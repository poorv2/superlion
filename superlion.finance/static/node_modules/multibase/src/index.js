/**
 * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.
 * @module Multibase
 */
'use strict';

var _require = require('buffer'),
    Buffer = _require.Buffer;

var constants = require('./constants');

exports = module.exports = multibase;
exports.encode = encode;
exports.decode = decode;
exports.isEncoded = isEncoded;
exports.names = Object.freeze(Object.keys(constants.names));
exports.codes = Object.freeze(Object.keys(constants.codes));
var errNotSupported = new Error('Unsupported encoding');
/**
 * Create a new buffer with the multibase varint+code.
 *
 * @param {string|number} nameOrCode - The multibase name or code number.
 * @param {Buffer} buf - The data to be prefixed with multibase.
 * @memberof Multibase
 * @returns {Buffer}
 */

function multibase(nameOrCode, buf) {
    if (!buf) {
        throw new Error('requires an encoded buffer');
    }

    var base = getBase(nameOrCode);
    var codeBuf = Buffer.from(base.code);
    var name = base.name;
    validEncode(name, buf);
    return Buffer.concat([codeBuf, buf]);
}
/**
 * Encode data with the specified base and add the multibase prefix.
 *
 * @param {string|number} nameOrCode - The multibase name or code number.
 * @param {Buffer} buf - The data to be encoded.
 * @returns {Buffer}
 * @memberof Multibase
 */


function encode(nameOrCode, buf) {
    var base = getBase(nameOrCode);
    var name = base.name;
    return multibase(name, Buffer.from(base.encode(buf)));
}
/**
 * Takes a buffer or string encoded with multibase header, decodes it and
 * returns the decoded buffer
 *
 * @param {Buffer|string} bufOrString
 * @returns {Buffer}
 * @memberof Multibase
 *
 */


function decode(bufOrString) {
    if (Buffer.isBuffer(bufOrString)) {
        bufOrString = bufOrString.toString();
    }

    var code = bufOrString.substring(0, 1);
    bufOrString = bufOrString.substring(1, bufOrString.length);

    if (typeof bufOrString === 'string') {
        bufOrString = Buffer.from(bufOrString);
    }

    var base = getBase(code);
    return Buffer.from(base.decode(bufOrString.toString()));
}
/**
 * Is the given data multibase encoded?
 *
 * @param {Buffer|string} bufOrString
 * @returns {boolean}
 * @memberof Multibase
 */


function isEncoded(bufOrString) {
    if (Buffer.isBuffer(bufOrString)) {
        bufOrString = bufOrString.toString();
    } // Ensure bufOrString is a string


    if (Object.prototype.toString.call(bufOrString) !== '[object String]') {
        return false;
    }

    var code = bufOrString.substring(0, 1);

    try {
        var base = getBase(code);
        return base.name;
    } catch (err) {
        return false;
    }
}
/**
 * @param {string} name
 * @param {Buffer} buf
 * @private
 * @returns {undefined}
 */


function validEncode(name, buf) {
    var base = getBase(name);
    base.decode(buf.toString());
}

function getBase(nameOrCode) {
    var base;

    if (constants.names[nameOrCode]) {
        base = constants.names[nameOrCode];
    } else if (constants.codes[nameOrCode]) {
        base = constants.codes[nameOrCode];
    } else {
        throw errNotSupported;
    }

    if (!base.isImplemented()) {
        throw new Error('Base ' + nameOrCode + ' is not implemented yet');
    }

    return base;
}