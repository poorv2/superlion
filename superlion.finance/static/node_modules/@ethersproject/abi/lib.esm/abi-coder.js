"use strict"; // See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI

import _classCallCheck from "/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass";
import {
    arrayify
} from "@ethersproject/bytes";
import {
    defineReadOnly
} from "@ethersproject/properties";
import {
    Logger
} from "@ethersproject/logger";
import {
    version
} from "./_version";
var logger = new Logger(version);
import {
    Reader,
    Writer
} from "./coders/abstract-coder";
import {
    AddressCoder
} from "./coders/address";
import {
    ArrayCoder
} from "./coders/array";
import {
    BooleanCoder
} from "./coders/boolean";
import {
    BytesCoder
} from "./coders/bytes";
import {
    FixedBytesCoder
} from "./coders/fixed-bytes";
import {
    NullCoder
} from "./coders/null";
import {
    NumberCoder
} from "./coders/number";
import {
    StringCoder
} from "./coders/string";
import {
    TupleCoder
} from "./coders/tuple";
import {
    ParamType
} from "./fragments";
var paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
var paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
export var AbiCoder = /*#__PURE__*/ function() {
    function AbiCoder(coerceFunc) {
        _classCallCheck(this, AbiCoder);

        logger.checkNew(this instanceof AbiCoder ? this.constructor : void 0, AbiCoder);
        defineReadOnly(this, "coerceFunc", coerceFunc || null);
    }

    _createClass(AbiCoder, [{
        key: "_getCoder",
        value: function _getCoder(param) {
            var _this = this;

            switch (param.baseType) {
                case "address":
                    return new AddressCoder(param.name);

                case "bool":
                    return new BooleanCoder(param.name);

                case "string":
                    return new StringCoder(param.name);

                case "bytes":
                    return new BytesCoder(param.name);

                case "array":
                    return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);

                case "tuple":
                    return new TupleCoder((param.components || []).map(function(component) {
                        return _this._getCoder(component);
                    }), param.name);

                case "":
                    return new NullCoder(param.name);
            } // u?int[0-9]*


            var match = param.type.match(paramTypeNumber);

            if (match) {
                var size = parseInt(match[2] || "256");

                if (size === 0 || size > 256 || size % 8 !== 0) {
                    logger.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
                }

                return new NumberCoder(size / 8, match[1] === "int", param.name);
            } // bytes[0-9]+


            match = param.type.match(paramTypeBytes);

            if (match) {
                var _size = parseInt(match[1]);

                if (_size === 0 || _size > 32) {
                    logger.throwArgumentError("invalid bytes length", "param", param);
                }

                return new FixedBytesCoder(_size, param.name);
            }

            return logger.throwArgumentError("invalid type", "type", param.type);
        }
    }, {
        key: "_getWordSize",
        value: function _getWordSize() {
            return 32;
        }
    }, {
        key: "_getReader",
        value: function _getReader(data, allowLoose) {
            return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
        }
    }, {
        key: "_getWriter",
        value: function _getWriter() {
            return new Writer(this._getWordSize());
        }
    }, {
        key: "encode",
        value: function encode(types, values) {
            var _this2 = this;

            if (types.length !== values.length) {
                logger.throwError("types/values length mismatch", Logger.errors.INVALID_ARGUMENT, {
                    count: {
                        types: types.length,
                        values: values.length
                    },
                    value: {
                        types: types,
                        values: values
                    }
                });
            }

            var coders = types.map(function(type) {
                return _this2._getCoder(ParamType.from(type));
            });
            var coder = new TupleCoder(coders, "_");

            var writer = this._getWriter();

            coder.encode(writer, values);
            return writer.data;
        }
    }, {
        key: "decode",
        value: function decode(types, data, loose) {
            var _this3 = this;

            var coders = types.map(function(type) {
                return _this3._getCoder(ParamType.from(type));
            });
            var coder = new TupleCoder(coders, "_");
            return coder.decode(this._getReader(arrayify(data), loose));
        }
    }]);

    return AbiCoder;
}();
export var defaultAbiCoder = new AbiCoder();