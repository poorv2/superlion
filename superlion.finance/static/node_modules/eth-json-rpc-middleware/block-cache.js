var _classCallCheck = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck");

var _createClass = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass");

var _regeneratorRuntime = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator");

var _asyncToGenerator = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator");

var cacheUtils = require('./cache-utils.js');

var createAsyncMiddleware = require('json-rpc-engine/src/createAsyncMiddleware'); // `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925


var emptyValues = [undefined, null, "<nil>"];
module.exports = createBlockCacheMiddleware;

function createBlockCacheMiddleware() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    // validate options
    var blockTracker = opts.blockTracker;
    if (!blockTracker) throw new Error('createBlockCacheMiddleware - No BlockTracker specified'); // create caching strategies

    var blockCache = new BlockCacheStrategy();
    var strategies = {
        perma: blockCache,
        block: blockCache,
        fork: blockCache
    };
    return createAsyncMiddleware( /*#__PURE__*/ function() {
        var _ref = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee(req, res, next) {
            var type, strategy, blockTag, requestedBlockNumber, latestBlockNumber, cacheResult;
            return _regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                    switch (_context.prev = _context.next) {
                        case 0:
                            if (!req.skipCache) {
                                _context.next = 2;
                                break;
                            }

                            return _context.abrupt("return", next());

                        case 2:
                            // check type and matching strategy
                            type = cacheUtils.cacheTypeForPayload(req);
                            strategy = strategies[type]; // If there's no strategy in place, pass it down the chain.

                            if (strategy) {
                                _context.next = 6;
                                break;
                            }

                            return _context.abrupt("return", next());

                        case 6:
                            if (strategy.canCacheRequest(req)) {
                                _context.next = 8;
                                break;
                            }

                            return _context.abrupt("return", next());

                        case 8:
                            // get block reference (number or keyword)
                            blockTag = cacheUtils.blockTagForPayload(req);
                            if (!blockTag) blockTag = 'latest'; // get exact block number

                            if (!(blockTag === 'earliest')) {
                                _context.next = 14;
                                break;
                            }

                            // this just exists for symmetry with "latest"
                            requestedBlockNumber = '0x00';
                            _context.next = 23;
                            break;

                        case 14:
                            if (!(blockTag === 'latest')) {
                                _context.next = 22;
                                break;
                            }

                            _context.next = 17;
                            return blockTracker.getLatestBlock();

                        case 17:
                            latestBlockNumber = _context.sent;
                            // clear all cache before latest block
                            blockCache.clearBefore(latestBlockNumber);
                            requestedBlockNumber = latestBlockNumber;
                            _context.next = 23;
                            break;

                        case 22:
                            // We have a hex number
                            requestedBlockNumber = blockTag;

                        case 23:
                            _context.next = 25;
                            return strategy.get(req, requestedBlockNumber);

                        case 25:
                            cacheResult = _context.sent;

                            if (!(cacheResult === undefined)) {
                                _context.next = 33;
                                break;
                            }

                            _context.next = 29;
                            return next();

                        case 29:
                            _context.next = 31;
                            return strategy.set(req, requestedBlockNumber, res.result);

                        case 31:
                            _context.next = 34;
                            break;

                        case 33:
                            // fill in result from cache
                            res.result = cacheResult;

                        case 34:
                        case "end":
                            return _context.stop();
                    }
                }
            }, _callee);
        }));

        return function(_x, _x2, _x3) {
            return _ref.apply(this, arguments);
        };
    }());
} //
// Cache Strategies
//


var BlockCacheStrategy = /*#__PURE__*/ function() {
    "use strict";

    function BlockCacheStrategy() {
        _classCallCheck(this, BlockCacheStrategy);

        this.cache = {};
    }

    _createClass(BlockCacheStrategy, [{
        key: "getBlockCacheForPayload",
        value: function getBlockCacheForPayload(payload, blockNumberHex) {
            var blockNumber = Number.parseInt(blockNumberHex, 16);
            var blockCache = this.cache[blockNumber]; // create new cache if necesary

            if (!blockCache) {
                var newCache = {};
                this.cache[blockNumber] = newCache;
                blockCache = newCache;
            }

            return blockCache;
        }
    }, {
        key: "get",
        value: function() {
            var _get = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee2(payload, requestedBlockNumber) {
                var blockCache, identifier, cached;
                return _regeneratorRuntime.wrap(function _callee2$(_context2) {
                    while (1) {
                        switch (_context2.prev = _context2.next) {
                            case 0:
                                // lookup block cache
                                blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);

                                if (blockCache) {
                                    _context2.next = 3;
                                    break;
                                }

                                return _context2.abrupt("return");

                            case 3:
                                // lookup payload in block cache
                                identifier = cacheUtils.cacheIdentifierForPayload(payload, true);
                                cached = blockCache[identifier]; // may be undefined

                                return _context2.abrupt("return", cached);

                            case 6:
                            case "end":
                                return _context2.stop();
                        }
                    }
                }, _callee2, this);
            }));

            function get(_x4, _x5) {
                return _get.apply(this, arguments);
            }

            return get;
        }()
    }, {
        key: "set",
        value: function() {
            var _set = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee3(payload, requestedBlockNumber, result) {
                var canCache, blockCache, identifier;
                return _regeneratorRuntime.wrap(function _callee3$(_context3) {
                    while (1) {
                        switch (_context3.prev = _context3.next) {
                            case 0:
                                // check if we can cached this result
                                canCache = this.canCacheResult(payload, result);

                                if (canCache) {
                                    _context3.next = 3;
                                    break;
                                }

                                return _context3.abrupt("return");

                            case 3:
                                // set the value in the cache
                                blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);
                                identifier = cacheUtils.cacheIdentifierForPayload(payload, true);
                                blockCache[identifier] = result;

                            case 6:
                            case "end":
                                return _context3.stop();
                        }
                    }
                }, _callee3, this);
            }));

            function set(_x6, _x7, _x8) {
                return _set.apply(this, arguments);
            }

            return set;
        }()
    }, {
        key: "canCacheRequest",
        value: function canCacheRequest(payload) {
            // check request method
            if (!cacheUtils.canCache(payload)) {
                return false;
            } // check blockTag


            var blockTag = cacheUtils.blockTagForPayload(payload);

            if (blockTag === 'pending') {
                return false;
            } // can be cached


            return true;
        }
    }, {
        key: "canCacheResult",
        value: function canCacheResult(payload, result) {
            // never cache empty values (e.g. undefined)
            if (emptyValues.includes(result)) return; // check if transactions have block reference before caching

            if (['eth_getTransactionByHash', 'eth_getTransactionReceipt'].includes(payload.method)) {
                if (!result || !result.blockHash || result.blockHash === '0x0000000000000000000000000000000000000000000000000000000000000000') {
                    return false;
                }
            } // otherwise true


            return true;
        } // removes all block caches with block number lower than `oldBlockHex`

    }, {
        key: "clearBefore",
        value: function clearBefore(oldBlockHex) {
            var self = this;
            var oldBlockNumber = Number.parseInt(oldBlockHex, 16); // clear old caches

            Object.keys(self.cache).map(Number).filter(function(num) {
                return num < oldBlockNumber;
            }).forEach(function(num) {
                return delete self.cache[num];
            });
        }
    }]);

    return BlockCacheStrategy;
}();