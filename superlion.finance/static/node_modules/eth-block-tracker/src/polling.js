var _regeneratorRuntime = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator");

var _asyncToGenerator = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator");

var _classCallCheck = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck");

var _createClass = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass");

var _possibleConstructorReturn = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf");

var _inherits = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits");

var pify = require('pify');

var BaseBlockTracker = require('./base');

var sec = 1000;

var PollingBlockTracker = /*#__PURE__*/ function(_BaseBlockTracker) {
    "use strict";

    _inherits(PollingBlockTracker, _BaseBlockTracker);

    function PollingBlockTracker() {
        var _this;

        var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        _classCallCheck(this, PollingBlockTracker);

        // parse + validate args
        if (!opts.provider) throw new Error('PollingBlockTracker - no provider specified.');
        var pollingInterval = opts.pollingInterval || 20 * sec;
        var retryTimeout = opts.retryTimeout || pollingInterval / 10;
        var keepEventLoopActive = opts.keepEventLoopActive !== undefined ? opts.keepEventLoopActive : true;
        var setSkipCacheFlag = opts.setSkipCacheFlag || false; // BaseBlockTracker constructor

        _this = _possibleConstructorReturn(this, _getPrototypeOf(PollingBlockTracker).call(this, Object.assign({
            blockResetDuration: pollingInterval
        }, opts))); // config

        _this._provider = opts.provider;
        _this._pollingInterval = pollingInterval;
        _this._retryTimeout = retryTimeout;
        _this._keepEventLoopActive = keepEventLoopActive;
        _this._setSkipCacheFlag = setSkipCacheFlag;
        return _this;
    } //
    // public
    //
    // trigger block polling


    _createClass(PollingBlockTracker, [{
        key: "checkForLatestBlock",
        value: function() {
            var _checkForLatestBlock = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee() {
                return _regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                _context.next = 2;
                                return this._updateLatestBlock();

                            case 2:
                                _context.next = 4;
                                return this.getLatestBlock();

                            case 4:
                                return _context.abrupt("return", _context.sent);

                            case 5:
                            case "end":
                                return _context.stop();
                        }
                    }
                }, _callee, this);
            }));

            function checkForLatestBlock() {
                return _checkForLatestBlock.apply(this, arguments);
            }

            return checkForLatestBlock;
        }() //
        // private
        //

    }, {
        key: "_start",
        value: function _start() {
            var _this2 = this;

            this._performSync().catch(function(err) {
                return _this2.emit('error', err);
            });
        }
    }, {
        key: "_performSync",
        value: function() {
            var _performSync2 = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee2() {
                var newErr;
                return _regeneratorRuntime.wrap(function _callee2$(_context2) {
                    while (1) {
                        switch (_context2.prev = _context2.next) {
                            case 0:
                                if (!this._isRunning) {
                                    _context2.next = 16;
                                    break;
                                }

                                _context2.prev = 1;
                                _context2.next = 4;
                                return this._updateLatestBlock();

                            case 4:
                                _context2.next = 6;
                                return timeout(this._pollingInterval, !this._keepEventLoopActive);

                            case 6:
                                _context2.next = 14;
                                break;

                            case 8:
                                _context2.prev = 8;
                                _context2.t0 = _context2["catch"](1);
                                newErr = new Error("PollingBlockTracker - encountered an error while attempting to update latest block:\n".concat(_context2.t0.stack));

                                try {
                                    this.emit('error', newErr);
                                } catch (emitErr) {
                                    console.error(newErr);
                                }

                                _context2.next = 14;
                                return timeout(this._retryTimeout, !this._keepEventLoopActive);

                            case 14:
                                _context2.next = 0;
                                break;

                            case 16:
                            case "end":
                                return _context2.stop();
                        }
                    }
                }, _callee2, this, [
                    [1, 8]
                ]);
            }));

            function _performSync() {
                return _performSync2.apply(this, arguments);
            }

            return _performSync;
        }()
    }, {
        key: "_updateLatestBlock",
        value: function() {
            var _updateLatestBlock2 = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee3() {
                var latestBlock;
                return _regeneratorRuntime.wrap(function _callee3$(_context3) {
                    while (1) {
                        switch (_context3.prev = _context3.next) {
                            case 0:
                                _context3.next = 2;
                                return this._fetchLatestBlock();

                            case 2:
                                latestBlock = _context3.sent;

                                this._newPotentialLatest(latestBlock);

                            case 4:
                            case "end":
                                return _context3.stop();
                        }
                    }
                }, _callee3, this);
            }));

            function _updateLatestBlock() {
                return _updateLatestBlock2.apply(this, arguments);
            }

            return _updateLatestBlock;
        }()
    }, {
        key: "_fetchLatestBlock",
        value: function() {
            var _fetchLatestBlock2 = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee4() {
                var _this3 = this;

                var req, res;
                return _regeneratorRuntime.wrap(function _callee4$(_context4) {
                    while (1) {
                        switch (_context4.prev = _context4.next) {
                            case 0:
                                req = {
                                    jsonrpc: "2.0",
                                    id: 1,
                                    method: 'eth_blockNumber',
                                    params: []
                                };
                                if (this._setSkipCacheFlag) req.skipCache = true;
                                _context4.next = 4;
                                return pify(function(cb) {
                                    return _this3._provider.sendAsync(req, cb);
                                })();

                            case 4:
                                res = _context4.sent;

                                if (!res.error) {
                                    _context4.next = 7;
                                    break;
                                }

                                throw new Error("PollingBlockTracker - encountered error fetching block:\n".concat(res.error));

                            case 7:
                                return _context4.abrupt("return", res.result);

                            case 8:
                            case "end":
                                return _context4.stop();
                        }
                    }
                }, _callee4, this);
            }));

            function _fetchLatestBlock() {
                return _fetchLatestBlock2.apply(this, arguments);
            }

            return _fetchLatestBlock;
        }()
    }]);

    return PollingBlockTracker;
}(BaseBlockTracker);

module.exports = PollingBlockTracker;

function timeout(duration, unref) {
    return new Promise(function(resolve) {
        var timoutRef = setTimeout(resolve, duration); // don't keep process open

        if (timoutRef.unref && unref) {
            timoutRef.unref();
        }
    });
}