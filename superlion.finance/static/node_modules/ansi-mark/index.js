var ansiRegex = require('ansi-regex');

var superSplit = require('super-split');

var arrayUniq = require('array-uniq');

var stripAnsi = require('strip-ansi');

var realignOutOfBoundsCoords = function realignOutOfBoundsCoords(text, opts) {
    var plain = stripAnsi(text);
    var lines = plain.split('\n');
    var totalLines = lines.length; // 'End.line marker out of bounds (max).'

    if (opts.end.line > totalLines) {
        opts.end.line = totalLines;
    } // 'Start.line marker out of bounds (min).'


    if (opts.start.line < 1) {
        opts.start.line = 1;
    } // 'Start.column marker out of bounds (min).'


    if (opts.start.column < 1) {
        opts.start.column = 1;
    } // 'End.column marker out of bounds (max).'


    if (opts.end.column > lines[opts.end.line - 1].length) {
        opts.end.column = lines[opts.end.line - 1].length;
    }

    if (opts.start.line > opts.end.line) {
        throw new Error('Your start line is after your end line.');
    }

    if (opts.start.line === opts.end.line && opts.end.column < opts.start.column) {
        throw new Error('Your end column is after your start column.');
    }

    return false;
}; // Returns arys:
// 1 - ANSI Escape sequences from section
// 2 - Glyphs in section (ansi escape seq - or - ascii character)


var atomize = function atomize(section) {
    var ansies = arrayUniq(section.match(ansiRegex()));
    var words = superSplit(section, ansies);
    var glyphs = [];
    words.forEach(function(word) {
        if (ansies.includes(word) === false) {
            glyphs = glyphs.concat(word.split(''));
            return;
        }

        glyphs.push(word);
    });
    return {
        ansies: ansies,
        glyphs: glyphs
    };
};

var markSection = function markSection(section, opts, linear) {
    var _atomize = atomize(section),
        ansies = _atomize.ansies,
        glyphs = _atomize.glyphs;

    var x = 0;
    var y = 0;
    var inPoint;
    var outPoint;
    var output = '';
    var height = opts.end.line - opts.start.line;

    var markNotBegun = function markNotBegun() {
        return typeof inPoint !== 'number' && typeof outPoint !== 'number';
    };

    var markHasEnded = function markHasEnded() {
        return typeof inPoint === 'number' && typeof outPoint === 'number';
    };

    var outsideOfMark = function outsideOfMark() {
        return markNotBegun() || markHasEnded();
    };

    glyphs.forEach(function(glyph) {
        if (ansies.includes(glyph) === false) {
            if (glyph === '\n' && !linear) {
                y += 1;
                x = -1;
            }

            x += 1;

            if (x === opts.start.column && y === 0) {
                inPoint = output.length;
            }

            output += glyph;

            if (x === opts.end.column && y === height) {
                outPoint = output.length;
            }

            return;
        }

        if (outsideOfMark()) {
            output += glyph;
        } else if (!outsideOfMark() && !opts.resetColor) {
            output += glyph;
        }
    });
    var pre = output.substr(0, inPoint);
    var mark = opts.color(output.substr(inPoint, outPoint - inPoint));
    var post = output.substr(outPoint);
    var sectionMarked = pre + mark + post;
    return sectionMarked;
};

var mark2d = function mark2d(text, opts) {
    realignOutOfBoundsCoords(text, opts);
    var lines = text.split('\n'); // Minus 1: because line and column numbers start at 1

    var startLine = opts.start.line - 1;
    var endLine = opts.end.line - 1; // Plus 1: because slice does not include the end indice

    var unmarkedSection = lines.slice(startLine, endLine + 1).join('\n');
    var preSection = lines.slice(0, startLine);
    var markedSection = markSection(unmarkedSection, opts);
    var postSection = lines.slice(endLine + 1);
    var result = preSection.concat([markedSection]).concat(postSection).join('\n');
    return result;
};

var mark1d = function mark1d(text, opts, linear) {
    var markedSection = markSection(text, opts, linear);
    return markedSection;
};

var mark = function mark(text, opts, linear) {
    return linear ? mark1d(text, opts, linear) : mark2d(text, opts);
};

var validMarkersNumbers = function validMarkersNumbers(opts) {
    return typeof opts.start === 'number' && typeof opts.end === 'number';
};

var validMarkersObject = function validMarkersObject(opts) {
    return typeof opts.start === 'object' && typeof opts.end === 'object' && typeof opts.start.line === 'number' && typeof opts.start.column === 'number' && typeof opts.end.line === 'number' && typeof opts.end.column === 'number';
};

var ansiMark = function ansiMark(text, opts) {
    if (validMarkersObject(opts)) {
        return mark(text, opts);
    }

    if (validMarkersNumbers(opts)) {
        opts.start = {
            line: 1,
            column: opts.start
        };
        opts.end = {
            line: 1,
            column: opts.end
        };
        var linear = true;
        return mark(text, opts, linear);
    }

    throw new Error('Invalid marker definition.');
};

module.exports = ansiMark;