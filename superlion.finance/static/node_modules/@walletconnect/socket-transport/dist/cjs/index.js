"use strict";

var _regeneratorRuntime = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator");

var _classCallCheck = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck");

var _createClass = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass");

Object.defineProperty(exports, "__esModule", {
    value: true
});

var tslib_1 = require("tslib");

var utils_1 = require("@walletconnect/utils");

var network_1 = tslib_1.__importDefault(require("./network"));

var WS = typeof global.WebSocket !== "undefined" ? global.WebSocket : require("ws");

var SocketTransport = /*#__PURE__*/ function() {
    function SocketTransport(opts) {
        var _this = this;

        _classCallCheck(this, SocketTransport);

        this._queue = [];
        this._events = [];
        this._subscriptions = [];
        this._protocol = opts.protocol;
        this._version = opts.version;
        this._url = "";
        this._netMonitor = null;
        this._socket = null;
        this._nextSocket = null;
        this._subscriptions = opts.subscriptions || [];
        this._netMonitor = opts.netMonitor || new network_1.default();

        if (!opts.url || typeof opts.url !== "string") {
            throw new Error("Missing or invalid WebSocket url");
        }

        this._url = opts.url;

        this._netMonitor.on("online", function() {
            return _this._socketCreate();
        });
    }

    _createClass(SocketTransport, [{
        key: "open",
        value: function open() {
            this._socketCreate();
        }
    }, {
        key: "close",
        value: function close() {
            this._socketClose();
        }
    }, {
        key: "send",
        value: function send(message, topic, silent) {
            if (!topic || typeof topic !== "string") {
                throw new Error("Missing or invalid topic field");
            }

            this._socketSend({
                topic: topic,
                type: "pub",
                payload: message,
                silent: !!silent
            });
        }
    }, {
        key: "subscribe",
        value: function subscribe(topic) {
            this._socketSend({
                topic: topic,
                type: "sub",
                payload: "",
                silent: true
            });
        }
    }, {
        key: "on",
        value: function on(event, callback) {
            this._events.push({
                event: event,
                callback: callback
            });
        }
    }, {
        key: "_socketCreate",
        value: function _socketCreate() {
            var _this2 = this;

            if (this._nextSocket) {
                return;
            }

            var url = getWebSocketUrl(this._url, this._protocol, this._version);
            this._nextSocket = new WS(url);

            if (!this._nextSocket) {
                throw new Error("Failed to create socket");
            }

            this._nextSocket.onmessage = function(event) {
                return _this2._socketReceive(event);
            };

            this._nextSocket.onopen = function() {
                return _this2._socketOpen();
            };

            this._nextSocket.onerror = function(event) {
                return _this2._socketError(event);
            };

            this._nextSocket.onclose = function() {
                _this2._nextSocket = null;

                _this2._socketCreate();
            };
        }
    }, {
        key: "_socketOpen",
        value: function _socketOpen() {
            this._socketClose();

            this._socket = this._nextSocket;
            this._nextSocket = null;

            this._queueSubscriptions();

            this._pushQueue();
        }
    }, {
        key: "_socketClose",
        value: function _socketClose() {
            if (this._socket) {
                this._socket.onclose = function() {};

                this._socket.close();
            }
        }
    }, {
        key: "_socketSend",
        value: function _socketSend(socketMessage) {
            var message = JSON.stringify(socketMessage);

            if (this._socket && this._socket.readyState === 1) {
                this._socket.send(message);
            } else {
                this._setToQueue(socketMessage);

                this._socketCreate();
            }
        }
    }, {
        key: "_socketReceive",
        value: function _socketReceive(event) {
            return tslib_1.__awaiter(this, void 0, void 0, /*#__PURE__*/ _regeneratorRuntime.mark(function _callee() {
                var socketMessage, events;
                return _regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                _context.prev = 0;
                                socketMessage = JSON.parse(event.data);
                                _context.next = 7;
                                break;

                            case 4:
                                _context.prev = 4;
                                _context.t0 = _context["catch"](0);
                                return _context.abrupt("return");

                            case 7:
                                this._socketSend({
                                    topic: socketMessage.topic,
                                    type: "ack",
                                    payload: "",
                                    silent: true
                                });

                                if (this._socket && this._socket.readyState === 1) {
                                    events = this._events.filter(function(event) {
                                        return event.event === "message";
                                    });

                                    if (events && events.length) {
                                        events.forEach(function(event) {
                                            return event.callback(socketMessage);
                                        });
                                    }
                                }

                            case 9:
                            case "end":
                                return _context.stop();
                        }
                    }
                }, _callee, this, [
                    [0, 4]
                ]);
            }));
        }
    }, {
        key: "_socketError",
        value: function _socketError(e) {
            var events = this._events.filter(function(event) {
                return event.event === "error";
            });

            if (events && events.length) {
                events.forEach(function(event) {
                    return event.callback(e);
                });
            }
        }
    }, {
        key: "_queueSubscriptions",
        value: function _queueSubscriptions() {
            var _this3 = this;

            var subscriptions = this._subscriptions;
            subscriptions.forEach(function(topic) {
                return _this3._queue.push({
                    topic: topic,
                    type: "sub",
                    payload: "",
                    silent: true
                });
            });
            this._subscriptions = [];
        }
    }, {
        key: "_setToQueue",
        value: function _setToQueue(socketMessage) {
            this._queue.push(socketMessage);
        }
    }, {
        key: "_pushQueue",
        value: function _pushQueue() {
            var _this4 = this;

            var queue = this._queue;
            queue.forEach(function(socketMessage) {
                return _this4._socketSend(socketMessage);
            });
            this._queue = [];
        }
    }, {
        key: "readyState",
        set: function set(value) {},
        get: function get() {
            return this._socket ? this._socket.readyState : -1;
        }
    }, {
        key: "connecting",
        set: function set(value) {},
        get: function get() {
            return this.readyState === 0;
        }
    }, {
        key: "connected",
        set: function set(value) {},
        get: function get() {
            return this.readyState === 1;
        }
    }, {
        key: "closing",
        set: function set(value) {},
        get: function get() {
            return this.readyState === 2;
        }
    }, {
        key: "closed",
        set: function set(value) {},
        get: function get() {
            return this.readyState === 3;
        }
    }]);

    return SocketTransport;
}();

function getWebSocketUrl(_url, protocol, version) {
    var _a, _b;

    var url = _url.startsWith("https") ? _url.replace("https", "wss") : _url.startsWith("http") ? _url.replace("http", "ws") : _url;
    var splitUrl = url.split("?");
    var params = utils_1.isBrowser() ? {
        protocol: protocol,
        version: version,
        env: "browser",
        host: ((_a = utils_1.getLocation()) === null || _a === void 0 ? void 0 : _a.host) || ""
    } : {
        protocol: protocol,
        version: version,
        env: ((_b = utils_1.detectEnv()) === null || _b === void 0 ? void 0 : _b.name) || ""
    };
    var queryString = utils_1.appendToQueryString(utils_1.getQueryString(splitUrl[1] || ""), params);
    return splitUrl[0] + "?" + queryString;
}

exports.default = SocketTransport;