"use strict";

var _regeneratorRuntime = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator");

function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {};
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true,
        didErr = false,
        err;
    return {
        s: function s() {
            it = o[Symbol.iterator]();
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally {
                if (didErr) throw err;
            }
        }
    };
}

function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
    }
    return arr2;
}

var _marked = /*#__PURE__*/ _regeneratorRuntime.mark(decodeAbi),
    _marked2 = /*#__PURE__*/ _regeneratorRuntime.mark(decodeAbiReferenceByAddress),
    _marked3 = /*#__PURE__*/ _regeneratorRuntime.mark(decodeAbiReferenceStatic),
    _marked4 = /*#__PURE__*/ _regeneratorRuntime.mark(decodeAbiStructByPosition),
    _marked5 = /*#__PURE__*/ _regeneratorRuntime.mark(decodeAbiTupleByPosition);

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});

var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
        for (var k in mod) {
            if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }

    __setModuleDefault(result, mod);

    return result;
};

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.decodeAbiReferenceStatic = exports.decodeAbiReferenceByAddress = exports.decodeAbi = void 0;

var debug_1 = __importDefault(require("debug"));

var debug = debug_1.default("codec:abi-data:decode");

var read_1 = __importDefault(require("../../read"));

var Conversion = __importStar(require("../../conversion"));

var Basic = __importStar(require("../../basic"));

var Bytes = __importStar(require("../../bytes"));

var Format = __importStar(require("../../format"));

var Evm = __importStar(require("../../evm"));

var allocate_1 = require("../allocate");

var errors_1 = require("../../errors");

function decodeAbi(dataType, pointer, info) {
    var options,
        dynamic,
        _args = arguments;
    return _regeneratorRuntime.wrap(function decodeAbi$(_context) {
        while (1) {
            switch (_context.prev = _context.next) {
                case 0:
                    options = _args.length > 3 && _args[3] !== undefined ? _args[3] : {};

                    if (!(Format.Types.isReferenceType(dataType) || dataType.typeClass === "tuple")) {
                        _context.next = 18;
                        break;
                    }

                    _context.prev = 2;
                    dynamic = allocate_1.abiSizeInfo(dataType, info.allocations.abi).dynamic;
                    _context.next = 9;
                    break;

                case 6:
                    _context.prev = 6;
                    _context.t0 = _context["catch"](2);
                    return _context.abrupt("return", errors_1.handleDecodingError(dataType, _context.t0, options.strictAbiMode));

                case 9:
                    if (!dynamic) {
                        _context.next = 14;
                        break;
                    }

                    return _context.delegateYield(decodeAbiReferenceByAddress(dataType, pointer, info, options), "t1", 11);

                case 11:
                    return _context.abrupt("return", _context.t1);

                case 14:
                    return _context.delegateYield(decodeAbiReferenceStatic(dataType, pointer, info, options), "t2", 15);

                case 15:
                    return _context.abrupt("return", _context.t2);

                case 16:
                    _context.next = 21;
                    break;

                case 18:
                    debug("pointer %o", pointer);
                    return _context.delegateYield(Basic.Decode.decodeBasic(dataType, pointer, info, options), "t3", 20);

                case 20:
                    return _context.abrupt("return", _context.t3);

                case 21:
                case "end":
                    return _context.stop();
            }
        }
    }, _marked, null, [
        [2, 6]
    ]);
}

exports.decodeAbi = decodeAbi;

function decodeAbiReferenceByAddress(dataType, pointer, info) {
    var options,
        strict,
        base,
        lengthOverride,
        allocations,
        state,
        location,
        rawValue,
        rawValueAsBN,
        rawValueAsNumber,
        error,
        startPosition,
        dynamic,
        size,
        _allocate_1$abiSizeIn,
        staticPointer,
        length,
        lengthAsBN,
        rawLength,
        childPointer,
        baseSize,
        decodedChildren,
        index,
        _args2 = arguments;

    return _regeneratorRuntime.wrap(function decodeAbiReferenceByAddress$(_context2) {
        while (1) {
            switch (_context2.prev = _context2.next) {
                case 0:
                    options = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : {};
                    strict = options.strictAbiMode, base = options.abiPointerBase, lengthOverride = options.lengthOverride;
                    base = base || 0; //in case base was undefined

                    allocations = info.allocations.abi, state = info.state;
                    debug("pointer %o", pointer); //this variable holds the location we should look to *next*
                    //stack pointers point to calldata; other pointers point to same location

                    location = pointer.location === "stack" || pointer.location === "stackliteral" ? "calldata" : pointer.location;

                    if (pointer.location !== "stack" && pointer.location !== "stackliteral") {
                        //length overrides are only applicable when you're decoding a pointer
                        //from the stack!  otherwise they must be ignored!
                        lengthOverride = undefined;
                    }

                    _context2.prev = 7;
                    return _context2.delegateYield(read_1.default(pointer, state), "t0", 9);

                case 9:
                    rawValue = _context2.t0;
                    _context2.next = 15;
                    break;

                case 12:
                    _context2.prev = 12;
                    _context2.t1 = _context2["catch"](7);
                    return _context2.abrupt("return", errors_1.handleDecodingError(dataType, _context2.t1, strict));

                case 15:
                    rawValueAsBN = Conversion.toBN(rawValue);
                    debug("rawValue: %O", rawValue);
                    debug("rawValueAsBN: %O", rawValueAsBN);
                    _context2.prev = 18;
                    rawValueAsNumber = rawValueAsBN.toNumber();
                    _context2.next = 28;
                    break;

                case 22:
                    _context2.prev = 22;
                    _context2.t2 = _context2["catch"](18);
                    error = {
                        kind: "OverlargePointersNotImplementedError",
                        pointerAsBN: rawValueAsBN
                    };

                    if (!strict) {
                        _context2.next = 27;
                        break;
                    }

                    throw new errors_1.StopDecodingError(error);

                case 27:
                    return _context2.abrupt("return", {
                        //again with the TS failures...
                        type: dataType,
                        kind: "error",
                        error: error
                    });

                case 28:
                    startPosition = rawValueAsNumber + base;
                    debug("startPosition %d", startPosition);
                    _context2.prev = 30;
                    _allocate_1$abiSizeIn = allocate_1.abiSizeInfo(dataType, allocations);
                    dynamic = _allocate_1$abiSizeIn.dynamic;
                    size = _allocate_1$abiSizeIn.size;
                    _context2.next = 39;
                    break;

                case 36:
                    _context2.prev = 36;
                    _context2.t3 = _context2["catch"](30);
                    return _context2.abrupt("return", errors_1.handleDecodingError(dataType, _context2.t3, strict));

                case 39:
                    if (dynamic) {
                        _context2.next = 43;
                        break;
                    }

                    //this will only come up when called from stack.ts
                    staticPointer = {
                        location: location,
                        start: startPosition,
                        length: size
                    };
                    return _context2.delegateYield(decodeAbiReferenceStatic(dataType, staticPointer, info, options), "t4", 42);

                case 42:
                    return _context2.abrupt("return", _context2.t4);

                case 43:
                    _context2.t5 = dataType.typeClass;
                    _context2.next = _context2.t5 === "bytes" ? 46 : _context2.t5 === "string" ? 46 : _context2.t5 === "array" ? 72 : _context2.t5 === "struct" ? 118 : _context2.t5 === "tuple" ? 120 : 122;
                    break;

                case 46:
                    if (!(lengthOverride !== undefined)) {
                        _context2.next = 50;
                        break;
                    }

                    lengthAsBN = lengthOverride; //note in this case we do *not* increment start position;
                    //if a length override is given, that means the given start
                    //position skips over the length word!

                    _context2.next = 60;
                    break;

                case 50:
                    _context2.prev = 50;
                    return _context2.delegateYield(read_1.default({
                        location: location,
                        start: startPosition,
                        length: Evm.Utils.WORD_SIZE
                    }, state), "t6", 52);

                case 52:
                    rawLength = _context2.t6;
                    _context2.next = 58;
                    break;

                case 55:
                    _context2.prev = 55;
                    _context2.t7 = _context2["catch"](50);
                    return _context2.abrupt("return", errors_1.handleDecodingError(dataType, _context2.t7, strict));

                case 58:
                    lengthAsBN = Conversion.toBN(rawLength);
                    startPosition += Evm.Utils.WORD_SIZE; //increment start position after reading length
                    //so it'll be set up to read the data

                case 60:
                    if (!(strict && lengthAsBN.gtn(state[location].length))) {
                        _context2.next = 62;
                        break;
                    }

                    throw new errors_1.StopDecodingError({
                        kind: "OverlongArrayOrStringStrictModeError",
                        lengthAsBN: lengthAsBN,
                        dataLength: state[location].length
                    });

                case 62:
                    _context2.prev = 62;
                    length = lengthAsBN.toNumber();
                    _context2.next = 69;
                    break;

                case 66:
                    _context2.prev = 66;
                    _context2.t8 = _context2["catch"](62);
                    return _context2.abrupt("return", {
                        //again with the TS failures...
                        type: dataType,
                        kind: "error",
                        error: {
                            kind: "OverlongArraysAndStringsNotImplementedError",
                            lengthAsBN: lengthAsBN
                        }
                    });

                case 69:
                    childPointer = {
                        location: location,
                        start: startPosition,
                        length: length
                    };
                    return _context2.delegateYield(Bytes.Decode.decodeBytes(dataType, childPointer, info, options), "t9", 71);

                case 71:
                    return _context2.abrupt("return", _context2.t9);

                case 72:
                    if (!(dataType.kind === "static")) {
                        _context2.next = 76;
                        break;
                    }

                    //static-length array
                    lengthAsBN = dataType.length; //note we don't increment start position; static arrays don't
                    //include a length word!

                    _context2.next = 91;
                    break;

                case 76:
                    if (!(lengthOverride !== undefined)) {
                        _context2.next = 81;
                        break;
                    }

                    debug("override: %o", lengthOverride); //dynamic-length array, but with length override

                    lengthAsBN = lengthOverride; //we don't increment start position; if a length override was
                    //given, that means the pointer skipped the length word!

                    _context2.next = 91;
                    break;

                case 81:
                    _context2.prev = 81;
                    return _context2.delegateYield(read_1.default({
                        location: location,
                        start: startPosition,
                        length: Evm.Utils.WORD_SIZE
                    }, state), "t10", 83);

                case 83:
                    rawLength = _context2.t10;
                    _context2.next = 89;
                    break;

                case 86:
                    _context2.prev = 86;
                    _context2.t11 = _context2["catch"](81);
                    return _context2.abrupt("return", errors_1.handleDecodingError(dataType, _context2.t11, strict));

                case 89:
                    lengthAsBN = Conversion.toBN(rawLength);
                    startPosition += Evm.Utils.WORD_SIZE; //increment startPosition
                    //to next word, as first word was used for length

                case 91:
                    if (!(strict && lengthAsBN.gtn(state[location].length))) {
                        _context2.next = 93;
                        break;
                    }

                    throw new errors_1.StopDecodingError({
                        kind: "OverlongArraysAndStringsNotImplementedError",
                        lengthAsBN: lengthAsBN,
                        dataLength: state[location].length
                    });

                case 93:
                    _context2.prev = 93;
                    length = lengthAsBN.toNumber();
                    _context2.next = 100;
                    break;

                case 97:
                    _context2.prev = 97;
                    _context2.t12 = _context2["catch"](93);
                    return _context2.abrupt("return", {
                        type: dataType,
                        kind: "error",
                        error: {
                            kind: "OverlongArraysAndStringsNotImplementedError",
                            lengthAsBN: lengthAsBN
                        }
                    });

                case 100:
                    _context2.prev = 100;
                    baseSize = allocate_1.abiSizeInfo(dataType.baseType, allocations).size;
                    _context2.next = 107;
                    break;

                case 104:
                    _context2.prev = 104;
                    _context2.t13 = _context2["catch"](100);
                    return _context2.abrupt("return", errors_1.handleDecodingError(dataType, _context2.t13, strict));

                case 107:
                    decodedChildren = [];
                    index = 0;

                case 109:
                    if (!(index < length)) {
                        _context2.next = 117;
                        break;
                    }

                    _context2.t14 = decodedChildren;
                    return _context2.delegateYield(decodeAbi(dataType.baseType, {
                        location: location,
                        start: startPosition + index * baseSize,
                        length: baseSize
                    }, info, Object.assign(Object.assign({}, options), {
                        abiPointerBase: startPosition
                    })), "t15", 112);

                case 112:
                    _context2.t16 = _context2.t15;

                    _context2.t14.push.call(_context2.t14, _context2.t16);

                case 114:
                    index++;
                    _context2.next = 109;
                    break;

                case 117:
                    return _context2.abrupt("return", {
                        type: dataType,
                        kind: "value",
                        value: decodedChildren
                    });

                case 118:
                    return _context2.delegateYield(decodeAbiStructByPosition(dataType, location, startPosition, info, options), "t17", 119);

                case 119:
                    return _context2.abrupt("return", _context2.t17);

                case 120:
                    return _context2.delegateYield(decodeAbiTupleByPosition(dataType, location, startPosition, info, options), "t18", 121);

                case 121:
                    return _context2.abrupt("return", _context2.t18);

                case 122:
                case "end":
                    return _context2.stop();
            }
        }
    }, _marked2, null, [
        [7, 12],
        [18, 22],
        [30, 36],
        [50, 55],
        [62, 66],
        [81, 86],
        [93, 97],
        [100, 104]
    ]);
}

exports.decodeAbiReferenceByAddress = decodeAbiReferenceByAddress;

function decodeAbiReferenceStatic(dataType, pointer, info) {
    var options,
        location,
        lengthAsBN,
        length,
        error,
        baseSize,
        decodedChildren,
        index,
        _args3 = arguments;
    return _regeneratorRuntime.wrap(function decodeAbiReferenceStatic$(_context3) {
        while (1) {
            switch (_context3.prev = _context3.next) {
                case 0:
                    options = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : {};
                    debug("static");
                    debug("pointer %o", pointer);
                    location = pointer.location;
                    _context3.t0 = dataType.typeClass;
                    _context3.next = _context3.t0 === "array" ? 7 : _context3.t0 === "struct" ? 36 : _context3.t0 === "tuple" ? 38 : 40;
                    break;

                case 7:
                    //we're in the static case, so we know the array must be statically sized
                    lengthAsBN = dataType.length;
                    _context3.prev = 8;
                    length = lengthAsBN.toNumber();
                    _context3.next = 18;
                    break;

                case 12:
                    _context3.prev = 12;
                    _context3.t1 = _context3["catch"](8);
                    //note: since this is the static case, we don't bother including the stronger
                    //strict-mode guard against getting DOSed by large array sizes, since in this
                    //case we're not reading the size from the input; if there's a huge static size
                    //array, well, we'll just have to deal with it
                    error = {
                        kind: "OverlongArraysAndStringsNotImplementedError",
                        lengthAsBN: lengthAsBN
                    };

                    if (!options.strictAbiMode) {
                        _context3.next = 17;
                        break;
                    }

                    throw new errors_1.StopDecodingError(error);

                case 17:
                    return _context3.abrupt("return", {
                        type: dataType,
                        kind: "error",
                        error: error
                    });

                case 18:
                    _context3.prev = 18;
                    baseSize = allocate_1.abiSizeInfo(dataType.baseType, info.allocations.abi).size;
                    _context3.next = 25;
                    break;

                case 22:
                    _context3.prev = 22;
                    _context3.t2 = _context3["catch"](18);
                    return _context3.abrupt("return", errors_1.handleDecodingError(dataType, _context3.t2, options.strictAbiMode));

                case 25:
                    decodedChildren = [];
                    index = 0;

                case 27:
                    if (!(index < length)) {
                        _context3.next = 35;
                        break;
                    }

                    _context3.t3 = decodedChildren;
                    return _context3.delegateYield(decodeAbi(dataType.baseType, {
                        location: location,
                        start: pointer.start + index * baseSize,
                        length: baseSize
                    }, info, options), "t4", 30);

                case 30:
                    _context3.t5 = _context3.t4;

                    _context3.t3.push.call(_context3.t3, _context3.t5);

                case 32:
                    index++;
                    _context3.next = 27;
                    break;

                case 35:
                    return _context3.abrupt("return", {
                        type: dataType,
                        kind: "value",
                        value: decodedChildren
                    });

                case 36:
                    return _context3.delegateYield(decodeAbiStructByPosition(dataType, location, pointer.start, info, options), "t6", 37);

                case 37:
                    return _context3.abrupt("return", _context3.t6);

                case 38:
                    return _context3.delegateYield(decodeAbiTupleByPosition(dataType, location, pointer.start, info, options), "t7", 39);

                case 39:
                    return _context3.abrupt("return", _context3.t7);

                case 40:
                case "end":
                    return _context3.stop();
            }
        }
    }, _marked3, null, [
        [8, 12],
        [18, 22]
    ]);
}

exports.decodeAbiReferenceStatic = decodeAbiReferenceStatic; //note that this function takes the start position as a *number*; it does not take a pointer

function decodeAbiStructByPosition(dataType, location, startPosition, info) {
    var options,
        allocations,
        typeLocation,
        typeId,
        structAllocation,
        error,
        decodedMembers,
        index,
        memberAllocation,
        memberPointer,
        childPointer,
        memberName,
        memberType,
        _args4 = arguments;
    return _regeneratorRuntime.wrap(function decodeAbiStructByPosition$(_context4) {
        while (1) {
            switch (_context4.prev = _context4.next) {
                case 0:
                    options = _args4.length > 4 && _args4[4] !== undefined ? _args4[4] : {};
                    allocations = info.allocations.abi;
                    typeLocation = location === "calldata" ? "calldata" : null; //other abi locations are not valid type locations

                    typeId = dataType.id;
                    structAllocation = allocations[typeId];

                    if (structAllocation) {
                        _context4.next = 10;
                        break;
                    }

                    error = {
                        kind: "UserDefinedTypeNotFoundError",
                        type: dataType
                    };

                    if (!(options.strictAbiMode || options.allowRetry)) {
                        _context4.next = 9;
                        break;
                    }

                    throw new errors_1.StopDecodingError(error, true);

                case 9:
                    return _context4.abrupt("return", {
                        type: dataType,
                        kind: "error",
                        error: error
                    });

                case 10:
                    decodedMembers = [];
                    index = 0;

                case 12:
                    if (!(index < structAllocation.members.length)) {
                        _context4.next = 27;
                        break;
                    }

                    memberAllocation = structAllocation.members[index];
                    memberPointer = memberAllocation.pointer;
                    childPointer = {
                        location: location,
                        start: startPosition + memberPointer.start,
                        length: memberPointer.length
                    };
                    memberName = memberAllocation.name;
                    memberType = Format.Types.specifyLocation(memberAllocation.type, typeLocation);
                    _context4.t0 = decodedMembers;
                    _context4.t1 = memberName;
                    return _context4.delegateYield(decodeAbi(memberType, childPointer, info, Object.assign(Object.assign({}, options), {
                        abiPointerBase: startPosition
                    })), "t2", 21);

                case 21:
                    _context4.t3 = _context4.t2;
                    _context4.t4 = {
                        name: _context4.t1,
                        value: _context4.t3
                    };

                    _context4.t0.push.call(_context4.t0, _context4.t4);

                case 24:
                    index++;
                    _context4.next = 12;
                    break;

                case 27:
                    return _context4.abrupt("return", {
                        type: dataType,
                        kind: "value",
                        value: decodedMembers
                    });

                case 28:
                case "end":
                    return _context4.stop();
            }
        }
    }, _marked4);
} //note that this function takes the start position as a *number*; it does not take a pointer


function decodeAbiTupleByPosition(dataType, location, startPosition, info) {
    var options,
        decodedMembers,
        position,
        _iterator,
        _step,
        _step$value,
        name,
        memberType,
        memberSize,
        childPointer,
        _args5 = arguments;

    return _regeneratorRuntime.wrap(function decodeAbiTupleByPosition$(_context5) {
        while (1) {
            switch (_context5.prev = _context5.next) {
                case 0:
                    options = _args5.length > 4 && _args5[4] !== undefined ? _args5[4] : {};
                    //WARNING: This case is written in a way that involves a bunch of unnecessary recomputation!
                    //I'm writing it this way anyway for simplicity, to avoid rewriting the decoder
                    //However it may be worth revisiting this in the future if performance turns out to be a problem
                    //(changing this may be pretty hard though)
                    decodedMembers = [];
                    position = startPosition;
                    _iterator = _createForOfIteratorHelper(dataType.memberTypes);
                    _context5.prev = 4;

                    _iterator.s();

                case 6:
                    if ((_step = _iterator.n()).done) {
                        _context5.next = 19;
                        break;
                    }

                    _step$value = _step.value, name = _step$value.name, memberType = _step$value.type;
                    memberSize = allocate_1.abiSizeInfo(memberType, info.allocations.abi).size;
                    childPointer = {
                        location: location,
                        start: position,
                        length: memberSize
                    };
                    _context5.t0 = decodedMembers;
                    _context5.t1 = name;
                    return _context5.delegateYield(decodeAbi(memberType, childPointer, info, Object.assign(Object.assign({}, options), {
                        abiPointerBase: startPosition
                    })), "t2", 13);

                case 13:
                    _context5.t3 = _context5.t2;
                    _context5.t4 = {
                        name: _context5.t1,
                        value: _context5.t3
                    };

                    _context5.t0.push.call(_context5.t0, _context5.t4);

                    position += memberSize;

                case 17:
                    _context5.next = 6;
                    break;

                case 19:
                    _context5.next = 24;
                    break;

                case 21:
                    _context5.prev = 21;
                    _context5.t5 = _context5["catch"](4);

                    _iterator.e(_context5.t5);

                case 24:
                    _context5.prev = 24;

                    _iterator.f();

                    return _context5.finish(24);

                case 27:
                    return _context5.abrupt("return", {
                        type: dataType,
                        kind: "value",
                        value: decodedMembers
                    });

                case 28:
                case "end":
                    return _context5.stop();
            }
        }
    }, _marked5, null, [
        [4, 21, 24, 27]
    ]);
}