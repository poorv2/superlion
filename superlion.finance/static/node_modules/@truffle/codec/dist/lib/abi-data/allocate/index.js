"use strict";

var _slicedToArray = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray");

function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {};
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true,
        didErr = false,
        err;
    return {
        s: function s() {
            it = o[Symbol.iterator]();
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally {
                if (didErr) throw err;
            }
        }
    };
}

function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
    }
    return arr2;
}

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});

var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
        for (var k in mod) {
            if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }

    __setModuleDefault(result, mod);

    return result;
};

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getEventAllocations = exports.getCalldataAllocations = exports.abiSizeInfo = exports.getAbiAllocations = exports.FallbackOutputAllocation = void 0;

var debug_1 = __importDefault(require("debug"));

var debug = debug_1.default("codec:abi-data:allocate");

var Import = __importStar(require("../import"));

var AbiDataUtils = __importStar(require("../utils"));

var Evm = __importStar(require("../../evm"));

var Common = __importStar(require("../../common"));

var Ast = __importStar(require("../../ast"));

var Format = __importStar(require("../../format"));

var lodash_partition_1 = __importDefault(require("lodash.partition"));

exports.FallbackOutputAllocation = {
    kind: "returnmessage",
    selector: new Uint8Array(),
    allocationMode: "full"
};

function getAbiAllocations(userDefinedTypes) {
    var allocations = {};

    for (var _i = 0, _Object$values = Object.values(userDefinedTypes); _i < _Object$values.length; _i++) {
        var dataType = _Object$values[_i];

        if (dataType.typeClass === "struct") {
            try {
                allocations = allocateStruct(dataType, userDefinedTypes, allocations);
            } catch (_) { //if allocation fails... oh well, allocation fails, we do nothing and just move on :P
                //note: a better way of handling this would probably be to *mark* it
                //as failed rather than throwing an exception as that would lead to less
                //recomputation, but this is simpler and I don't think the recomputation
                //should really be a problem
            }
        }
    }

    return allocations;
}

exports.getAbiAllocations = getAbiAllocations;

function allocateStruct(dataType, userDefinedTypes, existingAllocations) {
    //NOTE: dataType here should be a *stored* type!
    //it is up to the caller to take care of this
    return allocateMembers(dataType.id, dataType.memberTypes, userDefinedTypes, existingAllocations);
} //note: we will still allocate circular structs, even though they're not allowed in the abi, because it's
//not worth the effort to detect them.  However on mappings or internal functions, we'll vomit (allocate null)


function allocateMembers(parentId, members, userDefinedTypes, existingAllocations) {
    var start = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var dynamic = false; //note that we will mutate the start argument also!
    //don't allocate things that have already been allocated

    if (parentId in existingAllocations) {
        return existingAllocations;
    }

    var allocations = Object.assign({}, existingAllocations); //otherwise, we'll be adding to this, so we better clone

    var memberAllocations = [];

    var _iterator = _createForOfIteratorHelper(members),
        _step;

    try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var member = _step.value;
            var length = void 0;
            var dynamicMember = void 0;

            var _abiSizeAndAllocate = abiSizeAndAllocate(member.type, userDefinedTypes, allocations);

            length = _abiSizeAndAllocate.size;
            dynamicMember = _abiSizeAndAllocate.dynamic;
            allocations = _abiSizeAndAllocate.allocations;

            //vomit on illegal types in calldata -- note the short-circuit!
            if (length === undefined) {
                allocations[parentId] = null;
                return allocations;
            }

            var pointer = {
                location: "abi",
                start: start,
                length: length
            };
            memberAllocations.push({
                name: member.name,
                type: member.type,
                pointer: pointer
            });
            start += length;
            dynamic = dynamic || dynamicMember;
        }
    } catch (err) {
        _iterator.e(err);
    } finally {
        _iterator.f();
    }

    allocations[parentId] = {
        members: memberAllocations,
        length: dynamic ? Evm.Utils.WORD_SIZE : start,
        dynamic: dynamic
    };
    return allocations;
} //first return value is the actual size.
//second return value is whether the type is dynamic
//both will be undefined if type is a mapping or internal function
//third return value is resulting allocations, INCLUDING the ones passed in


function abiSizeAndAllocate(dataType, userDefinedTypes, existingAllocations) {
    switch (dataType.typeClass) {
        case "bool":
        case "address":
        case "contract":
        case "int":
        case "uint":
        case "fixed":
        case "ufixed":
        case "enum":
            return {
                size: Evm.Utils.WORD_SIZE,
                dynamic: false,
                allocations: existingAllocations
            };

        case "string":
            return {
                size: Evm.Utils.WORD_SIZE,
                dynamic: true,
                allocations: existingAllocations
            };

        case "bytes":
            return {
                size: Evm.Utils.WORD_SIZE,
                dynamic: dataType.kind === "dynamic",
                allocations: existingAllocations
            };

        case "mapping":
            return {
                allocations: existingAllocations
            };

        case "function":
            switch (dataType.visibility) {
                case "external":
                    return {
                        size: Evm.Utils.WORD_SIZE,
                        dynamic: false,
                        allocations: existingAllocations
                    };

                case "internal":
                    return {
                        allocations: existingAllocations
                    };
            }

        case "array":
            {
                switch (dataType.kind) {
                    case "dynamic":
                        return {
                            size: Evm.Utils.WORD_SIZE,
                            dynamic: true,
                            allocations: existingAllocations
                        };

                    case "static":
                        if (dataType.length.isZero()) {
                            //arrays of length 0 are static regardless of base type
                            return {
                                size: 0,
                                dynamic: false,
                                allocations: existingAllocations
                            };
                        }

                        var _abiSizeAndAllocate2 = abiSizeAndAllocate(dataType.baseType, userDefinedTypes, existingAllocations),
                            baseSize = _abiSizeAndAllocate2.size,
                            dynamic = _abiSizeAndAllocate2.dynamic,
                            allocations = _abiSizeAndAllocate2.allocations;

                        return {
                            //WARNING!  The use of toNumber() here may throw an exception!
                            //I'm judging this OK since if you have arrays that large we have bigger problems :P
                            size: dataType.length.toNumber() * baseSize,
                            dynamic: dynamic,
                            allocations: allocations
                        };
                }
            }

        case "struct":
            {
                var _allocations = existingAllocations;
                var allocation = _allocations[dataType.id];

                if (allocation === undefined) {
                    //if we don't find an allocation, we'll have to do the allocation ourselves
                    var storedType = userDefinedTypes[dataType.id];

                    if (!storedType) {
                        throw new Common.UnknownUserDefinedTypeError(dataType.id, Format.Types.typeString(dataType));
                    }

                    _allocations = allocateStruct(storedType, userDefinedTypes, existingAllocations);
                    allocation = _allocations[storedType.id];
                } //having found our allocation, if it's not null, we can just look up its size and dynamicity


                if (allocation !== null) {
                    return {
                        size: allocation.length,
                        dynamic: allocation.dynamic,
                        allocations: _allocations
                    };
                } //if it is null, this type doesn't go in the abi
                else {
                    return {
                        allocations: _allocations
                    };
                }
            }

        case "tuple":
            {
                //Warning! Yucky wasteful recomputation here!
                var size = 0;
                var _dynamic = false; //note that we don't just invoke allocateStruct here!
                //why not? because it has no ID to store the result in!
                //and we can't use a fake like -1 because there might be a recursive call to it,
                //and then the results would overwrite each other
                //I mean, we could do some hashing thing or something, but I think it's easier to just
                //copy the logic in this one case (sorry)

                var _iterator2 = _createForOfIteratorHelper(dataType.memberTypes),
                    _step2;

                try {
                    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                        var member = _step2.value;

                        var _abiSizeAndAllocate3 = abiSizeAndAllocate(member.type, userDefinedTypes, existingAllocations),
                            memberSize = _abiSizeAndAllocate3.size,
                            memberDynamic = _abiSizeAndAllocate3.dynamic;

                        size += memberSize;
                        _dynamic = _dynamic || memberDynamic;
                    }
                } catch (err) {
                    _iterator2.e(err);
                } finally {
                    _iterator2.f();
                }

                return {
                    size: size,
                    dynamic: _dynamic,
                    allocations: existingAllocations
                };
            }
    }
} //assumes you've already done allocation! don't use if you haven't!

/**
 * @protected
 */


function abiSizeInfo(dataType, allocations) {
    var _abiSizeAndAllocate4 = abiSizeAndAllocate(dataType, null, allocations),
        size = _abiSizeAndAllocate4.size,
        dynamic = _abiSizeAndAllocate4.dynamic; //the above line should work fine... as long as allocation is already done!
    //the middle argument, userDefinedTypes, is only needed during allocation
    //again, this function is only for use if allocation is done, so it's safe to pass null here


    return {
        size: size,
        dynamic: dynamic
    };
}

exports.abiSizeInfo = abiSizeInfo; //allocates an external call
//NOTE: returns just a single allocation; assumes primary allocation is already complete!
//NOTE: returns undefined if attempting to allocate a constructor but we don't have the
//bytecode for the constructor

function allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext) {
    //first: determine the corresponding function node
    //(simultaneously: determine the offset)
    var node = undefined;
    var inputParametersFull;
    var outputParametersFull;
    var inputParametersAbi;
    var outputParametersAbi;
    var offset; //refers to INPUT offset; output offset is always 0

    switch (abiEntry.type) {
        case "constructor":
            if (!constructorContext) {
                return undefined;
            }

            var rawLength = constructorContext.binary.length;
            offset = (rawLength - 2) / 2; //number of bytes in 0x-prefixed bytestring
            //for a constructor, we only want to search the particular contract

            if (contractNode) {
                node = contractNode.nodes.find(function(functionNode) {
                    return AbiDataUtils.definitionMatchesAbi( //note this needn't actually be a function node, but then it will
                        //return false (well, unless it's a getter node!)
                        abiEntry, functionNode, referenceDeclarations);
                });
            } //if we can't find it, we'll handle this below


            break;

        case "function":
            offset = Evm.Utils.SELECTOR_SIZE; //search through base contracts, from most derived (left) to most base (right)

            if (contractNode) {
                var linearizedBaseContracts = contractNode.linearizedBaseContracts;
                debug("linearized: %O", linearizedBaseContracts);
                node = findNodeAndContract(linearizedBaseContracts, referenceDeclarations, function(functionNode) {
                    return AbiDataUtils.definitionMatchesAbi(abiEntry, functionNode, referenceDeclarations);
                }, contractNode).node; //may be undefined!  that's OK!
            }

            break;
    } //now: get the parameters (both full-mode & ABI)


    if (node) {
        switch (node.nodeType) {
            case "FunctionDefinition":
                //normal case
                inputParametersFull = node.parameters.parameters;
                outputParametersFull = node.returnParameters.parameters; //this exists even for constructors!

                break;

            case "VariableDeclaration":
                //getter case
                var _Ast$Utils$getterPara = Ast.Utils.getterParameters(node, referenceDeclarations);

                inputParametersFull = _Ast$Utils$getterPara.inputs;
                outputParametersFull = _Ast$Utils$getterPara.outputs;
                break;
        }
    } else {
        inputParametersFull = undefined;
        outputParametersFull = undefined;
    }

    inputParametersAbi = abiEntry.inputs;

    switch (abiEntry.type) {
        case "function":
            outputParametersAbi = abiEntry.outputs;
            break;

        case "constructor":
            //we just leave this empty for constructors
            outputParametersAbi = [];
            break;
    } //now: do the allocation!


    var _allocateDataArgument = allocateDataArguments(inputParametersFull, inputParametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler, offset),
        abiAllocationInput = _allocateDataArgument.allocation,
        inputMode = _allocateDataArgument.mode;

    var _allocateDataArgument2 = allocateDataArguments(outputParametersFull, outputParametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler //note no offset
        ),
        abiAllocationOutput = _allocateDataArgument2.allocation,
        outputMode = _allocateDataArgument2.mode; //finally: transform the allocation appropriately


    var inputArgumentsAllocation = abiAllocationInput.members.map(function(member) {
        return Object.assign(Object.assign({}, member), {
            pointer: {
                location: "calldata",
                start: member.pointer.start,
                length: member.pointer.length
            }
        });
    });
    var outputArgumentsAllocation = abiAllocationOutput.members.map(function(member) {
        return Object.assign(Object.assign({}, member), {
            pointer: {
                location: "returndata",
                start: member.pointer.start,
                length: member.pointer.length
            }
        });
    });
    var inputsAllocation = {
        abi: abiEntry,
        offset: offset,
        arguments: inputArgumentsAllocation,
        allocationMode: inputMode
    };
    var outputsAllocation;

    switch (abiEntry.type) {
        case "function":
            outputsAllocation = {
                selector: new Uint8Array(),
                arguments: outputArgumentsAllocation,
                allocationMode: outputMode,
                kind: "return"
            };
            break;

        case "constructor":
            outputsAllocation = constructorOutputAllocation(deployedContext, contractNode, referenceDeclarations, outputMode);
            break;
    }

    return {
        input: inputsAllocation,
        output: outputsAllocation
    };
} //note: allocateEvent doesn't use this because it needs additional
//handling for indexed parameters (maybe these can be unified in
//the future though?)


function allocateDataArguments(fullModeParameters, abiParameters, userDefinedTypes, abiAllocations, compilationId, compiler) {
    var offset = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
    var allocationMode = fullModeParameters ? "full" : "abi"; //can degrade

    var parameterTypes;
    var abiAllocation;

    if (allocationMode === "full") {
        var id = "-1"; //fake ID that doesn't matter

        parameterTypes = fullModeParameters.map(function(parameter) {
            return {
                name: parameter.name,
                type: Ast.Import.definitionToType(parameter, compilationId, compiler) //if node is defined, compiler had also better be!

            };
        });
        debug("parameterTypes: %O", parameterTypes); //now: perform the allocation!

        try {
            abiAllocation = allocateMembers(id, parameterTypes, userDefinedTypes, abiAllocations, offset)[id];
        } catch (_a) {
            //if something goes wrong, switch to ABI mdoe
            allocationMode = "abi";
        }
    }

    if (allocationMode === "abi") {
        //THIS IS DELIBERATELY NOT AN ELSE
        //this is the ABI case.  we end up here EITHER
        //if node doesn't exist, OR if something went wrong
        //during allocation
        var _id = "-1"; //fake irrelevant ID

        parameterTypes = abiParameters.map(function(parameter) {
            return {
                name: parameter.name,
                type: Import.abiParameterToType(parameter)
            };
        });
        abiAllocation = allocateMembers(_id, parameterTypes, userDefinedTypes, abiAllocations, offset)[_id];
    }

    return {
        allocation: abiAllocation,
        mode: allocationMode
    };
} //allocates an event
//NOTE: returns just a single allocation; assumes primary allocation is already complete!


function allocateEvent(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {
    var parameterTypes;
    var id; //first: determine the corresponding event node
    //search through base contracts, from most derived (right) to most base (left)

    var node = undefined;
    var definedIn = undefined;
    var allocationMode = "full"; //degrade to abi as needed

    debug("allocating ABI: %O", abiEntry);

    if (contractNode) {
        //first: check same contract for the event
        node = contractNode.nodes.find(function(eventNode) {
            return AbiDataUtils.definitionMatchesAbi( //note this needn't actually be an event node, but then it will
                //return false
                abiEntry, eventNode, referenceDeclarations);
        }); //if we found the node, great!  If not...

        if (!node) {
            debug("didn't find node in base contract..."); //let's search for the node among the base contracts.
            //but if we find it...
            //[note: the following code is overcomplicated; it was used
            //when we were trying to get the actual node, it's overcomplicated
            //now that we're just determining its presence.  oh well]

            var linearizedBaseContractsMinusSelf = contractNode.linearizedBaseContracts.slice();
            linearizedBaseContractsMinusSelf.shift(); //remove self

            debug("checking contracts: %o", linearizedBaseContractsMinusSelf);
            node = findNodeAndContract(linearizedBaseContractsMinusSelf, referenceDeclarations, function(eventNode) {
                    return AbiDataUtils.definitionMatchesAbi( //note this needn't actually be a event node, but then it will return false
                        abiEntry, eventNode, referenceDeclarations);
                } //don't pass deriveContractNode here, we're not checking the contract itself
            ).node; //may be undefined! that's OK!

            if (node) {
                //...if we find the node in an ancestor, we
                //deliberately *don't* allocate!  instead such cases
                //will be handled during a later combination step
                debug("bailing out for later handling!");
                debug("ABI: %O", abiEntry);
                return undefined;
            }
        }
    } //otherwise, leave node undefined


    if (node) {
        debug("found node"); //if we found the node, let's also turn it into a type

        definedIn = Ast.Import.definitionToStoredType(contractNode, compilationId, compiler); //can skip reference declarations argument here
    } else {
        //if no node, have to fall back into ABI mode
        debug("falling back to ABI because no node");
        allocationMode = "abi";
    } //now: construct the list of parameter types, attaching indexedness info
    //and overall position (for later reconstruction)


    var indexed;
    var nonIndexed;
    var abiAllocation; //the untransformed allocation for the non-indexed parameters

    if (allocationMode === "full") {
        var _id2 = node.id.toString();

        var parameters = node.parameters.parameters;
        parameterTypes = parameters.map(function(definition) {
            return {
                //note: if node is defined, compiler had better be defined, too!
                type: Ast.Import.definitionToType(definition, compilationId, compiler),
                name: definition.name,
                indexed: definition.indexed
            };
        }); //now: split the list of parameters into indexed and non-indexed

        var _lodash_partition_1$d = lodash_partition_1.default(parameterTypes, function(parameter) {
            return parameter.indexed;
        });

        var _lodash_partition_1$d2 = _slicedToArray(_lodash_partition_1$d, 2);

        indexed = _lodash_partition_1$d2[0];
        nonIndexed = _lodash_partition_1$d2[1];

        try {
            //now: perform the allocation for the non-indexed parameters!
            abiAllocation = allocateMembers(_id2, nonIndexed, userDefinedTypes, abiAllocations)[_id2]; //note the implicit conversion from EventParameterInfo to NameTypePair
        } catch (_a) {
            allocationMode = "abi";
        }
    }

    if (allocationMode === "abi") {
        //THIS IS DELIBERATELY NOT AN ELSE
        id = "-1"; //fake irrelevant ID

        parameterTypes = abiEntry.inputs.map(function(abiParameter) {
            return {
                type: Import.abiParameterToType(abiParameter),
                name: abiParameter.name,
                indexed: abiParameter.indexed
            };
        }); //now: split the list of parameters into indexed and non-indexed

        var _lodash_partition_1$d3 = lodash_partition_1.default(parameterTypes, function(parameter) {
            return parameter.indexed;
        });

        var _lodash_partition_1$d4 = _slicedToArray(_lodash_partition_1$d3, 2);

        indexed = _lodash_partition_1$d4[0];
        nonIndexed = _lodash_partition_1$d4[1];
        //now: perform the allocation for the non-indexed parameters!
        abiAllocation = allocateMembers(id, nonIndexed, userDefinedTypes, abiAllocations)[id]; //note the implicit conversion from EventParameterInfo to NameTypePair
    } //now: transform the result appropriately


    var nonIndexedArgumentsAllocation = abiAllocation.members.map(function(member) {
        return Object.assign(Object.assign({}, member), {
            pointer: {
                location: "eventdata",
                start: member.pointer.start,
                length: member.pointer.length
            }
        });
    }); //now: allocate the indexed parameters

    var startingTopic = abiEntry.anonymous ? 0 : 1; //if not anonymous, selector takes up topic 0

    var indexedArgumentsAllocation = indexed.map(function(_ref, position) {
        var type = _ref.type,
            name = _ref.name;
        return {
            type: type,
            name: name,
            pointer: {
                location: "eventtopic",
                topic: startingTopic + position
            }
        };
    }); //finally: weave these back together

    var argumentsAllocation = [];

    var _iterator3 = _createForOfIteratorHelper(parameterTypes),
        _step3;

    try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var parameter = _step3.value;
            var arrayToGrabFrom = parameter.indexed ? indexedArgumentsAllocation : nonIndexedArgumentsAllocation;
            argumentsAllocation.push(arrayToGrabFrom.shift()); //note that push and shift both modify!
        } //...and return

    } catch (err) {
        _iterator3.e(err);
    } finally {
        _iterator3.f();
    }

    return {
        abi: abiEntry,
        contextHash: undefined,
        definedIn: definedIn,
        arguments: argumentsAllocation,
        allocationMode: allocationMode,
        anonymous: abiEntry.anonymous
    };
}

function getCalldataAllocationsForContract(abi, contractNode, constructorContext, deployedContext, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {
    var allocations = {
        constructorAllocation: undefined,
        //(if it doesn't then it will remain as default)
        functionAllocations: {}
    };

    if (!abi) {
        //if no ABI, can't do much!
        allocations.constructorAllocation = defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext);
        return allocations;
    }

    var _iterator4 = _createForOfIteratorHelper(abi),
        _step4;

    try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var abiEntry = _step4.value;

            if (AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry) || AbiDataUtils.abiEntryHasStorageParameters(abiEntry)) {
                //the first of these conditions is a hack workaround for a Solidity bug.
                //the second of these is because... seriously? we're not handling these
                //(at least not for now!) (these only exist prior to Solidity 0.5.6,
                //thankfully)
                continue;
            }

            switch (abiEntry.type) {
                case "constructor":
                    allocations.constructorAllocation = allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext);
                    debug("constructor alloc: %O", allocations.constructorAllocation);
                    break;

                case "function":
                    allocations.functionAllocations[AbiDataUtils.abiSelector(abiEntry)] = allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext);
                    break;

                default:
                    //skip over fallback and event
                    break;
            }
        }
    } catch (err) {
        _iterator4.e(err);
    } finally {
        _iterator4.f();
    }

    if (!allocations.constructorAllocation) {
        //set a default constructor allocation if we haven't allocated one yet
        allocations.constructorAllocation = defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext);
        debug("default constructor alloc: %O", allocations.constructorAllocation);
    }

    return allocations;
}

function defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext) {
    if (!constructorContext) {
        return undefined;
    }

    var rawLength = constructorContext.binary.length;
    var offset = (rawLength - 2) / 2; //number of bytes in 0x-prefixed bytestring

    var input = {
        offset: offset,
        abi: AbiDataUtils.DEFAULT_CONSTRUCTOR_ABI,
        arguments: [],
        allocationMode: "full"
    };
    var output = constructorOutputAllocation(deployedContext, contractNode, referenceDeclarations, "full"); //assume full, degrade as necessary

    return {
        input: input,
        output: output
    };
} //note: context should be deployed context!


function constructorOutputAllocation(context, contractNode, referenceDeclarations, allocationMode) {
    if (!context) {
        //just return a default abi mode result
        return {
            selector: new Uint8Array(),
            allocationMode: "abi",
            kind: "bytecode",
            delegatecallGuard: false
        };
    }

    var immutableReferences = context.immutableReferences,
        compilationId = context.compilationId,
        compiler = context.compiler,
        contractKind = context.contractKind,
        binary = context.binary;
    var immutables;

    if (allocationMode === "full" && immutableReferences) {
        if (contractNode) {
            debug("allocating immutables");
            immutables = [];

            var _loop = function _loop() {
                var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
                    id = _Object$entries$_i[0],
                    references = _Object$entries$_i[1];

                if (references.length === 0) {
                    return "continue"; //don't allocate immutables that don't exist
                }

                var astId = parseInt(id); //get the corresponding variable node; potentially fail

                var _findNodeAndContract = findNodeAndContract(contractNode.linearizedBaseContracts, referenceDeclarations, function(node) {
                        return node.id === astId;
                    }, contractNode),
                    definition = _findNodeAndContract.node,
                    definedIn = _findNodeAndContract.contract;

                if (!definition || definition.nodeType !== "VariableDeclaration") {
                    debug("didn't find definition for %d!", astId);
                    allocationMode = "abi";
                    immutables = undefined;
                    return "break";
                }

                var definedInClass = Ast.Import.definitionToStoredType(definedIn, compilationId, compiler); //can skip reference declarations argument here

                var dataType = Ast.Import.definitionToType(definition, compilationId, compiler);
                immutables.push({
                    name: definition.name,
                    definedIn: definedInClass,
                    type: dataType,
                    pointer: {
                        location: "returndata",
                        start: references[0].start,
                        length: references[0].length
                    }
                });
            };

            for (var _i2 = 0, _Object$entries = Object.entries(immutableReferences); _i2 < _Object$entries.length; _i2++) {
                var _ret = _loop();

                if (_ret === "continue") continue;
                if (_ret === "break") break;
            }
        } else if (Object.entries(immutableReferences).length > 0) {
            //if there are immutables, but no contract mode, go to abi mode
            debug("immutables but no node!");
            allocationMode = "abi";
        }
    } else {
        debug("no immutables");
    } //now, is there a delegatecall guard?


    var delegatecallGuard = false;

    if (contractKind === "library") {
        //note: I am relying on this being present!
        //(also this part is a bit HACKy)
        var pushAddressInstruction = (0x60 + Evm.Utils.ADDRESS_SIZE - 1).toString(16); //"73"

        var delegateCallGuardString = "0x" + pushAddressInstruction + "..".repeat(Evm.Utils.ADDRESS_SIZE);

        if (binary.startsWith(delegateCallGuardString)) {
            delegatecallGuard = true;
        }
    }

    return {
        selector: new Uint8Array(),
        allocationMode: allocationMode,
        kind: "bytecode",
        immutables: immutables,
        delegatecallGuard: delegatecallGuard
    };
}

function getCalldataAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations) {
    var allocations = {
        constructorAllocations: {},
        functionAllocations: {}
    };

    var _iterator5 = _createForOfIteratorHelper(contracts),
        _step5;

    try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var contract = _step5.value;
            var contractAllocations = getCalldataAllocationsForContract(contract.abi, contract.contractNode, contract.constructorContext, contract.deployedContext, referenceDeclarations[contract.compilationId], userDefinedTypes, abiAllocations, contract.compilationId, contract.compiler);

            if (contract.constructorContext) {
                allocations.constructorAllocations[contract.constructorContext.context] = contractAllocations.constructorAllocation;
            }

            if (contract.deployedContext) {
                allocations.functionAllocations[contract.deployedContext.context] = contractAllocations.functionAllocations; //set this up under both constructor *and* deployed! this is to handle
                //constructor returndata decoding

                allocations.constructorAllocations[contract.deployedContext.context] = contractAllocations.constructorAllocation;
            }
        }
    } catch (err) {
        _iterator5.e(err);
    } finally {
        _iterator5.f();
    }

    return allocations;
}

exports.getCalldataAllocations = getCalldataAllocations;

function getEventAllocationsForContract(abi, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {
    return abi.filter(function(abiEntry) {
            return abiEntry.type === "event";
        }).filter(function(abiEntry) {
            return !AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry);
        }) //hack workaround
        .map(function(abiEntry) {
            return {
                selector: AbiDataUtils.abiSelector(abiEntry),
                anonymous: abiEntry.anonymous,
                topics: AbiDataUtils.topicsCount(abiEntry),
                allocation: allocateEvent(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler)
            };
        }); //note we do *not* filter out undefined allocations; we need these as placeholders
} //note: constructor context is ignored by this function; no need to pass it in
//WARNING: this function is full of hacks... sorry


function getEventAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations) {
    //first: do allocations for individual contracts
    var individualAllocations = {};
    var groupedAllocations = {};
    var allocations = {};

    var _iterator6 = _createForOfIteratorHelper(contracts),
        _step6;

    try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var _step6$value = _step6.value,
                abi = _step6$value.abi,
                deployedContext = _step6$value.deployedContext,
                contractNode = _step6$value.contractNode,
                compilationId = _step6$value.compilationId,
                compiler = _step6$value.compiler;

            if (!deployedContext && !contractNode) {
                //we'll need *one* of these two at least
                continue;
            }

            var contractAllocations = getEventAllocationsForContract(abi, contractNode, referenceDeclarations[compilationId], userDefinedTypes, abiAllocations, compilationId, compiler);
            var key = makeContractKey(deployedContext, contractNode ? contractNode.id : undefined, compilationId);

            if (individualAllocations[key] === undefined) {
                individualAllocations[key] = {};
            }

            var _iterator9 = _createForOfIteratorHelper(contractAllocations),
                _step9;

            try {
                for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
                    var allocationTemporary = _step9.value;
                    //we'll use selector *even for anonymous* here, because it's just
                    //for determining what overrides what at this point
                    individualAllocations[key][allocationTemporary.selector] = {
                        context: deployedContext,
                        contractNode: contractNode,
                        allocationTemporary: allocationTemporary,
                        compilationId: compilationId
                    };
                }
            } catch (err) {
                _iterator9.e(err);
            } finally {
                _iterator9.f();
            }
        } //now: put things together for inheritance
        //note how we always put things in order from most derived to most base

    } catch (err) {
        _iterator6.e(err);
    } finally {
        _iterator6.f();
    }

    for (var contextOrId in individualAllocations) {
        groupedAllocations[contextOrId] = {};

        var _loop2 = function _loop2(selector) {
            var _individualAllocation = individualAllocations[contextOrId][selector],
                context = _individualAllocation.context,
                contractNode = _individualAllocation.contractNode,
                allocationTemporary = _individualAllocation.allocationTemporary,
                compilationId = _individualAllocation.compilationId;
            debug("allocationTemporary: %O", allocationTemporary);
            var allocationsTemporary = allocationTemporary.allocation ? [allocationTemporary] : []; //filter out undefined allocations
            //first, copy from individual allocations

            groupedAllocations[contextOrId][selector] = {
                context: context,
                contractNode: contractNode,
                allocationsTemporary: allocationsTemporary
            }; //if no contract node, that's all.  if there is...

            if (contractNode) {
                //...we have to do inheritance processing
                debug("contract Id: %d", contractNode.id);
                debug("base contracts: %o", contractNode.linearizedBaseContracts);
                var linearizedBaseContractsMinusSelf = contractNode.linearizedBaseContracts.slice();
                linearizedBaseContractsMinusSelf.shift(); //remove contract itself; only want ancestors

                var _iterator7 = _createForOfIteratorHelper(linearizedBaseContractsMinusSelf),
                    _step7;

                try {
                    var _loop3 = function _loop3() {
                        var baseId = _step7.value;
                        debug("checking baseId: %d", baseId);
                        var baseNode = referenceDeclarations[compilationId][baseId];

                        if (!baseNode || baseNode.nodeType !== "ContractDefinition") {
                            debug("failed to find node for baseId: %d", baseId);
                            return "break"; //not a continue!
                            //if we can't find the base node, it's better to stop the loop,
                            //rather than continue to potentially erroneous things
                        } //note: we're not actually going to *use* the baseNode here.
                        //we're just checking for whether we can *find* it
                        //why? because if we couldn't find it, that means that events defined in
                        //base contracts *weren't* skipped earlier, and so we shouldn't now add them in


                        var baseContractInfo = contracts.find(function(contractAllocationInfo) {
                            return contractAllocationInfo.compilationId === compilationId && contractAllocationInfo.contractNode && contractAllocationInfo.contractNode.id === baseId;
                        });

                        if (!baseContractInfo) {
                            //similar to above... this failure case can happen when there are
                            //two contracts with the same name and you attempt to use the
                            //artifacts; say you have contracts A, B, and B', where A inherits
                            //from B, and B and B' have the same name, and B' is the one that
                            //gets the artifact; B will end up in reference declarations and so
                            //get found above, but it won't appear in contracts, causing the
                            //problem here.  Unfortunately I don't know any great way to handle this,
                            //so, uh, we treat it as a failure same as above.
                            debug("failed to find contract info for baseId: %d", baseId);
                            return "break";
                        }

                        var baseContext = baseContractInfo.deployedContext;
                        var baseKey = makeContractKey(baseContext, baseId, compilationId);

                        if (individualAllocations[baseKey][selector] !== undefined) {
                            var baseAllocation = individualAllocations[baseKey][selector].allocationTemporary;
                            debug("(probably) pushing inherited alloc from baseId: %d", baseId);

                            if (baseAllocation.allocation) {
                                //don't push undefined!
                                groupedAllocations[contextOrId][selector].allocationsTemporary.push(baseAllocation);
                            }
                        }
                    };

                    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                        var _ret2 = _loop3();

                        if (_ret2 === "break") break;
                    }
                } catch (err) {
                    _iterator7.e(err);
                } finally {
                    _iterator7.f();
                }
            }
        };

        for (var selector in individualAllocations[contextOrId]) {
            _loop2(selector);
        }
    } //finally: transform into final form & return,
    //filtering out things w/o a context


    for (var contractKey in groupedAllocations) {
        if (!hasContext(contractKey)) {
            continue; //(this filters out ones that had no context and therefore were
            //given by ID; we needed these at the previous stage but from
            //here on they're irrelevant)
        }

        var contextHash = contextHashForKey(contractKey);

        for (var _selector in groupedAllocations[contextHash]) {
            var _groupedAllocations$c = groupedAllocations[contextHash][_selector],
                allocationsTemporary = _groupedAllocations$c.allocationsTemporary,
                context = _groupedAllocations$c.context;

            var _iterator8 = _createForOfIteratorHelper(allocationsTemporary),
                _step8;

            try {
                for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                    var _step8$value = _step8.value,
                        anonymous = _step8$value.anonymous,
                        topics = _step8$value.topics,
                        allocation = _step8$value.allocation;
                    var contractKind = context.contractKind; //HACK: this is the wrong context, but libraries can't inherit, so it's OK

                    if (contractKind !== "library") {
                        contractKind = "contract"; //round off interfaces to being contracts for our purposes :P
                    }

                    allocation = Object.assign(Object.assign({}, allocation), {
                        contextHash: contextHash
                    }); //the allocation's context hash at this point depends on where it was defined, but
                    //that's not what we want going in the final allocation table!

                    if (allocations[topics] === undefined) {
                        allocations[topics] = {
                            bySelector: {},
                            anonymous: {
                                contract: {},
                                library: {}
                            }
                        };
                    }

                    if (!anonymous) {
                        if (allocations[topics].bySelector[_selector] === undefined) {
                            allocations[topics].bySelector[_selector] = {
                                contract: {},
                                library: {}
                            };
                        }

                        if (allocations[topics].bySelector[_selector][contractKind][contextHash] === undefined) {
                            allocations[topics].bySelector[_selector][contractKind][contextHash] = [];
                        }

                        allocations[topics].bySelector[_selector][contractKind][contextHash].push(allocation);
                    } else {
                        if (allocations[topics].anonymous[contractKind][contextHash] === undefined) {
                            allocations[topics].anonymous[contractKind][contextHash] = [];
                        }

                        allocations[topics].anonymous[contractKind][contextHash].push(allocation);
                    }
                }
            } catch (err) {
                _iterator8.e(err);
            } finally {
                _iterator8.f();
            }
        }
    }

    return allocations;
}

exports.getEventAllocations = getEventAllocations; //if derivedContractNode is passed, we check that before referenceDeclarations

function findNodeAndContract(linearizedBaseContracts, referenceDeclarations, condition, derivedContractNode) {
    var searchResult = linearizedBaseContracts.reduce(function(foundNodeAndContract, baseContractId) {
            if (foundNodeAndContract !== undefined) {
                return foundNodeAndContract; //once we've found something, we don't need to keep looking
            }

            debug("searching contract %d", baseContractId);
            var baseContractNode = derivedContractNode && baseContractId === derivedContractNode.id ? derivedContractNode //skip the lookup if we already have the right node! this is to reduce errors from collision
                :
                referenceDeclarations[baseContractId];

            if (baseContractNode === undefined || baseContractNode.nodeType !== "ContractDefinition") {
                debug("bad contract node!");
                return null; //return null rather than undefined so that this will propagate through
                //(i.e. by returning null here we give up the search)
                //(we don't want to continue due to possibility of grabbing the wrong override)
            }

            var node = baseContractNode.nodes.find(condition); //may be undefined! that's OK!

            if (node) {
                debug("found node: %o", node);
                return {
                    node: node,
                    contract: baseContractNode
                };
            } else {
                return undefined;
            }
        }, undefined //start with no node found
    );
    return searchResult || {
        node: undefined,
        contract: undefined
    };
}

function makeContractKey(context, id, compilationId) {
    return context ? context.context : id + ":" + compilationId; //HACK!
}

function hasContext(key) {
    return key.startsWith("0x"); //HACK!
}

function contextHashForKey(key) {
    return hasContext(key) ? key //HACK!
        :
        undefined;
}