"use strict";

var _regeneratorRuntime = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator");

var _marked = /*#__PURE__*/ _regeneratorRuntime.mark(decodeConstant);

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});

var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
        for (var k in mod) {
            if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }

    __setModuleDefault(result, mod);

    return result;
};

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.decodeConstant = void 0;

var debug_1 = __importDefault(require("debug"));

var debug = debug_1.default("codec:ast:decode");

var read_1 = __importDefault(require("../../read"));

var Conversion = __importStar(require("../../conversion"));

var Basic = __importStar(require("../../basic"));

var Bytes = __importStar(require("../../bytes"));

var Evm = __importStar(require("../../evm"));

var errors_1 = require("../../errors");

function decodeConstant(dataType, pointer, info) {
    var size, word, bytes;
    return _regeneratorRuntime.wrap(function decodeConstant$(_context) {
        while (1) {
            switch (_context.prev = _context.next) {
                case 0:
                    debug("pointer %o", pointer); //normally, we just dispatch to decodeBasic or decodeBytes.
                    //for statically-sized bytes, however, we need to make a special case.
                    //you see, decodeBasic expects to find the bytes at the *beginning*
                    //of the word, but readDefinition will put them at the *end* of the
                    //word.  So we'll have to adjust things ourselves.

                    if (!(dataType.typeClass === "bytes" && dataType.kind === "static")) {
                        _context.next = 13;
                        break;
                    }

                    size = dataType.length;
                    _context.prev = 3;
                    return _context.delegateYield(read_1.default(pointer, info.state), "t0", 5);

                case 5:
                    word = _context.t0;
                    _context.next = 11;
                    break;

                case 8:
                    _context.prev = 8;
                    _context.t1 = _context["catch"](3);
                    return _context.abrupt("return", errors_1.handleDecodingError(dataType, _context.t1));

                case 11:
                    //not bothering to check padding; shouldn't be necessary
                    bytes = word.slice(Evm.Utils.WORD_SIZE - size);
                    return _context.abrupt("return", {
                        type: dataType,
                        kind: "value",
                        value: {
                            asHex: Conversion.toHexString(bytes)
                        }
                    });

                case 13:
                    //otherwise, as mentioned, just dispatch to decodeBasic or decodeBytes
                    debug("not a static bytes");

                    if (!(dataType.typeClass === "bytes" || dataType.typeClass === "string")) {
                        _context.next = 17;
                        break;
                    }

                    return _context.delegateYield(Bytes.Decode.decodeBytes(dataType, pointer, info), "t2", 16);

                case 16:
                    return _context.abrupt("return", _context.t2);

                case 17:
                    return _context.delegateYield(Basic.Decode.decodeBasic(dataType, pointer, info), "t3", 18);

                case 18:
                    return _context.abrupt("return", _context.t3);

                case 19:
                case "end":
                    return _context.stop();
            }
        }
    }, _marked, null, [
        [3, 8]
    ]);
}

exports.decodeConstant = decodeConstant;