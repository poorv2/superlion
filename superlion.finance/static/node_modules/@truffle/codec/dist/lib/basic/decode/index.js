"use strict";

var _regeneratorRuntime = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator");

var _marked = /*#__PURE__*/ _regeneratorRuntime.mark(decodeBasic),
    _marked2 = /*#__PURE__*/ _regeneratorRuntime.mark(decodeContract),
    _marked3 = /*#__PURE__*/ _regeneratorRuntime.mark(decodeContractAndContext),
    _marked4 = /*#__PURE__*/ _regeneratorRuntime.mark(decodeExternalFunction);

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});

var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
        for (var k in mod) {
            if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }

    __setModuleDefault(result, mod);

    return result;
};

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.checkPaddingLeft = exports.decodeInternalFunction = exports.decodeExternalFunction = exports.decodeContract = exports.decodeBasic = void 0;

var debug_1 = __importDefault(require("debug"));

var debug = debug_1.default("codec:basic:decode");

var read_1 = __importDefault(require("../../read"));

var Conversion = __importStar(require("../../conversion"));

var Format = __importStar(require("../../format"));

var Contexts = __importStar(require("../../contexts"));

var Evm = __importStar(require("../../evm"));

var errors_1 = require("../../errors");

var allocate_1 = require("../allocate");

function decodeBasic(dataType, pointer, info) {
    var options,
        state,
        strict,
        paddingMode,
        bytes,
        rawBytes,
        error,
        numeric,
        _error,
        _error2,
        _error3,
        _error4,
        _error5,
        fullType,
        contractValueInfo,
        coercedDataType,
        _error6,
        _error7,
        address,
        selector,
        deployedPc,
        constructorPc,
        _numeric,
        _fullType,
        _error8,
        numOptions,
        numBytes,
        paddingType,
        _error9,
        name,
        _error10,
        _error11,
        asBN,
        rawAsBN,
        asBig,
        rawAsBig,
        _error12,
        _asBN,
        _rawAsBN,
        _asBig,
        _rawAsBig,
        _args = arguments;

    return _regeneratorRuntime.wrap(function decodeBasic$(_context) {
        while (1) {
            switch (_context.prev = _context.next) {
                case 0:
                    options = _args.length > 3 && _args[3] !== undefined ? _args[3] : {};
                    state = info.state;
                    strict = options.strictAbiMode; //if this is undefined it'll still be falsy so it's OK

                    paddingMode = options.paddingMode || "default";
                    _context.prev = 4;
                    return _context.delegateYield(read_1.default(pointer, state), "t0", 6);

                case 6:
                    bytes = _context.t0;
                    _context.next = 13;
                    break;

                case 9:
                    _context.prev = 9;
                    _context.t1 = _context["catch"](4);
                    debug("segfault, pointer %o, state: %O", pointer, state);
                    return _context.abrupt("return", errors_1.handleDecodingError(dataType, _context.t1, strict));

                case 13:
                    rawBytes = bytes;
                    debug("type %O", dataType);
                    debug("pointer %o", pointer);
                    _context.t2 = dataType.typeClass;
                    _context.next = _context.t2 === "bool" ? 19 : _context.t2 === "uint" ? 38 : _context.t2 === "int" ? 45 : _context.t2 === "address" ? 52 : _context.t2 === "contract" ? 59 : _context.t2 === "bytes" ? 69 : _context.t2 === "function" ? 77 : _context.t2 === "enum" ? 101 : _context.t2 === "fixed" ? 127 : _context.t2 === "ufixed" ? 138 : 149;
                    break;

                case 19:
                    if (checkPadding(bytes, dataType, paddingMode)) {
                        _context.next = 24;
                        break;
                    }

                    error = {
                        kind: "BoolPaddingError",
                        paddingType: getPaddingType(dataType, paddingMode),
                        raw: Conversion.toHexString(bytes)
                    };

                    if (!strict) {
                        _context.next = 23;
                        break;
                    }

                    throw new errors_1.StopDecodingError(error);

                case 23:
                    return _context.abrupt("return", {
                        type: dataType,
                        kind: "error",
                        error: error
                    });

                case 24:
                    bytes = removePadding(bytes, dataType, paddingMode); //note: the use of the BN is a little silly here,
                    //but, kind of stuck with it for now

                    numeric = Conversion.toBN(bytes);

                    if (!numeric.eqn(0)) {
                        _context.next = 30;
                        break;
                    }

                    return _context.abrupt("return", {
                        type: dataType,
                        kind: "value",
                        value: {
                            asBoolean: false
                        }
                    });

                case 30:
                    if (!numeric.eqn(1)) {
                        _context.next = 34;
                        break;
                    }

                    return _context.abrupt("return", {
                        type: dataType,
                        kind: "value",
                        value: {
                            asBoolean: true
                        }
                    });

                case 34:
                    _error = {
                        kind: "BoolOutOfRangeError",
                        rawAsBN: numeric
                    };

                    if (!strict) {
                        _context.next = 37;
                        break;
                    }

                    throw new errors_1.StopDecodingError(_error);

                case 37:
                    return _context.abrupt("return", {
                        type: dataType,
                        kind: "error",
                        error: _error
                    });

                case 38:
                    if (checkPadding(bytes, dataType, paddingMode)) {
                        _context.next = 43;
                        break;
                    }

                    _error2 = {
                        kind: "UintPaddingError",
                        paddingType: getPaddingType(dataType, paddingMode),
                        raw: Conversion.toHexString(bytes)
                    };

                    if (!strict) {
                        _context.next = 42;
                        break;
                    }

                    throw new errors_1.StopDecodingError(_error2);

                case 42:
                    return _context.abrupt("return", {
                        type: dataType,
                        kind: "error",
                        error: _error2
                    });

                case 43:
                    //now, truncate to appropriate length
                    bytes = removePadding(bytes, dataType, paddingMode);
                    return _context.abrupt("return", {
                        type: dataType,
                        kind: "value",
                        value: {
                            asBN: Conversion.toBN(bytes),
                            rawAsBN: Conversion.toBN(rawBytes)
                        }
                    });

                case 45:
                    if (checkPadding(bytes, dataType, paddingMode)) {
                        _context.next = 50;
                        break;
                    }

                    _error3 = {
                        kind: "IntPaddingError",
                        paddingType: getPaddingType(dataType, paddingMode),
                        raw: Conversion.toHexString(bytes)
                    };

                    if (!strict) {
                        _context.next = 49;
                        break;
                    }

                    throw new errors_1.StopDecodingError(_error3);

                case 49:
                    return _context.abrupt("return", {
                        type: dataType,
                        kind: "error",
                        error: _error3
                    });

                case 50:
                    //now, truncate to appropriate length (keeping the bytes on the right)
                    bytes = removePadding(bytes, dataType, paddingMode);
                    return _context.abrupt("return", {
                        type: dataType,
                        kind: "value",
                        value: {
                            asBN: Conversion.toSignedBN(bytes),
                            rawAsBN: Conversion.toSignedBN(rawBytes)
                        }
                    });

                case 52:
                    if (checkPadding(bytes, dataType, paddingMode)) {
                        _context.next = 57;
                        break;
                    }

                    _error4 = {
                        kind: "AddressPaddingError",
                        paddingType: getPaddingType(dataType, paddingMode),
                        raw: Conversion.toHexString(bytes)
                    };

                    if (!strict) {
                        _context.next = 56;
                        break;
                    }

                    throw new errors_1.StopDecodingError(_error4);

                case 56:
                    return _context.abrupt("return", {
                        type: dataType,
                        kind: "error",
                        error: _error4
                    });

                case 57:
                    bytes = removePadding(bytes, dataType, paddingMode);
                    return _context.abrupt("return", {
                        type: dataType,
                        kind: "value",
                        value: {
                            asAddress: Evm.Utils.toAddress(bytes),
                            rawAsHex: Conversion.toHexString(rawBytes)
                        }
                    });

                case 59:
                    if (checkPadding(bytes, dataType, paddingMode)) {
                        _context.next = 64;
                        break;
                    }

                    _error5 = {
                        kind: "ContractPaddingError",
                        paddingType: getPaddingType(dataType, paddingMode),
                        raw: Conversion.toHexString(bytes)
                    };

                    if (!strict) {
                        _context.next = 63;
                        break;
                    }

                    throw new errors_1.StopDecodingError(_error5);

                case 63:
                    return _context.abrupt("return", {
                        type: dataType,
                        kind: "error",
                        error: _error5
                    });

                case 64:
                    bytes = removePadding(bytes, dataType, paddingMode);
                    fullType = Format.Types.fullType(dataType, info.userDefinedTypes);
                    return _context.delegateYield(decodeContract(bytes, info), "t3", 67);

                case 67:
                    contractValueInfo = _context.t3;
                    return _context.abrupt("return", {
                        type: fullType,
                        kind: "value",
                        value: contractValueInfo
                    });

                case 69:
                    //NOTE: we assume this is a *static* bytestring,
                    //because this is decodeBasic! dynamic ones should
                    //go to decodeBytes!
                    coercedDataType = dataType; //first, check padding (if needed)

                    if (checkPadding(bytes, dataType, paddingMode)) {
                        _context.next = 75;
                        break;
                    }

                    _error6 = {
                        kind: "BytesPaddingError",
                        paddingType: getPaddingType(dataType, paddingMode),
                        raw: Conversion.toHexString(bytes)
                    };

                    if (!strict) {
                        _context.next = 74;
                        break;
                    }

                    throw new errors_1.StopDecodingError(_error6);

                case 74:
                    return _context.abrupt("return", {
                        type: coercedDataType,
                        kind: "error",
                        error: _error6
                    });

                case 75:
                    //now, truncate to appropriate length
                    bytes = removePadding(bytes, dataType, paddingMode);
                    return _context.abrupt("return", {
                        type: coercedDataType,
                        kind: "value",
                        value: {
                            asHex: Conversion.toHexString(bytes),
                            rawAsHex: Conversion.toHexString(rawBytes)
                        }
                    });

                case 77:
                    _context.t4 = dataType.visibility;
                    _context.next = _context.t4 === "external" ? 80 : _context.t4 === "internal" ? 92 : 100;
                    break;

                case 80:
                    if (checkPadding(bytes, dataType, paddingMode)) {
                        _context.next = 85;
                        break;
                    }

                    _error7 = {
                        kind: "FunctionExternalNonStackPaddingError",
                        paddingType: getPaddingType(dataType, paddingMode),
                        raw: Conversion.toHexString(bytes)
                    };

                    if (!strict) {
                        _context.next = 84;
                        break;
                    }

                    throw new errors_1.StopDecodingError(_error7);

                case 84:
                    return _context.abrupt("return", {
                        type: dataType,
                        kind: "error",
                        error: _error7
                    });

                case 85:
                    bytes = removePadding(bytes, dataType, paddingMode);
                    address = bytes.slice(0, Evm.Utils.ADDRESS_SIZE);
                    selector = bytes.slice(Evm.Utils.ADDRESS_SIZE, Evm.Utils.ADDRESS_SIZE + Evm.Utils.SELECTOR_SIZE);
                    _context.t5 = dataType;
                    return _context.delegateYield(decodeExternalFunction(address, selector, info), "t6", 90);

                case 90:
                    _context.t7 = _context.t6;
                    return _context.abrupt("return", {
                        type: _context.t5,
                        kind: "value",
                        value: _context.t7
                    });

                case 92:
                    if (!strict) {
                        _context.next = 94;
                        break;
                    }

                    throw new errors_1.StopDecodingError({
                        kind: "InternalFunctionInABIError"
                    });

                case 94:
                    if (checkPadding(bytes, dataType, paddingMode)) {
                        _context.next = 96;
                        break;
                    }

                    return _context.abrupt("return", {
                        type: dataType,
                        kind: "error",
                        error: {
                            kind: "FunctionInternalPaddingError",
                            paddingType: getPaddingType(dataType, paddingMode),
                            raw: Conversion.toHexString(bytes)
                        }
                    });

                case 96:
                    bytes = removePadding(bytes, dataType, paddingMode);
                    deployedPc = bytes.slice(-Evm.Utils.PC_SIZE);
                    constructorPc = bytes.slice(-Evm.Utils.PC_SIZE * 2, -Evm.Utils.PC_SIZE);
                    return _context.abrupt("return", decodeInternalFunction(dataType, deployedPc, constructorPc, info));

                case 100:
                    return _context.abrupt("break", 149);

                case 101:
                    _numeric = Conversion.toBN(bytes);
                    _fullType = Format.Types.fullType(dataType, info.userDefinedTypes);

                    if (_fullType.options) {
                        _context.next = 108;
                        break;
                    }

                    _error8 = {
                        kind: "EnumNotFoundDecodingError",
                        type: _fullType,
                        rawAsBN: _numeric
                    };

                    if (!(strict || options.allowRetry)) {
                        _context.next = 107;
                        break;
                    }

                    throw new errors_1.StopDecodingError(_error8, true);

                case 107:
                    return _context.abrupt("return", {
                        type: _fullType,
                        kind: "error",
                        error: _error8
                    });

                case 108:
                    //note: I'm doing the padding checks a little more manually on this one
                    //so that we can have the right type of error
                    numOptions = _fullType.options.length;
                    numBytes = Math.ceil(Math.log2(numOptions) / 8);
                    paddingType = getPaddingType(dataType, paddingMode);

                    if (checkPaddingDirect(bytes, numBytes, paddingType)) {
                        _context.next = 116;
                        break;
                    }

                    _error9 = {
                        kind: "EnumPaddingError",
                        type: _fullType,
                        paddingType: paddingType,
                        raw: Conversion.toHexString(bytes)
                    };

                    if (!strict) {
                        _context.next = 115;
                        break;
                    }

                    throw new errors_1.StopDecodingError(_error9);

                case 115:
                    return _context.abrupt("return", {
                        type: dataType,
                        kind: "error",
                        error: _error9
                    });

                case 116:
                    bytes = removePaddingDirect(bytes, numBytes, paddingType);
                    _numeric = Conversion.toBN(bytes); //alter numeric!

                    if (!_numeric.ltn(numOptions)) {
                        _context.next = 123;
                        break;
                    }

                    name = _fullType.options[_numeric.toNumber()]; //NOTE: despite the use of toNumber(), I'm NOT catching exceptions here and returning an
                    //error value like elsewhere; I'm just letting this one fail.  Why?  Because if we have
                    //an enum with that many options in the first place, we have bigger problems!

                    return _context.abrupt("return", {
                        type: _fullType,
                        kind: "value",
                        value: {
                            name: name,
                            numericAsBN: _numeric
                        }
                    });

                case 123:
                    _error10 = {
                        kind: "EnumOutOfRangeError",
                        type: _fullType,
                        rawAsBN: _numeric
                    };

                    if (!strict) {
                        _context.next = 126;
                        break;
                    }

                    throw new errors_1.StopDecodingError(_error10);

                case 126:
                    return _context.abrupt("return", {
                        type: _fullType,
                        kind: "error",
                        error: _error10
                    });

                case 127:
                    if (checkPadding(bytes, dataType, paddingMode)) {
                        _context.next = 132;
                        break;
                    }

                    _error11 = {
                        kind: "FixedPaddingError",
                        paddingType: getPaddingType(dataType, paddingMode),
                        raw: Conversion.toHexString(bytes)
                    };

                    if (!strict) {
                        _context.next = 131;
                        break;
                    }

                    throw new errors_1.StopDecodingError(_error11);

                case 131:
                    return _context.abrupt("return", {
                        type: dataType,
                        kind: "error",
                        error: _error11
                    });

                case 132:
                    //now, truncate to appropriate length (keeping the bytes on the right)
                    bytes = removePadding(bytes, dataType, paddingMode);
                    asBN = Conversion.toSignedBN(bytes);
                    rawAsBN = Conversion.toSignedBN(rawBytes);
                    asBig = Conversion.shiftBigDown(Conversion.toBig(asBN), dataType.places);
                    rawAsBig = Conversion.shiftBigDown(Conversion.toBig(rawAsBN), dataType.places);
                    return _context.abrupt("return", {
                        type: dataType,
                        kind: "value",
                        value: {
                            asBig: asBig,
                            rawAsBig: rawAsBig
                        }
                    });

                case 138:
                    if (checkPadding(bytes, dataType, paddingMode)) {
                        _context.next = 143;
                        break;
                    }

                    _error12 = {
                        kind: "UfixedPaddingError",
                        paddingType: getPaddingType(dataType, paddingMode),
                        raw: Conversion.toHexString(bytes)
                    };

                    if (!strict) {
                        _context.next = 142;
                        break;
                    }

                    throw new errors_1.StopDecodingError(_error12);

                case 142:
                    return _context.abrupt("return", {
                        type: dataType,
                        kind: "error",
                        error: _error12
                    });

                case 143:
                    //now, truncate to appropriate length (keeping the bytes on the right)
                    bytes = removePadding(bytes, dataType, paddingMode);
                    _asBN = Conversion.toBN(bytes);
                    _rawAsBN = Conversion.toBN(rawBytes);
                    _asBig = Conversion.shiftBigDown(Conversion.toBig(_asBN), dataType.places);
                    _rawAsBig = Conversion.shiftBigDown(Conversion.toBig(_rawAsBN), dataType.places);
                    return _context.abrupt("return", {
                        type: dataType,
                        kind: "value",
                        value: {
                            asBig: _asBig,
                            rawAsBig: _rawAsBig
                        }
                    });

                case 149:
                case "end":
                    return _context.stop();
            }
        }
    }, _marked, null, [
        [4, 9]
    ]);
}

exports.decodeBasic = decodeBasic; //NOTE that this function returns a ContractValueInfo, not a ContractResult

function decodeContract(addressBytes, info) {
    return _regeneratorRuntime.wrap(function decodeContract$(_context2) {
        while (1) {
            switch (_context2.prev = _context2.next) {
                case 0:
                    return _context2.delegateYield(decodeContractAndContext(addressBytes, info), "t0", 1);

                case 1:
                    return _context2.abrupt("return", _context2.t0.contractInfo);

                case 2:
                case "end":
                    return _context2.stop();
            }
        }
    }, _marked2);
}

exports.decodeContract = decodeContract;

function decodeContractAndContext(addressBytes, info) {
    var address, rawAddress, codeBytes, code, context;
    return _regeneratorRuntime.wrap(function decodeContractAndContext$(_context3) {
        while (1) {
            switch (_context3.prev = _context3.next) {
                case 0:
                    address = Evm.Utils.toAddress(addressBytes);
                    rawAddress = Conversion.toHexString(addressBytes);
                    _context3.next = 4;
                    return {
                        type: "code",
                        address: address
                    };

                case 4:
                    codeBytes = _context3.sent;
                    code = Conversion.toHexString(codeBytes);
                    context = Contexts.Utils.findContext(info.contexts, code);

                    if (!(context !== null)) {
                        _context3.next = 11;
                        break;
                    }

                    return _context3.abrupt("return", {
                        context: context,
                        contractInfo: {
                            kind: "known",
                            address: address,
                            rawAddress: rawAddress,
                            class: Contexts.Import.contextToType(context)
                        }
                    });

                case 11:
                    return _context3.abrupt("return", {
                        context: context,
                        contractInfo: {
                            kind: "unknown",
                            address: address,
                            rawAddress: rawAddress
                        }
                    });

                case 12:
                case "end":
                    return _context3.stop();
            }
        }
    }, _marked3);
} //note: address can have extra zeroes on the left like elsewhere, but selector should be exactly 4 bytes
//NOTE this again returns a FunctionExternalValueInfo, not a FunctionExternalResult


function decodeExternalFunction(addressBytes, selectorBytes, info) {
    var _yield$decodeContract, contract, context, selector, abiEntry;

    return _regeneratorRuntime.wrap(function decodeExternalFunction$(_context4) {
        while (1) {
            switch (_context4.prev = _context4.next) {
                case 0:
                    return _context4.delegateYield(decodeContractAndContext(addressBytes, info), "t0", 1);

                case 1:
                    _yield$decodeContract = _context4.t0;
                    contract = _yield$decodeContract.contractInfo;
                    context = _yield$decodeContract.context;
                    selector = Conversion.toHexString(selectorBytes);

                    if (!(contract.kind === "unknown")) {
                        _context4.next = 7;
                        break;
                    }

                    return _context4.abrupt("return", {
                        kind: "unknown",
                        contract: contract,
                        selector: selector
                    });

                case 7:
                    abiEntry = context.abi !== undefined ? context.abi[selector] : undefined;

                    if (!(abiEntry === undefined)) {
                        _context4.next = 10;
                        break;
                    }

                    return _context4.abrupt("return", {
                        kind: "invalid",
                        contract: contract,
                        selector: selector
                    });

                case 10:
                    return _context4.abrupt("return", {
                        kind: "known",
                        contract: contract,
                        selector: selector,
                        abi: abiEntry
                    });

                case 11:
                case "end":
                    return _context4.stop();
            }
        }
    }, _marked4);
}

exports.decodeExternalFunction = decodeExternalFunction; //this one works a bit differently -- in order to handle errors, it *does* return a FunctionInternalResult
//also note, I haven't put the same sort of error-handling in this one since it's only intended to run with full info (for now, anyway)

function decodeInternalFunction(dataType, deployedPcBytes, constructorPcBytes, info) {
    var deployedPc = Conversion.toBN(deployedPcBytes).toNumber();
    var constructorPc = Conversion.toBN(constructorPcBytes).toNumber();
    var context = Contexts.Import.contextToType(info.currentContext); //before anything else: do we even have an internal functions table?
    //if not, we'll just return the info we have without really attemting to decode

    if (!info.internalFunctionsTable) {
        return {
            type: dataType,
            kind: "value",
            value: {
                kind: "unknown",
                context: context,
                deployedProgramCounter: deployedPc,
                constructorProgramCounter: constructorPc
            }
        };
    } //also before we continue: is the PC zero? if so let's just return that


    if (deployedPc === 0 && constructorPc === 0) {
        return {
            type: dataType,
            kind: "value",
            value: {
                kind: "exception",
                context: context,
                deployedProgramCounter: deployedPc,
                constructorProgramCounter: constructorPc
            }
        };
    } //another check: is only the deployed PC zero?


    if (deployedPc === 0 && constructorPc !== 0) {
        return {
            type: dataType,
            kind: "error",
            error: {
                kind: "MalformedInternalFunctionError",
                context: context,
                deployedProgramCounter: 0,
                constructorProgramCounter: constructorPc
            }
        };
    } //one last pre-check: is this a deployed-format pointer in a constructor?


    if (info.currentContext.isConstructor && constructorPc === 0) {
        return {
            type: dataType,
            kind: "error",
            error: {
                kind: "DeployedFunctionInConstructorError",
                context: context,
                deployedProgramCounter: deployedPc,
                constructorProgramCounter: 0
            }
        };
    } //otherwise, we get our function


    var pc = info.currentContext.isConstructor ? constructorPc : deployedPc;
    var functionEntry = info.internalFunctionsTable[pc];

    if (!functionEntry) {
        //if it's not zero and there's no entry... error!
        return {
            type: dataType,
            kind: "error",
            error: {
                kind: "NoSuchInternalFunctionError",
                context: context,
                deployedProgramCounter: deployedPc,
                constructorProgramCounter: constructorPc
            }
        };
    }

    if (functionEntry.isDesignatedInvalid) {
        return {
            type: dataType,
            kind: "value",
            value: {
                kind: "exception",
                context: context,
                deployedProgramCounter: deployedPc,
                constructorProgramCounter: constructorPc
            }
        };
    }

    var name = functionEntry.name;
    var mutability = functionEntry.mutability;
    var definedIn = Evm.Import.functionTableEntryToType(functionEntry); //may be null

    var id = Evm.Import.makeInternalFunctionId(functionEntry);
    return {
        type: dataType,
        kind: "value",
        value: {
            kind: "function",
            context: context,
            deployedProgramCounter: deployedPc,
            constructorProgramCounter: constructorPc,
            name: name,
            id: id,
            definedIn: definedIn,
            mutability: mutability
        }
    };
}

exports.decodeInternalFunction = decodeInternalFunction;

function checkPadding(bytes, dataType, paddingMode, userDefinedTypes) {
    var length = allocate_1.byteLength(dataType, userDefinedTypes);
    var paddingType = getPaddingType(dataType, paddingMode);

    if (paddingMode === "permissive") {
        switch (dataType.typeClass) {
            case "bool":
            case "enum":
            case "function":
                //these three types are checked even in permissive mode
                return checkPaddingDirect(bytes, length, paddingType);

            default:
                return true;
        }
    } else {
        return checkPaddingDirect(bytes, length, paddingType);
    }
}

function removePadding(bytes, dataType, paddingMode, userDefinedTypes) {
    var length = allocate_1.byteLength(dataType, userDefinedTypes);
    var paddingType = getPaddingType(dataType, paddingMode);
    return removePaddingDirect(bytes, length, paddingType);
}

function removePaddingDirect(bytes, length, paddingType) {
    switch (paddingType) {
        case "left":
        case "signed":
            return bytes.slice(-length);

        case "right":
            return bytes.slice(0, length);
    }
}

function checkPaddingDirect(bytes, length, paddingType) {
    switch (paddingType) {
        case "left":
            return checkPaddingLeft(bytes, length);

        case "right":
            return checkPaddingRight(bytes, length);

        case "signed":
            return checkPaddingSigned(bytes, length);
    }
}

function getPaddingType(dataType, paddingMode) {
    switch (paddingMode) {
        case "right":
            return "right";

        case "default":
        case "permissive":
            return defaultPaddingType(dataType);

        case "zero":
            var defaultType = defaultPaddingType(dataType);
            return defaultType === "signed" ? "left" : defaultType;
    }
}

function defaultPaddingType(dataType) {
    switch (dataType.typeClass) {
        case "bytes":
            return "right";

        case "int":
        case "fixed":
            return "signed";

        case "function":
            if (dataType.visibility === "external") {
                return "right";
            }

            //otherwise, fall through to default

        default:
            return "left";
    }
}

function checkPaddingRight(bytes, length) {
    var padding = bytes.slice(length); //cut off the first length bytes

    return padding.every(function(paddingByte) {
        return paddingByte === 0;
    });
} //exporting this one for use in stack.ts


function checkPaddingLeft(bytes, length) {
    var padding = bytes.slice(0, -length); //cut off the last length bytes

    return padding.every(function(paddingByte) {
        return paddingByte === 0;
    });
}

exports.checkPaddingLeft = checkPaddingLeft;

function checkPaddingSigned(bytes, length) {
    var padding = bytes.slice(0, -length); //padding is all but the last length bytes

    var value = bytes.slice(-length); //meanwhile the actual value is those last length bytes

    var signByte = value[0] & 0x80 ? 0xff : 0x00;
    return padding.every(function(paddingByte) {
        return paddingByte === signByte;
    });
}