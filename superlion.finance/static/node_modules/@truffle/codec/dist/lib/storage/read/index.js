"use strict";

var _regeneratorRuntime = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator");

var _marked = /*#__PURE__*/ _regeneratorRuntime.mark(readSlot),
    _marked2 = /*#__PURE__*/ _regeneratorRuntime.mark(readStorage);

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});

var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
        for (var k in mod) {
            if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }

    __setModuleDefault(result, mod);

    return result;
};

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.readStorage = exports.readSlot = void 0;

var debug_1 = __importDefault(require("debug"));

var debug = debug_1.default("codec:storage:read");

var Conversion = __importStar(require("../../conversion"));

var Utils = __importStar(require("../utils"));

var Evm = __importStar(require("../../evm"));

var errors_1 = require("../../errors");

function readSlot(storage, slot) {
    var address, hexAddress, word;
    return _regeneratorRuntime.wrap(function readSlot$(_context) {
        while (1) {
            switch (_context.prev = _context.next) {
                case 0:
                    address = Utils.slotAddress(slot); // debug("reading slot: %o", Conversion.toHexString(address));

                    hexAddress = Conversion.toHexString(address, Evm.Utils.WORD_SIZE);
                    word = storage[hexAddress]; //if we can't find the word in the map, we place a request to the invoker to supply it
                    //(contract-decoder will look it up from the blockchain, while the debugger will just
                    //say 0)

                    if (!(word === undefined)) {
                        _context.next = 7;
                        break;
                    }

                    _context.next = 6;
                    return {
                        type: "storage",
                        slot: address
                    };

                case 6:
                    word = _context.sent;

                case 7:
                    return _context.abrupt("return", word);

                case 8:
                case "end":
                    return _context.stop();
            }
        }
    }, _marked);
}

exports.readSlot = readSlot;

function readStorage(pointer, state) {
    var storage, range, from, to, length, totalWordsAsBN, totalWords, data, i, offset, word;
    return _regeneratorRuntime.wrap(function readStorage$(_context2) {
        while (1) {
            switch (_context2.prev = _context2.next) {
                case 0:
                    storage = state.storage;
                    range = pointer.range;
                    debug("readRange %o", range);
                    from = range.from, to = range.to, length = range.length;
                    from = {
                        slot: from.slot,
                        index: from.index || 0
                    };

                    if (length !== undefined) {
                        to = {
                            slot: {
                                path: from.slot.path || undefined,
                                offset: from.slot.offset.addn(Math.floor((from.index + length - 1) / Evm.Utils.WORD_SIZE))
                            },
                            index: (from.index + length - 1) % Evm.Utils.WORD_SIZE
                        };
                    }

                    debug("normalized readRange %o", {
                        from: from,
                        to: to
                    });
                    totalWordsAsBN = to.slot.offset.sub(from.slot.offset).addn(1);
                    _context2.prev = 8;
                    totalWords = totalWordsAsBN.toNumber();
                    _context2.next = 15;
                    break;

                case 12:
                    _context2.prev = 12;
                    _context2.t0 = _context2["catch"](8);
                    throw new errors_1.DecodingError({
                        kind: "ReadErrorStorage",
                        range: range
                    });

                case 15:
                    data = new Uint8Array(totalWords * Evm.Utils.WORD_SIZE);
                    i = 0;

                case 17:
                    if (!(i < totalWords)) {
                        _context2.next = 25;
                        break;
                    }

                    offset = from.slot.offset.addn(i);
                    return _context2.delegateYield(readSlot(storage, Object.assign(Object.assign({}, from.slot), {
                        offset: offset
                    })), "t1", 20);

                case 20:
                    word = _context2.t1;

                    if (typeof word !== "undefined") {
                        data.set(word, i * Evm.Utils.WORD_SIZE);
                    }

                case 22:
                    i++;
                    _context2.next = 17;
                    break;

                case 25:
                    debug("words %o", data);
                    data = data.slice(from.index, (totalWords - 1) * Evm.Utils.WORD_SIZE + to.index + 1);
                    debug("data: %o", data);
                    return _context2.abrupt("return", data);

                case 29:
                case "end":
                    return _context2.stop();
            }
        }
    }, _marked2, null, [
        [8, 12]
    ]);
}

exports.readStorage = readStorage;