"use strict";

var _regeneratorRuntime = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator");

function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {};
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true,
        didErr = false,
        err;
    return {
        s: function s() {
            it = o[Symbol.iterator]();
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally {
                if (didErr) throw err;
            }
        }
    };
}

function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
    }
    return arr2;
}

var _marked = /*#__PURE__*/ _regeneratorRuntime.mark(decodeStorage),
    _marked2 = /*#__PURE__*/ _regeneratorRuntime.mark(decodeStorageReferenceByAddress),
    _marked3 = /*#__PURE__*/ _regeneratorRuntime.mark(decodeStorageReference);

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});

var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
        for (var k in mod) {
            if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }

    __setModuleDefault(result, mod);

    return result;
};

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.decodeStorageReference = exports.decodeStorageReferenceByAddress = exports.decodeStorage = void 0;

var debug_1 = __importDefault(require("debug"));

var debug = debug_1.default("codec:storage:decode");

var read_1 = __importDefault(require("../../read"));

var Conversion = __importStar(require("../../conversion"));

var Format = __importStar(require("../../format"));

var Basic = __importStar(require("../../basic"));

var Bytes = __importStar(require("../../bytes"));

var Utils = __importStar(require("../utils"));

var Evm = __importStar(require("../../evm"));

var allocate_1 = require("../allocate");

var bn_js_1 = __importDefault(require("bn.js"));

var errors_1 = require("../../errors");

function decodeStorage(dataType, pointer, info) {
    return _regeneratorRuntime.wrap(function decodeStorage$(_context) {
        while (1) {
            switch (_context.prev = _context.next) {
                case 0:
                    if (!Format.Types.isReferenceType(dataType)) {
                        _context.next = 5;
                        break;
                    }

                    return _context.delegateYield(decodeStorageReference(dataType, pointer, info), "t0", 2);

                case 2:
                    return _context.abrupt("return", _context.t0);

                case 5:
                    return _context.delegateYield(Basic.Decode.decodeBasic(dataType, pointer, info), "t1", 6);

                case 6:
                    return _context.abrupt("return", _context.t1);

                case 7:
                case "end":
                    return _context.stop();
            }
        }
    }, _marked);
}

exports.decodeStorage = decodeStorage; //decodes storage at the address *read* from the pointer -- hence why this takes DataPointer rather than StoragePointer.
//NOTE: ONLY for use with pointers to reference types!
//Of course, pointers to value types don't exist in Solidity, so that warning is redundant, but...

function decodeStorageReferenceByAddress(dataType, pointer, info) {
    var allocations, rawValue, startOffset, rawSize, size, newPointer;
    return _regeneratorRuntime.wrap(function decodeStorageReferenceByAddress$(_context2) {
        while (1) {
            switch (_context2.prev = _context2.next) {
                case 0:
                    allocations = info.allocations.storage;
                    _context2.prev = 1;
                    return _context2.delegateYield(read_1.default(pointer, info.state), "t0", 3);

                case 3:
                    rawValue = _context2.t0;
                    _context2.next = 9;
                    break;

                case 6:
                    _context2.prev = 6;
                    _context2.t1 = _context2["catch"](1);
                    return _context2.abrupt("return", errors_1.handleDecodingError(dataType, _context2.t1));

                case 9:
                    startOffset = Conversion.toBN(rawValue);
                    _context2.prev = 10;
                    rawSize = allocate_1.storageSize(dataType, info.userDefinedTypes, allocations);
                    _context2.next = 17;
                    break;

                case 14:
                    _context2.prev = 14;
                    _context2.t2 = _context2["catch"](10);
                    return _context2.abrupt("return", errors_1.handleDecodingError(dataType, _context2.t2));

                case 17:
                    //we *know* the type being decoded must be sized in words, because it's a
                    //reference type, but TypeScript doesn't, so we'll have to use a type
                    //coercion
                    size = rawSize.words; //now, construct the storage pointer

                    newPointer = {
                        location: "storage",
                        range: {
                            from: {
                                slot: {
                                    offset: startOffset
                                },
                                index: 0
                            },
                            to: {
                                slot: {
                                    offset: startOffset.addn(size - 1)
                                },
                                index: Evm.Utils.WORD_SIZE - 1
                            }
                        }
                    }; //dispatch to decodeStorageReference

                    return _context2.delegateYield(decodeStorageReference(dataType, newPointer, info), "t3", 20);

                case 20:
                    return _context2.abrupt("return", _context2.t3);

                case 21:
                case "end":
                    return _context2.stop();
            }
        }
    }, _marked2, null, [
        [1, 6],
        [10, 14]
    ]);
}

exports.decodeStorageReferenceByAddress = decodeStorageReferenceByAddress;

function decodeStorageReference(dataType, pointer, info) {
    var data, length, state, allocations, lengthAsBN, baseSize, ranges, currentSlot, i, childRange, perWord, currentPosition, _i, _childRange, decodedChildren, _i2, _ranges, _childRange2, lengthByte, _lengthAsBN, typeId, structAllocation, decodedMembers, members, index, memberAllocation, memberPointer, _childRange3, storedType, storedMemberType, memberType, valueType, valueSize, decodedEntries, baseSlot, keySlots, _iterator, _step, key, valuePointer;

    return _regeneratorRuntime.wrap(function decodeStorageReference$(_context3) {
        while (1) {
            switch (_context3.prev = _context3.next) {
                case 0:
                    state = info.state;
                    allocations = info.allocations.storage;
                    _context3.t0 = dataType.typeClass;
                    _context3.next = _context3.t0 === "array" ? 5 : _context3.t0 === "bytes" ? 55 : _context3.t0 === "string" ? 55 : _context3.t0 === "struct" ? 82 : _context3.t0 === "mapping" ? 109 : 147;
                    break;

                case 5:
                    debug("storage array! %o", pointer);
                    _context3.t1 = dataType.kind;
                    _context3.next = _context3.t1 === "dynamic" ? 9 : _context3.t1 === "static" ? 21 : 24;
                    break;

                case 9:
                    debug("dynamic array");
                    debug("type %O", dataType);
                    _context3.prev = 11;
                    return _context3.delegateYield(read_1.default(pointer, state), "t2", 13);

                case 13:
                    data = _context3.t2;
                    _context3.next = 19;
                    break;

                case 16:
                    _context3.prev = 16;
                    _context3.t3 = _context3["catch"](11);
                    return _context3.abrupt("return", errors_1.handleDecodingError(dataType, _context3.t3));

                case 19:
                    lengthAsBN = Conversion.toBN(data);
                    return _context3.abrupt("break", 24);

                case 21:
                    debug("static array");
                    lengthAsBN = dataType.length;
                    return _context3.abrupt("break", 24);

                case 24:
                    _context3.prev = 24;
                    length = lengthAsBN.toNumber();
                    _context3.next = 31;
                    break;

                case 28:
                    _context3.prev = 28;
                    _context3.t4 = _context3["catch"](24);
                    return _context3.abrupt("return", {
                        type: dataType,
                        kind: "error",
                        error: {
                            kind: "OverlongArraysAndStringsNotImplementedError",
                            lengthAsBN: lengthAsBN
                        }
                    });

                case 31:
                    debug("length %o", length);
                    debug("about to determine baseSize");
                    _context3.prev = 33;
                    baseSize = allocate_1.storageSize(dataType.baseType, info.userDefinedTypes, allocations);
                    _context3.next = 40;
                    break;

                case 37:
                    _context3.prev = 37;
                    _context3.t5 = _context3["catch"](33);
                    return _context3.abrupt("return", errors_1.handleDecodingError(dataType, _context3.t5));

                case 40:
                    debug("baseSize %o", baseSize); //we are going to make a list of child ranges, pushing them one by one onto
                    //this list, and then decode them; the first part will vary based on whether
                    //we're in the words case or the bytes case, the second will not

                    ranges = [];

                    if (Utils.isWordsLength(baseSize)) {
                        //currentSlot will point to the start of the entry being decoded
                        currentSlot = {
                            path: pointer.range.from.slot,
                            offset: new bn_js_1.default(0),
                            hashPath: dataType.kind === "dynamic"
                        };

                        for (i = 0; i < length; i++) {
                            childRange = {
                                from: {
                                    slot: {
                                        path: currentSlot.path,
                                        offset: currentSlot.offset.clone(),
                                        hashPath: currentSlot.hashPath
                                    },
                                    index: 0
                                },
                                to: {
                                    slot: {
                                        path: currentSlot.path,
                                        offset: currentSlot.offset.addn(baseSize.words - 1),
                                        hashPath: currentSlot.hashPath
                                    },
                                    index: Evm.Utils.WORD_SIZE - 1
                                }
                            };
                            ranges.push(childRange);
                            currentSlot.offset.iaddn(baseSize.words);
                        }
                    } else {
                        perWord = Math.floor(Evm.Utils.WORD_SIZE / baseSize.bytes);
                        debug("perWord %d", perWord); //currentPosition will point to the start of the entry being decoded
                        //note we have baseSize.bytes <= Evm.Utils.WORD_SIZE

                        currentPosition = {
                            slot: {
                                path: pointer.range.from.slot,
                                offset: new bn_js_1.default(0),
                                hashPath: dataType.kind === "dynamic"
                            },
                            index: Evm.Utils.WORD_SIZE - baseSize.bytes //note the starting index!

                        };

                        for (_i = 0; _i < length; _i++) {
                            _childRange = {
                                from: {
                                    slot: {
                                        path: currentPosition.slot.path,
                                        offset: currentPosition.slot.offset.clone(),
                                        hashPath: currentPosition.slot.hashPath
                                    },
                                    index: currentPosition.index
                                },
                                length: baseSize.bytes
                            };
                            ranges.push(_childRange);
                            currentPosition.index -= baseSize.bytes;

                            if (currentPosition.index < 0) {
                                currentPosition.slot.offset.iaddn(1);
                                currentPosition.index = Evm.Utils.WORD_SIZE - baseSize.bytes;
                            }
                        }
                    }

                    decodedChildren = [];
                    _i2 = 0, _ranges = ranges;

                case 45:
                    if (!(_i2 < _ranges.length)) {
                        _context3.next = 54;
                        break;
                    }

                    _childRange2 = _ranges[_i2];
                    _context3.t6 = decodedChildren;
                    return _context3.delegateYield(decodeStorage(dataType.baseType, {
                        location: "storage",
                        range: _childRange2
                    }, info), "t7", 49);

                case 49:
                    _context3.t8 = _context3.t7;

                    _context3.t6.push.call(_context3.t6, _context3.t8);

                case 51:
                    _i2++;
                    _context3.next = 45;
                    break;

                case 54:
                    return _context3.abrupt("return", {
                        type: dataType,
                        kind: "value",
                        value: decodedChildren
                    });

                case 55:
                    _context3.prev = 55;
                    return _context3.delegateYield(read_1.default(pointer, state), "t9", 57);

                case 57:
                    data = _context3.t9;
                    _context3.next = 63;
                    break;

                case 60:
                    _context3.prev = 60;
                    _context3.t10 = _context3["catch"](55);
                    return _context3.abrupt("return", errors_1.handleDecodingError(dataType, _context3.t10));

                case 63:
                    lengthByte = data[Evm.Utils.WORD_SIZE - 1];

                    if (!(lengthByte % 2 == 0)) {
                        _context3.next = 71;
                        break;
                    }

                    // string lives in word, length is last byte / 2
                    length = lengthByte / 2;
                    debug("in-word; length %o", length);
                    return _context3.delegateYield(Bytes.Decode.decodeBytes(dataType, {
                        location: "storage",
                        range: {
                            from: {
                                slot: pointer.range.from.slot,
                                index: 0
                            },
                            to: {
                                slot: pointer.range.from.slot,
                                index: length - 1
                            }
                        }
                    }, info), "t11", 68);

                case 68:
                    return _context3.abrupt("return", _context3.t11);

                case 71:
                    _lengthAsBN = Conversion.toBN(data).subn(1).divn(2);
                    _context3.prev = 72;
                    length = _lengthAsBN.toNumber();
                    _context3.next = 79;
                    break;

                case 76:
                    _context3.prev = 76;
                    _context3.t12 = _context3["catch"](72);
                    return _context3.abrupt("return", {
                        //again with the TS failures...
                        type: dataType,
                        kind: "error",
                        error: {
                            kind: "OverlongArraysAndStringsNotImplementedError",
                            lengthAsBN: _lengthAsBN
                        }
                    });

                case 79:
                    debug("new-word, length %o", length);
                    return _context3.delegateYield(Bytes.Decode.decodeBytes(dataType, {
                        location: "storage",
                        range: {
                            from: {
                                slot: {
                                    path: pointer.range.from.slot,
                                    offset: new bn_js_1.default(0),
                                    hashPath: true
                                },
                                index: 0
                            },
                            length: length
                        }
                    }, info), "t13", 81);

                case 81:
                    return _context3.abrupt("return", _context3.t13);

                case 82:
                    typeId = dataType.id;
                    structAllocation = allocations[typeId];

                    if (structAllocation) {
                        _context3.next = 86;
                        break;
                    }

                    return _context3.abrupt("return", {
                        type: dataType,
                        kind: "error",
                        error: {
                            kind: "UserDefinedTypeNotFoundError",
                            type: dataType
                        }
                    });

                case 86:
                    decodedMembers = [];
                    members = structAllocation.members;
                    index = 0;

                case 89:
                    if (!(index < members.length)) {
                        _context3.next = 108;
                        break;
                    }

                    memberAllocation = members[index];
                    memberPointer = memberAllocation.pointer; //the type system thinks memberPointer might also be a constant
                    //definition pointer.  However, structs can't contain constants,
                    //so *we* know it's not, and can safely coerce it.

                    debug("pointer %O", pointer);
                    _childRange3 = {
                        from: {
                            slot: {
                                path: pointer.range.from.slot,
                                offset: memberPointer.range.from.slot.offset.clone() //note that memberPointer should have no path

                            },
                            index: memberPointer.range.from.index
                        },
                        to: {
                            slot: {
                                path: pointer.range.from.slot,
                                offset: memberPointer.range.to.slot.offset.clone() //note that memberPointer should have no path

                            },
                            index: memberPointer.range.to.index
                        }
                    };
                    storedType = info.userDefinedTypes[typeId];

                    if (storedType) {
                        _context3.next = 97;
                        break;
                    }

                    return _context3.abrupt("return", {
                        type: dataType,
                        kind: "error",
                        error: {
                            kind: "UserDefinedTypeNotFoundError",
                            type: dataType
                        }
                    });

                case 97:
                    storedMemberType = storedType.memberTypes[index].type;
                    memberType = Format.Types.specifyLocation(storedMemberType, "storage");
                    _context3.t14 = decodedMembers;
                    _context3.t15 = memberAllocation.name;
                    return _context3.delegateYield(decodeStorage(memberType, {
                        location: "storage",
                        range: _childRange3
                    }, info), "t16", 102);

                case 102:
                    _context3.t17 = _context3.t16;
                    _context3.t18 = {
                        name: _context3.t15,
                        value: _context3.t17
                    };

                    _context3.t14.push.call(_context3.t14, _context3.t18);

                case 105:
                    index++;
                    _context3.next = 89;
                    break;

                case 108:
                    return _context3.abrupt("return", {
                        type: dataType,
                        kind: "value",
                        value: decodedMembers
                    });

                case 109:
                    debug("decoding mapping");
                    valueType = dataType.valueType;
                    _context3.prev = 111;
                    valueSize = allocate_1.storageSize(valueType, info.userDefinedTypes, allocations);
                    _context3.next = 118;
                    break;

                case 115:
                    _context3.prev = 115;
                    _context3.t19 = _context3["catch"](111);
                    return _context3.abrupt("return", errors_1.handleDecodingError(dataType, _context3.t19));

                case 118:
                    decodedEntries = [];
                    baseSlot = pointer.range.from.slot;
                    debug("baseSlot %o", baseSlot);
                    debug("base slot address %o", Utils.slotAddress(baseSlot));
                    keySlots = info.mappingKeys.filter(function(_ref) {
                        var path = _ref.path;
                        return Utils.slotAddress(baseSlot).eq(Utils.slotAddress(path));
                    });
                    _iterator = _createForOfIteratorHelper(keySlots);
                    _context3.prev = 124;

                    _iterator.s();

                case 126:
                    if ((_step = _iterator.n()).done) {
                        _context3.next = 138;
                        break;
                    }

                    key = _step.value.key;
                    valuePointer = void 0;

                    if (Utils.isWordsLength(valueSize)) {
                        valuePointer = {
                            location: "storage",
                            range: {
                                from: {
                                    slot: {
                                        key: key,
                                        path: baseSlot,
                                        offset: new bn_js_1.default(0)
                                    },
                                    index: 0
                                },
                                to: {
                                    slot: {
                                        key: key,
                                        path: baseSlot,
                                        offset: new bn_js_1.default(valueSize.words - 1)
                                    },
                                    index: Evm.Utils.WORD_SIZE - 1
                                }
                            }
                        };
                    } else {
                        valuePointer = {
                            location: "storage",
                            range: {
                                from: {
                                    slot: {
                                        key: key,
                                        path: baseSlot,
                                        offset: new bn_js_1.default(0)
                                    },
                                    index: Evm.Utils.WORD_SIZE - valueSize.bytes
                                },
                                to: {
                                    slot: {
                                        key: key,
                                        path: baseSlot,
                                        offset: new bn_js_1.default(0)
                                    },
                                    index: Evm.Utils.WORD_SIZE - 1
                                }
                            }
                        };
                    }

                    _context3.t20 = decodedEntries;
                    _context3.t21 = key;
                    return _context3.delegateYield(decodeStorage(valueType, valuePointer, info), "t22", 133);

                case 133:
                    _context3.t23 = _context3.t22;
                    _context3.t24 = {
                        key: _context3.t21,
                        value: _context3.t23
                    };

                    _context3.t20.push.call(_context3.t20, _context3.t24);

                case 136:
                    _context3.next = 126;
                    break;

                case 138:
                    _context3.next = 143;
                    break;

                case 140:
                    _context3.prev = 140;
                    _context3.t25 = _context3["catch"](124);

                    _iterator.e(_context3.t25);

                case 143:
                    _context3.prev = 143;

                    _iterator.f();

                    return _context3.finish(143);

                case 146:
                    return _context3.abrupt("return", {
                        type: dataType,
                        kind: "value",
                        value: decodedEntries
                    });

                case 147:
                case "end":
                    return _context3.stop();
            }
        }
    }, _marked3, null, [
        [11, 16],
        [24, 28],
        [33, 37],
        [55, 60],
        [72, 76],
        [111, 115],
        [124, 140, 143, 146]
    ]);
}

exports.decodeStorageReference = decodeStorageReference;