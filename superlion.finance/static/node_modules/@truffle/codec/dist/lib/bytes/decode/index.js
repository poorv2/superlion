"use strict";

var _regeneratorRuntime = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator");

var _marked = /*#__PURE__*/ _regeneratorRuntime.mark(decodeBytes);

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});

var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
        for (var k in mod) {
            if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }

    __setModuleDefault(result, mod);

    return result;
};

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.decodeString = exports.decodeBytes = void 0;

var debug_1 = __importDefault(require("debug"));

var debug = debug_1.default("codec:bytes:decode");

var read_1 = __importDefault(require("../../read"));

var Conversion = __importStar(require("../../conversion"));

var errors_1 = require("../../errors");

var utf8_1 = __importDefault(require("utf8"));

function decodeBytes(dataType, pointer, info) {
    var options,
        state,
        strict,
        bytes,
        _args = arguments;
    return _regeneratorRuntime.wrap(function decodeBytes$(_context) {
        while (1) {
            switch (_context.prev = _context.next) {
                case 0:
                    options = _args.length > 3 && _args[3] !== undefined ? _args[3] : {};
                    state = info.state;
                    strict = options.strictAbiMode; //if this is undefined it'll still be falsy so OK

                    _context.prev = 3;
                    return _context.delegateYield(read_1.default(pointer, state), "t0", 5);

                case 5:
                    bytes = _context.t0;
                    _context.next = 12;
                    break;

                case 8:
                    _context.prev = 8;
                    _context.t1 = _context["catch"](3);
                    debug("segfault, pointer %o, state: %O", pointer, state);
                    return _context.abrupt("return", errors_1.handleDecodingError(dataType, _context.t1, strict));

                case 12:
                    debug("type %O", dataType);
                    debug("pointer %o", pointer); //note: this function does not check padding

                    _context.t2 = dataType.typeClass;
                    _context.next = _context.t2 === "bytes" ? 17 : _context.t2 === "string" ? 18 : 19;
                    break;

                case 17:
                    return _context.abrupt("return", {
                        type: dataType,
                        kind: "value",
                        value: {
                            asHex: Conversion.toHexString(bytes)
                        }
                    });

                case 18:
                    return _context.abrupt("return", {
                        type: dataType,
                        kind: "value",
                        value: decodeString(bytes)
                    });

                case 19:
                case "end":
                    return _context.stop();
            }
        }
    }, _marked, null, [
        [3, 8]
    ]);
}

exports.decodeBytes = decodeBytes;

function decodeString(bytes) {
    //the following line takes our UTF-8 string... and interprets each byte
    //as a UTF-16 bytepair.  Yikes!  Fortunately, we have a library to repair that.
    var badlyEncodedString = String.fromCharCode.apply(undefined, bytes);

    try {
        //this will throw an error if we have malformed UTF-8
        var correctlyEncodedString = utf8_1.default.decode(badlyEncodedString); //NOTE: we don't use node's builtin Buffer class to do the UTF-8 decoding
        //here, because that handles malformed UTF-8 by means of replacement characters
        //(U+FFFD).  That loses information.  So we use the utf8 package instead,
        //and... well, see the catch block below.

        return {
            kind: "valid",
            asString: correctlyEncodedString
        };
    } catch (_a) {
        //we're going to ignore the precise error and just assume it's because
        //the string was malformed (what else could it be?)
        var hexString = Conversion.toHexString(bytes);
        return {
            kind: "malformed",
            asHex: hexString
        };
    }
}

exports.decodeString = decodeString;