"use strict";

var _toConsumableArray = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray");

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.tie = void 0;

var debug_1 = __importDefault(require("debug"));

var debug = debug_1.default("codec:format:utils:circularity");

function tie(untied) {
    return tieWithTable(untied, []);
}

exports.tie = tie;

function tieWithTable(untied, seenSoFar) {
    if (untied.kind === "error") {
        return untied;
    }

    var reference;

    switch (untied.type.typeClass) {
        case "array":
            var untiedAsArray = untied; //dammit TS

            reference = untiedAsArray.reference;

            if (reference === undefined) {
                //we need to do some pointer stuff here, so let's first create our new
                //object we'll be pointing to
                //[we don't want to alter the original accidentally so let's clone a bit]
                var _tied = Object.assign(Object.assign({}, untiedAsArray), {
                    value: _toConsumableArray(untiedAsArray.value)
                }); //now, we can't use a map here, or we'll screw things up!
                //we want to *mutate* value, not replace it with a new object


                for (var index in _tied.value) {
                    _tied.value[index] = tieWithTable(_tied.value[index], [_tied].concat(_toConsumableArray(seenSoFar)));
                }

                return _tied;
            } else {
                return Object.assign(Object.assign({}, seenSoFar[reference - 1]), {
                    reference: reference
                });
            }

        case "struct":
            var untiedAsStruct = untied; //dammit TS

            reference = untiedAsStruct.reference;

            if (reference === undefined) {
                //we need to do some pointer stuff here, so let's first create our new
                //object we'll be pointing to
                //[we don't want to alter the original accidentally so let's clone a bit]
                var _tied2 = Object.assign(Object.assign({}, untiedAsStruct), {
                    value: untiedAsStruct.value.map(function(component) {
                        return Object.assign({}, component);
                    })
                }); //now, we can't use a map here, or we'll screw things up!
                //we want to *mutate* value, not replace it with a new object


                for (var _index in _tied2.value) {
                    _tied2.value[_index] = Object.assign(Object.assign({}, _tied2.value[_index]), {
                        value: tieWithTable(_tied2.value[_index].value, [_tied2].concat(_toConsumableArray(seenSoFar)))
                    });
                }

                return _tied2;
            } else {
                return Object.assign(Object.assign({}, seenSoFar[reference - 1]), {
                    reference: reference
                });
            }

        case "tuple":
            //currently there are no memory tuples, but may as well
            //can't be circular, just recurse
            //note we can just recurse with a straight tie here; don't need tieWithTable
            var untiedAsTuple = untied; //dammit TS
            //we need to do some pointer stuff here, so let's first create our new
            //object we'll be pointing to

            var tied = Object.assign({}, untiedAsTuple);
            tied.value = tied.value.map(function(component) {
                return Object.assign(Object.assign({}, component), {
                    value: tie(component.value)
                });
            });
            return tied;

        default:
            //other types either:
            //1. aren't containers and so need no recursion
            //2. are containers but can't go in or contain memory things
            //and so still need no recursion
            //(or, in the case of mappings, can't contain *nontrivial* memory
            //things)
            return untied;
    }
}