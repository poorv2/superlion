"use strict";

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isContractDefinedType = exports.typeStringWithoutLocation = exports.typeString = exports.specifyLocation = exports.fullType = exports.isReferenceType = void 0;

var debug_1 = __importDefault(require("debug"));

var debug = debug_1.default("codec:format:types");

function isUserDefinedType(anyType) {
    var userDefinedTypes = ["contract", "enum", "struct"];
    return userDefinedTypes.includes(anyType.typeClass);
}

function isReferenceType(anyType) {
    var alwaysReferenceTypes = ["array", "mapping", "struct", "string"];

    if (alwaysReferenceTypes.includes(anyType.typeClass)) {
        return true;
    } else if (anyType.typeClass === "bytes") {
        return anyType.kind === "dynamic";
    } else {
        return false;
    }
}

exports.isReferenceType = isReferenceType; //one could define a counterpart function that stripped all unnecessary information
//from the type object, but at the moment I see no need for that

function fullType(basicType, userDefinedTypes) {
    if (!isUserDefinedType(basicType)) {
        return basicType;
    }

    var id = basicType.id;
    var storedType = userDefinedTypes[id];

    if (!storedType) {
        return basicType;
    }

    var returnType = Object.assign(Object.assign({}, basicType), storedType);

    if (isReferenceType(basicType) && basicType.location !== undefined) {
        returnType = specifyLocation(returnType, basicType.location);
    }

    return returnType;
}

exports.fullType = fullType; //the location argument here always forces, so passing undefined *will* force undefined

function specifyLocation(dataType, location) {
    if (isReferenceType(dataType)) {
        switch (dataType.typeClass) {
            case "string":
            case "bytes":
                return Object.assign(Object.assign({}, dataType), {
                    location: location
                });

            case "array":
                return Object.assign(Object.assign({}, dataType), {
                    location: location,
                    baseType: specifyLocation(dataType.baseType, location)
                });

            case "mapping":
                var newLocation = location === "storage" ? "storage" : undefined;
                return Object.assign(Object.assign({}, dataType), {
                    location: newLocation,
                    valueType: specifyLocation(dataType.valueType, newLocation)
                });

            case "struct":
                var returnType = Object.assign(Object.assign({}, dataType), {
                    location: location
                });

                if (returnType.memberTypes) {
                    returnType.memberTypes = returnType.memberTypes.map(function(_ref) {
                        var memberName = _ref.name,
                            memberType = _ref.type;
                        return {
                            name: memberName,
                            type: specifyLocation(memberType, location)
                        };
                    });
                }

                return returnType;
        }
    } else {
        return dataType;
    }
}

exports.specifyLocation = specifyLocation; //NOTE: the following two functions might not be exactly right for weird internal stuff,
//or for ABI-only stuff.  (E.g. for internal stuff sometimes it records whether things
//are pointers or not??  we don't track that so we can't recreate that)
//But what can you do.

function typeString(dataType) {
    var baseString = typeStringWithoutLocation(dataType);

    if (isReferenceType(dataType) && dataType.location) {
        return baseString + " " + dataType.location;
    } else {
        return baseString;
    }
}

exports.typeString = typeString;

function typeStringWithoutLocation(dataType) {
    switch (dataType.typeClass) {
        case "uint":
            return dataType.typeHint || "uint".concat(dataType.bits);

        case "int":
            return dataType.typeHint || "int".concat(dataType.bits);

        case "bool":
            return dataType.typeHint || "bool";

        case "bytes":
            if (dataType.typeHint) {
                return dataType.typeHint;
            }

            switch (dataType.kind) {
                case "dynamic":
                    return "bytes";

                case "static":
                    return "bytes".concat(dataType.length);
            }

        case "address":
            switch (dataType.kind) {
                case "general":
                    return dataType.typeHint || "address";
                    //I guess?

                case "specific":
                    return dataType.payable ? "address payable" : "address";
            }

        case "string":
            return dataType.typeHint || "string";

        case "fixed":
            return dataType.typeHint || "fixed".concat(dataType.bits, "x").concat(dataType.places);

        case "ufixed":
            return dataType.typeHint || "ufixed".concat(dataType.bits, "x").concat(dataType.places);

        case "array":
            if (dataType.typeHint) {
                return dataType.typeHint;
            }

            switch (dataType.kind) {
                case "dynamic":
                    return "".concat(typeStringWithoutLocation(dataType.baseType), "[]");

                case "static":
                    return "".concat(typeStringWithoutLocation(dataType.baseType), "[").concat(dataType.length, "]");
            }

        case "mapping":
            return "mapping(".concat(typeStringWithoutLocation(dataType.keyType), " => ").concat(typeStringWithoutLocation(dataType.valueType), ")");

        case "struct":
        case "enum":
            //combining these cases for simplicity
            switch (dataType.kind) {
                case "local":
                    return "".concat(dataType.typeClass, " ").concat(dataType.definingContractName, ".").concat(dataType.typeName);

                case "global":
                    return "".concat(dataType.typeClass, " ").concat(dataType.typeName);
            }

        case "tuple":
            return dataType.typeHint || "tuple(" + dataType.memberTypes.map(function(memberType) {
                return typeString(memberType.type);
            }).join(",") + ")";
            //note that we do include location and do not put spaces

        case "contract":
            return dataType.contractKind + " " + dataType.typeName;

        case "magic":
            //no, this is not transposed!
            var variableNames = {
                message: "msg",
                transaction: "tx",
                block: "block"
            };
            return variableNames[dataType.variable];

        case "type":
            return "type(".concat(typeString(dataType.type), ")");

        case "function":
            var visibilityString;

            switch (dataType.visibility) {
                case "external":
                    if (dataType.kind === "general") {
                        if (dataType.typeHint) {
                            return dataType.typeHint;
                        } else {
                            return "function external"; //I guess???
                        }
                    }

                    visibilityString = " external"; //note the deliberate space!

                    break;

                case "internal":
                    visibilityString = "";
                    break;
            }

            var mutabilityString = dataType.mutability === "nonpayable" ? "" : " " + dataType.mutability; //again, note the deliberate space

            var inputList = dataType.inputParameterTypes.map(typeString).join(","); //note that we do include location, and do not put spaces

            var outputList = dataType.outputParameterTypes.map(typeString).join(",");
            var inputString = "function(".concat(inputList, ")");
            var outputString = outputList === "" ? "" : " returns (".concat(outputList, ")"); //again, note the deliberate space

            return inputString + mutabilityString + visibilityString + outputString;
    }
}

exports.typeStringWithoutLocation = typeStringWithoutLocation;

function isContractDefinedType(anyType) {
    var contractDefinedTypes = ["enum", "struct"];
    return contractDefinedTypes.includes(anyType.typeClass);
}

exports.isContractDefinedType = isContractDefinedType;