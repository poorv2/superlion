"use strict";

var _slicedToArray = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray");

var _toConsumableArray = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray");

var _regeneratorRuntime = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator");

function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {};
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true,
        didErr = false,
        err;
    return {
        s: function s() {
            it = o[Symbol.iterator]();
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally {
                if (didErr) throw err;
            }
        }
    };
}

function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
    }
    return arr2;
}

var _marked = /*#__PURE__*/ _regeneratorRuntime.mark(decodeVariable),
    _marked2 = /*#__PURE__*/ _regeneratorRuntime.mark(decodeCalldata),
    _marked3 = /*#__PURE__*/ _regeneratorRuntime.mark(decodeEvent),
    _marked4 = /*#__PURE__*/ _regeneratorRuntime.mark(decodeReturndata),
    _marked5 = /*#__PURE__*/ _regeneratorRuntime.mark(decodeBytecode);

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});

var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
        for (var k in mod) {
            if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }

    __setModuleDefault(result, mod);

    return result;
};

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.decodeRevert = exports.decodeReturndata = exports.decodeEvent = exports.decodeCalldata = exports.decodeVariable = void 0;

var debug_1 = __importDefault(require("debug"));

var debug = debug_1.default("codec:core");

var Ast = __importStar(require("./ast"));

var AbiData = __importStar(require("./abi-data"));

var Topic = __importStar(require("./topic"));

var Evm = __importStar(require("./evm"));

var Contexts = __importStar(require("./contexts"));

var abify_1 = require("./abify");

var Conversion = __importStar(require("./conversion"));

var errors_1 = require("./errors");

var read_1 = __importDefault(require("./read"));

var decode_1 = __importDefault(require("./decode")); // untyped import since no @types/web3-utils exists


var Web3Utils = require("web3-utils");
/**
 * @Category Decoding
 */


function decodeVariable(definition, pointer, info, compilationId) {
    var compiler, dataType;
    return _regeneratorRuntime.wrap(function decodeVariable$(_context) {
        while (1) {
            switch (_context.prev = _context.next) {
                case 0:
                    compiler = info.currentContext.compiler;
                    dataType = Ast.Import.definitionToType(definition, compilationId, compiler);
                    return _context.delegateYield(decode_1.default(dataType, pointer, info), "t0", 3);

                case 3:
                    return _context.abrupt("return", _context.t0);

                case 4:
                case "end":
                    return _context.stop();
            }
        }
    }, _marked);
}

exports.decodeVariable = decodeVariable;
/**
 * @Category Decoding
 */

function decodeCalldata(info, isConstructor //ignored if context! trust context instead if have
) {
    var context, contextHash, contractType, allocations, allocation, selector, rawSelector, abiEntry, decodingMode, decodedArguments, _iterator, _step, argumentAllocation, value, dataType, name;

    return _regeneratorRuntime.wrap(function decodeCalldata$(_context2) {
        while (1) {
            switch (_context2.prev = _context2.next) {
                case 0:
                    context = info.currentContext;

                    if (!(context === null)) {
                        _context2.next = 7;
                        break;
                    }

                    if (!isConstructor) {
                        _context2.next = 6;
                        break;
                    }

                    return _context2.abrupt("return", {
                        kind: "create",
                        decodingMode: "full",
                        bytecode: Conversion.toHexString(info.state.calldata)
                    });

                case 6:
                    return _context2.abrupt("return", {
                        kind: "unknown",
                        decodingMode: "full",
                        data: Conversion.toHexString(info.state.calldata)
                    });

                case 7:
                    contextHash = context.context;
                    contractType = Contexts.Import.contextToType(context);
                    isConstructor = context.isConstructor;
                    allocations = info.allocations.calldata;

                    if (!isConstructor) {
                        _context2.next = 15;
                        break;
                    }

                    allocation = (allocations.constructorAllocations[contextHash] || {
                        input: undefined
                    }).input;
                    _context2.next = 19;
                    break;

                case 15:
                    return _context2.delegateYield(read_1.default({
                        location: "calldata",
                        start: 0,
                        length: Evm.Utils.SELECTOR_SIZE
                    }, info.state), "t0", 16);

                case 16:
                    rawSelector = _context2.t0;
                    selector = Conversion.toHexString(rawSelector);
                    allocation = ((allocations.functionAllocations[contextHash] || {})[selector] || {
                        input: undefined
                    }).input;

                case 19:
                    if (!(allocation === undefined)) {
                        _context2.next = 23;
                        break;
                    }

                    abiEntry = null;

                    if (info.state.calldata.length === 0) {
                        //to hell with reads, let's just be direct
                        abiEntry = context.fallbackAbi.receive || context.fallbackAbi.fallback;
                    } else {
                        abiEntry = context.fallbackAbi.fallback;
                    }

                    return _context2.abrupt("return", {
                        kind: "message",
                        class: contractType,
                        abi: abiEntry,
                        data: Conversion.toHexString(info.state.calldata),
                        decodingMode: "full"
                    });

                case 23:
                    decodingMode = allocation.allocationMode; //starts out this way, degrades to ABI if necessary

                    debug("calldata decoding mode: %s", decodingMode); //you can't map with a generator, so we have to do this map manually

                    decodedArguments = [];
                    _iterator = _createForOfIteratorHelper(allocation.arguments);
                    _context2.prev = 27;

                    _iterator.s();

                case 29:
                    if ((_step = _iterator.n()).done) {
                        _context2.next = 54;
                        break;
                    }

                    argumentAllocation = _step.value;
                    value = void 0;
                    dataType = decodingMode === "full" ? argumentAllocation.type : abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes);
                    _context2.prev = 33;
                    return _context2.delegateYield(decode_1.default(dataType, argumentAllocation.pointer, info, {
                        abiPointerBase: allocation.offset,
                        allowRetry: decodingMode === "full"
                    }), "t1", 35);

                case 35:
                    value = _context2.t1;
                    _context2.next = 50;
                    break;

                case 38:
                    _context2.prev = 38;
                    _context2.t2 = _context2["catch"](33);

                    if (!(_context2.t2 instanceof errors_1.StopDecodingError && _context2.t2.allowRetry && decodingMode === "full")) {
                        _context2.next = 49;
                        break;
                    }

                    debug("problem! retrying as ABI");
                    debug("error: %O", _context2.t2); //if a retry happens, we've got to do several things in order to switch to ABI mode:
                    //1. mark that we're switching to ABI mode;

                    decodingMode = "abi"; //2. abify all previously decoded values;

                    decodedArguments = decodedArguments.map(function(argumentDecoding) {
                        return Object.assign(Object.assign({}, argumentDecoding), {
                            value: abify_1.abifyResult(argumentDecoding.value, info.userDefinedTypes)
                        });
                    }); //3. retry this particular decode in ABI mode.
                    //(no try/catch on this one because we can't actually handle errors here!
                    //not that they should be occurring)

                    return _context2.delegateYield(decode_1.default(abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes), //type is now abified!
                        argumentAllocation.pointer, info, {
                            abiPointerBase: allocation.offset
                        }), "t3", 46);

                case 46:
                    value = _context2.t3;
                    _context2.next = 50;
                    break;

                case 49:
                    throw _context2.t2;

                case 50:
                    name = argumentAllocation.name;
                    decodedArguments.push(name //deliberate general falsiness test
                        ?
                        {
                            name: name,
                            value: value
                        } : {
                            value: value
                        });

                case 52:
                    _context2.next = 29;
                    break;

                case 54:
                    _context2.next = 59;
                    break;

                case 56:
                    _context2.prev = 56;
                    _context2.t4 = _context2["catch"](27);

                    _iterator.e(_context2.t4);

                case 59:
                    _context2.prev = 59;

                    _iterator.f();

                    return _context2.finish(59);

                case 62:
                    if (!isConstructor) {
                        _context2.next = 66;
                        break;
                    }

                    return _context2.abrupt("return", {
                        kind: "constructor",
                        class: contractType,
                        arguments: decodedArguments,
                        abi: allocation.abi,
                        bytecode: Conversion.toHexString(info.state.calldata.slice(0, allocation.offset)),
                        decodingMode: decodingMode
                    });

                case 66:
                    return _context2.abrupt("return", {
                        kind: "function",
                        class: contractType,
                        abi: allocation.abi,
                        arguments: decodedArguments,
                        selector: selector,
                        decodingMode: decodingMode
                    });

                case 67:
                case "end":
                    return _context2.stop();
            }
        }
    }, _marked2, null, [
        [27, 56, 59, 62],
        [33, 38]
    ]);
}

exports.decodeCalldata = decodeCalldata;
/**
 * @Category Decoding
 */

function decodeEvent(info, address) {
    var _ref13, _ref14;

    var options,
        allocations,
        extras,
        rawSelector,
        selector,
        contractAllocations,
        libraryAllocations,
        contractAnonymousAllocations,
        libraryAnonymousAllocations,
        topicsCount,
        _allocations$topicsCo,
        _allocations$topicsCo2,
        codeBytes,
        codeAsHex,
        contractContext,
        possibleContractAllocations,
        possibleContractAnonymousAllocations,
        possibleExtraAllocations,
        possibleExtraAnonymousAllocations,
        emittingContextHash,
        _ref,
        _ref6,
        contractAllocation,
        contractAnonymousAllocation,
        _ref11,
        _ref12,
        possibleLibraryAllocations,
        possibleLibraryAnonymousAllocations,
        possibleAllocations,
        possibleAnonymousAllocations,
        possibleAllocationsTotalMinusExtras,
        possibleExtraAllocationsTotal,
        possibleAllocationsTotal,
        decodings,
        _iterator2,
        _step2,
        allocation,
        decodingMode,
        contextHash,
        attemptContext,
        emittingContractType,
        contractType,
        decodedArguments,
        _iterator3,
        _step3,
        argumentAllocation,
        value,
        dataType,
        name,
        indexed,
        nonIndexedValues,
        reEncodedData,
        encodedData,
        indexedValues,
        reEncodedTopics,
        encodedTopics,
        selectorAdjustment,
        i,
        _args3 = arguments;

    return _regeneratorRuntime.wrap(function decodeEvent$(_context3) {
        while (1) {
            switch (_context3.prev = _context3.next) {
                case 0:
                    options = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {};
                    allocations = info.allocations.event;
                    extras = options.extras || "off";
                    topicsCount = info.state.eventtopics.length; //yeah, it's not great to read directly from the state like this (bypassing read), but what are you gonna do?

                    if (!allocations[topicsCount]) {
                        _context3.next = 19;
                        break;
                    }

                    if (!(topicsCount > 0)) {
                        _context3.next = 12;
                        break;
                    }

                    return _context3.delegateYield(read_1.default({
                        location: "eventtopic",
                        topic: 0
                    }, info.state), "t0", 7);

                case 7:
                    rawSelector = _context3.t0;
                    selector = Conversion.toHexString(rawSelector);

                    if (allocations[topicsCount].bySelector[selector]) {
                        _allocations$topicsCo = allocations[topicsCount].bySelector[selector];
                        contractAllocations = _allocations$topicsCo.contract;
                        libraryAllocations = _allocations$topicsCo.library;
                    } else {
                        debug("no allocations for that selector!");
                        contractAllocations = {};
                        libraryAllocations = {};
                    }

                    _context3.next = 14;
                    break;

                case 12:
                    //if we don't have a selector, it means we don't have any non-anonymous events
                    contractAllocations = {};
                    libraryAllocations = {};

                case 14:
                    _allocations$topicsCo2 = allocations[topicsCount].anonymous;
                    contractAnonymousAllocations = _allocations$topicsCo2.contract;
                    libraryAnonymousAllocations = _allocations$topicsCo2.library;
                    _context3.next = 21;
                    break;

                case 19:
                    //if there's not even an allocation for the topics count, we can't
                    //decode; we could do this the honest way of setting all four allocation
                    //objects to {}, but let's just short circuit
                    debug("no allocations for that topic count!");
                    return _context3.abrupt("return", []);

                case 21:
                    _context3.next = 23;
                    return {
                        type: "code",
                        address: address
                    };

                case 23:
                    codeBytes = _context3.sent;
                    codeAsHex = Conversion.toHexString(codeBytes);
                    contractContext = Contexts.Utils.findContext(info.contexts, codeAsHex);
                    emittingContextHash = (contractContext || {
                        context: undefined
                    }).context;

                    if (emittingContextHash) {
                        //if we found the contract, maybe it's from that contract
                        contractAllocation = contractAllocations[emittingContextHash];
                        contractAnonymousAllocation = contractAnonymousAllocations[emittingContextHash];
                        possibleContractAllocations = contractAllocation || [];
                        possibleContractAnonymousAllocations = contractAnonymousAllocation || []; //also, we need to set up the extras (everything that's from a
                        //non-library contract but *not* this one)

                        possibleExtraAllocations = (_ref = []).concat.apply(_ref, _toConsumableArray(Object.entries(contractAllocations).filter(function(_ref2) {
                            var _ref3 = _slicedToArray(_ref2, 2),
                                key = _ref3[0],
                                _ = _ref3[1];

                            return key !== emittingContextHash;
                        }).map(function(_ref4) {
                            var _ref5 = _slicedToArray(_ref4, 2),
                                _ = _ref5[0],
                                value = _ref5[1];

                            return value;
                        })));
                        possibleExtraAnonymousAllocations = (_ref6 = []).concat.apply(_ref6, _toConsumableArray(Object.entries(contractAnonymousAllocations).filter(function(_ref7) {
                            var _ref8 = _slicedToArray(_ref7, 2),
                                key = _ref8[0],
                                _ = _ref8[1];

                            return key !== emittingContextHash;
                        }).map(function(_ref9) {
                            var _ref10 = _slicedToArray(_ref9, 2),
                                _ = _ref10[0],
                                value = _ref10[1];

                            return value;
                        })));
                    } else {
                        //if we couldn't determine the contract, well, we have to assume it's from a library
                        debug("couldn't find context");
                        possibleContractAllocations = [];
                        possibleContractAnonymousAllocations = []; //or it's an extra, which could be any of the contracts

                        possibleExtraAllocations = (_ref11 = []).concat.apply(_ref11, _toConsumableArray(Object.values(contractAllocations)));
                        possibleExtraAnonymousAllocations = (_ref12 = []).concat.apply(_ref12, _toConsumableArray(Object.values(contractAnonymousAllocations)));
                    } //now we get all the library allocations!


                    possibleLibraryAllocations = (_ref13 = []).concat.apply(_ref13, _toConsumableArray(Object.values(libraryAllocations)));
                    possibleLibraryAnonymousAllocations = (_ref14 = []).concat.apply(_ref14, _toConsumableArray(Object.values(libraryAnonymousAllocations))); //now we put it all together!

                    possibleAllocations = possibleContractAllocations.concat(possibleLibraryAllocations);
                    possibleAnonymousAllocations = possibleContractAnonymousAllocations.concat(possibleLibraryAnonymousAllocations);
                    possibleAllocationsTotalMinusExtras = possibleAllocations.concat(possibleAnonymousAllocations); //...and also there's the extras

                    possibleExtraAllocationsTotal = possibleExtraAllocations.concat(possibleExtraAnonymousAllocations);
                    possibleAllocationsTotal = possibleAllocationsTotalMinusExtras.concat([null], //HACK: add sentinel value before the extras
                        possibleExtraAllocationsTotal); //whew!

                    decodings = [];
                    _iterator2 = _createForOfIteratorHelper(possibleAllocationsTotal);
                    _context3.prev = 37;

                    _iterator2.s();

                case 39:
                    if ((_step2 = _iterator2.n()).done) {
                        _context3.next = 126;
                        break;
                    }

                    allocation = _step2.value;
                    debug("trying allocation: %O", allocation); //first: check for our sentinel value for extras (yeah, kind of HACKy)

                    if (!(allocation === null)) {
                        _context3.next = 53;
                        break;
                    }

                    _context3.t1 = extras;
                    _context3.next = _context3.t1 === "on" ? 46 : _context3.t1 === "off" ? 47 : _context3.t1 === "necessary" ? 48 : 53;
                    break;

                case 46:
                    return _context3.abrupt("continue", 124);

                case 47:
                    return _context3.abrupt("break", 126);

                case 48:
                    if (!(decodings.length > 0)) {
                        _context3.next = 52;
                        break;
                    }

                    return _context3.abrupt("break", 126);

                case 52:
                    return _context3.abrupt("continue", 124);

                case 53:
                    if (!(options.name !== undefined && allocation.abi.name !== options.name)) {
                        _context3.next = 55;
                        break;
                    }

                    return _context3.abrupt("continue", 124);

                case 55:
                    //now: the main part!
                    decodingMode = allocation.allocationMode; //starts out here; degrades to abi if necessary

                    contextHash = allocation.contextHash;
                    attemptContext = info.contexts[contextHash];
                    emittingContractType = Contexts.Import.contextToType(attemptContext);
                    contractType = allocation.definedIn; //you can't map with a generator, so we have to do this map manually

                    decodedArguments = [];
                    _iterator3 = _createForOfIteratorHelper(allocation.arguments);
                    _context3.prev = 62;

                    _iterator3.s();

                case 64:
                    if ((_step3 = _iterator3.n()).done) {
                        _context3.next = 96;
                        break;
                    }

                    argumentAllocation = _step3.value;
                    value = void 0; //if in full mode, use the allocation's listed data type.
                    //if in ABI mode, abify it before use.

                    dataType = decodingMode === "full" ? argumentAllocation.type : abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes);
                    _context3.prev = 68;
                    return _context3.delegateYield(decode_1.default(dataType, argumentAllocation.pointer, info, {
                        strictAbiMode: true,
                        allowRetry: decodingMode === "full" //this option is unnecessary but including for clarity

                    }), "t2", 70);

                case 70:
                    value = _context3.t2;
                    _context3.next = 91;
                    break;

                case 73:
                    _context3.prev = 73;
                    _context3.t3 = _context3["catch"](68);

                    if (!(_context3.t3 instanceof errors_1.StopDecodingError && _context3.t3.allowRetry && decodingMode === "full")) {
                        _context3.next = 89;
                        break;
                    }

                    //if a retry happens, we've got to do several things in order to switch to ABI mode:
                    //1. mark that we're switching to ABI mode;
                    decodingMode = "abi"; //2. abify all previously decoded values;

                    decodedArguments = decodedArguments.map(function(argumentDecoding) {
                        return Object.assign(Object.assign({}, argumentDecoding), {
                            value: abify_1.abifyResult(argumentDecoding.value, info.userDefinedTypes)
                        });
                    }); //3. retry this particular decode in ABI mode.

                    _context3.prev = 78;
                    return _context3.delegateYield(decode_1.default(abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes), //type is now abified!
                        argumentAllocation.pointer, info, {
                            strictAbiMode: true //turns on STRICT MODE to cause more errors to be thrown
                            //retries no longer allowed, not that this has an effect

                        }), "t4", 80);

                case 80:
                    value = _context3.t4;
                    _context3.next = 87;
                    break;

                case 83:
                    _context3.prev = 83;
                    _context3.t5 = _context3["catch"](78);
                    //if an error occurred on the retry, this isn't a valid decoding!
                    debug("rejected due to exception on retry");
                    return _context3.abrupt("continue", 124);

                case 87:
                    _context3.next = 91;
                    break;

                case 89:
                    //if any other sort of error occurred, this isn't a valid decoding!
                    debug("rejected due to exception on first try: %O", _context3.t3);
                    return _context3.abrupt("continue", 124);

                case 91:
                    name = argumentAllocation.name;
                    indexed = argumentAllocation.pointer.location === "eventtopic";
                    decodedArguments.push(name //deliberate general falsiness test
                        ?
                        {
                            name: name,
                            indexed: indexed,
                            value: value
                        } : {
                            indexed: indexed,
                            value: value
                        });

                case 94:
                    _context3.next = 64;
                    break;

                case 96:
                    _context3.next = 101;
                    break;

                case 98:
                    _context3.prev = 98;
                    _context3.t6 = _context3["catch"](62);

                    _iterator3.e(_context3.t6);

                case 101:
                    _context3.prev = 101;

                    _iterator3.f();

                    return _context3.finish(101);

                case 104:
                    //OK, so, having decoded the result, the question is: does it reencode to the original?
                    //first, we have to filter out the indexed arguments, and also get rid of the name information
                    nonIndexedValues = decodedArguments.filter(function(argument) {
                        return !argument.indexed;
                    }).map(function(argument) {
                        return argument.value;
                    }); //now, we can encode!

                    reEncodedData = AbiData.Encode.encodeTupleAbi(nonIndexedValues, info.allocations.abi);
                    encodedData = info.state.eventdata; //again, not great to read this directly, but oh well
                    //are they equal?

                    if (Evm.Utils.equalData(reEncodedData, encodedData)) {
                        _context3.next = 110;
                        break;
                    }

                    //if not, this allocation doesn't work
                    debug("rejected due to [non-indexed] mismatch");
                    return _context3.abrupt("continue", 124);

                case 110:
                    //one last check -- let's check that the indexed arguments match up, too
                    indexedValues = decodedArguments.filter(function(argument) {
                        return argument.indexed;
                    }).map(function(argument) {
                        return argument.value;
                    });
                    reEncodedTopics = indexedValues.map(Topic.Encode.encodeTopic);
                    encodedTopics = info.state.eventtopics; //now: do *these* match?

                    selectorAdjustment = allocation.anonymous ? 0 : 1;
                    i = 0;

                case 115:
                    if (!(i < reEncodedTopics.length)) {
                        _context3.next = 122;
                        break;
                    }

                    if (Evm.Utils.equalData(reEncodedTopics[i], encodedTopics[i + selectorAdjustment])) {
                        _context3.next = 119;
                        break;
                    }

                    debug("rejected due to indexed mismatch");
                    return _context3.abrupt("continue", 124);

                case 119:
                    i++;
                    _context3.next = 115;
                    break;

                case 122:
                    //if we've made it here, the allocation works!  hooray!
                    debug("allocation accepted!");

                    if (allocation.abi.anonymous) {
                        decodings.push({
                            kind: "anonymous",
                            definedIn: contractType,
                            class: emittingContractType,
                            abi: allocation.abi,
                            arguments: decodedArguments,
                            decodingMode: decodingMode
                        });
                    } else {
                        decodings.push({
                            kind: "event",
                            definedIn: contractType,
                            class: emittingContractType,
                            abi: allocation.abi,
                            arguments: decodedArguments,
                            selector: selector,
                            decodingMode: decodingMode
                        });
                    }

                case 124:
                    _context3.next = 39;
                    break;

                case 126:
                    _context3.next = 131;
                    break;

                case 128:
                    _context3.prev = 128;
                    _context3.t7 = _context3["catch"](37);

                    _iterator2.e(_context3.t7);

                case 131:
                    _context3.prev = 131;

                    _iterator2.f();

                    return _context3.finish(131);

                case 134:
                    return _context3.abrupt("return", decodings);

                case 135:
                case "end":
                    return _context3.stop();
            }
        }
    }, _marked3, null, [
        [37, 128, 131, 134],
        [62, 98, 101, 104],
        [68, 73],
        [78, 83]
    ]);
}

exports.decodeEvent = decodeEvent;
var errorSelector = Conversion.toBytes(Web3Utils.soliditySha3({
    type: "string",
    value: "Error(string)"
})).subarray(0, Evm.Utils.SELECTOR_SIZE);
var panicSelector = Conversion.toBytes(Web3Utils.soliditySha3({
    type: "string",
    value: "Panic(uint256)"
})).subarray(0, Evm.Utils.SELECTOR_SIZE);
var defaultReturnAllocationsHighPriority = [{
    kind: "revert",
    allocationMode: "full",
    selector: errorSelector,
    abi: {
        name: "Error",
        type: "error",
        inputs: [{
            name: "",
            type: "string",
            internalType: "string"
        }]
    },
    arguments: [{
        name: "",
        pointer: {
            location: "returndata",
            start: errorSelector.length,
            length: Evm.Utils.WORD_SIZE
        },
        type: {
            typeClass: "string",
            typeHint: "string"
        }
    }]
}, {
    kind: "revert",
    allocationMode: "full",
    selector: panicSelector,
    abi: {
        name: "Panic",
        type: "error",
        inputs: [{
            name: "",
            type: "uint256",
            internalType: "uint256"
        }]
    },
    arguments: [{
        name: "",
        pointer: {
            location: "returndata",
            start: panicSelector.length,
            length: Evm.Utils.WORD_SIZE
        },
        type: {
            typeClass: "uint",
            bits: Evm.Utils.WORD_SIZE * 8,
            typeHint: "uint256"
        }
    }]
}];
var defaultReturnAllocationsLowPriority = [{
    kind: "failure",
    allocationMode: "full",
    selector: new Uint8Array(),
    arguments: []
}, {
    kind: "selfdestruct",
    allocationMode: "full",
    selector: new Uint8Array(),
    arguments: []
}];
var defaultReturnAllocations = [].concat(defaultReturnAllocationsHighPriority, defaultReturnAllocationsLowPriority);
/**
 * If there are multiple possibilities, they're always returned in
 * the order: return, revert, returnmessage, failure, empty, bytecode, unknownbytecode
 * @Category Decoding
 */

function decodeReturndata(info, successAllocation, //null here must be explicit
    status //you can pass this to indicate that you know the status
) {
    var possibleAllocations, decodings, _iterator4, _step4, allocation, encodedData, encodedPrefix, successKinds, failKinds, _decoding, _decoding2, decodingMode, decodedArguments, _iterator5, _step5, argumentAllocation, value, dataType, name, decodedArgumentValues, reEncodedData, decoding, kind;

    return _regeneratorRuntime.wrap(function decodeReturndata$(_context4) {
        while (1) {
            switch (_context4.prev = _context4.next) {
                case 0:
                    if (!(successAllocation === null)) {
                        _context4.next = 4;
                        break;
                    }

                    possibleAllocations = defaultReturnAllocations;
                    _context4.next = 13;
                    break;

                case 4:
                    _context4.t0 = successAllocation.kind;
                    _context4.next = _context4.t0 === "return" ? 7 : _context4.t0 === "bytecode" ? 9 : _context4.t0 === "returnmessage" ? 11 : 13;
                    break;

                case 7:
                    possibleAllocations = [successAllocation].concat(_toConsumableArray(defaultReturnAllocations));
                    return _context4.abrupt("break", 13);

                case 9:
                    possibleAllocations = [].concat(_toConsumableArray(defaultReturnAllocations), [successAllocation]);
                    return _context4.abrupt("break", 13);

                case 11:
                    possibleAllocations = [].concat(defaultReturnAllocationsHighPriority, [successAllocation], defaultReturnAllocationsLowPriority);
                    return _context4.abrupt("break", 13);

                case 13:
                    decodings = [];
                    _iterator4 = _createForOfIteratorHelper(possibleAllocations);
                    _context4.prev = 15;

                    _iterator4.s();

                case 17:
                    if ((_step4 = _iterator4.n()).done) {
                        _context4.next = 114;
                        break;
                    }

                    allocation = _step4.value;
                    debug("trying allocation: %O", allocation); //before we attempt to use this allocation, we check: does the selector match?

                    encodedData = info.state.returndata; //again, not great to read this directly, but oh well

                    encodedPrefix = encodedData.subarray(0, allocation.selector.length);

                    if (Evm.Utils.equalData(encodedPrefix, allocation.selector)) {
                        _context4.next = 24;
                        break;
                    }

                    return _context4.abrupt("continue", 112);

                case 24:
                    encodedData = encodedData.subarray(allocation.selector.length); //slice off the selector for later
                    //also we check, does the status match?

                    if (!(status !== undefined)) {
                        _context4.next = 35;
                        break;
                    }

                    successKinds = ["return", "selfdestruct", "bytecode", "returnmessage"];
                    failKinds = ["failure", "revert"];

                    if (!status) {
                        _context4.next = 33;
                        break;
                    }

                    if (successKinds.includes(allocation.kind)) {
                        _context4.next = 31;
                        break;
                    }

                    return _context4.abrupt("continue", 112);

                case 31:
                    _context4.next = 35;
                    break;

                case 33:
                    if (failKinds.includes(allocation.kind)) {
                        _context4.next = 35;
                        break;
                    }

                    return _context4.abrupt("continue", 112);

                case 35:
                    if (!(allocation.kind === "bytecode")) {
                        _context4.next = 40;
                        break;
                    }

                    return _context4.delegateYield(decodeBytecode(info), "t1", 37);

                case 37:
                    _decoding = _context4.t1;

                    if (_decoding) {
                        decodings.push(_decoding);
                    }

                    return _context4.abrupt("continue", 112);

                case 40:
                    if (!(allocation.kind === "returnmessage")) {
                        _context4.next = 44;
                        break;
                    }

                    //this kind is also special, though thankfully it's easier
                    _decoding2 = {
                        kind: "returnmessage",
                        status: true,
                        data: Conversion.toHexString(info.state.returndata),
                        decodingMode: allocation.allocationMode
                    };
                    decodings.push(_decoding2);
                    return _context4.abrupt("continue", 112);

                case 44:
                    decodingMode = allocation.allocationMode; //starts out here; degrades to abi if necessary
                    //you can't map with a generator, so we have to do this map manually

                    decodedArguments = [];
                    _iterator5 = _createForOfIteratorHelper(allocation.arguments);
                    _context4.prev = 47;

                    _iterator5.s();

                case 49:
                    if ((_step5 = _iterator5.n()).done) {
                        _context4.next = 83;
                        break;
                    }

                    argumentAllocation = _step5.value;
                    value = void 0; //if in full mode, use the allocation's listed data type.
                    //if in ABI mode, abify it before use.

                    dataType = decodingMode === "full" ? argumentAllocation.type : abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes); //now, let's decode!

                    _context4.prev = 53;
                    return _context4.delegateYield(decode_1.default(dataType, argumentAllocation.pointer, info, {
                        abiPointerBase: allocation.selector.length,
                        strictAbiMode: true,
                        allowRetry: decodingMode === "full" //this option is unnecessary but including for clarity

                    }), "t2", 55);

                case 55:
                    value = _context4.t2;
                    debug("value on first try: %O", value);
                    _context4.next = 79;
                    break;

                case 59:
                    _context4.prev = 59;
                    _context4.t3 = _context4["catch"](53);

                    if (!(_context4.t3 instanceof errors_1.StopDecodingError && _context4.t3.allowRetry && decodingMode === "full")) {
                        _context4.next = 77;
                        break;
                    }

                    debug("retry!"); //if a retry happens, we've got to do several things in order to switch to ABI mode:
                    //1. mark that we're switching to ABI mode;

                    decodingMode = "abi"; //2. abify all previously decoded values;

                    decodedArguments = decodedArguments.map(function(argumentDecoding) {
                        return Object.assign(Object.assign({}, argumentDecoding), {
                            value: abify_1.abifyResult(argumentDecoding.value, info.userDefinedTypes)
                        });
                    }); //3. retry this particular decode in ABI mode.

                    _context4.prev = 65;
                    return _context4.delegateYield(decode_1.default(abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes), //type is now abified!
                        argumentAllocation.pointer, info, {
                            abiPointerBase: allocation.selector.length,
                            strictAbiMode: true //turns on STRICT MODE to cause more errors to be thrown
                            //retries no longer allowed, not that this has an effect

                        }), "t4", 67);

                case 67:
                    value = _context4.t4;
                    debug("value on retry: %O", value);
                    _context4.next = 75;
                    break;

                case 71:
                    _context4.prev = 71;
                    _context4.t5 = _context4["catch"](65);
                    //if an error occurred on the retry, this isn't a valid decoding!
                    debug("rejected due to exception on retry");
                    return _context4.abrupt("continue", 112);

                case 75:
                    _context4.next = 79;
                    break;

                case 77:
                    //if any other sort of error occurred, this isn't a valid decoding!
                    debug("rejected due to exception on first try: %O", _context4.t3);
                    return _context4.abrupt("continue", 112);

                case 79:
                    name = argumentAllocation.name;
                    decodedArguments.push(name //deliberate general falsiness test
                        ?
                        {
                            name: name,
                            value: value
                        } : {
                            value: value
                        });

                case 81:
                    _context4.next = 49;
                    break;

                case 83:
                    _context4.next = 88;
                    break;

                case 85:
                    _context4.prev = 85;
                    _context4.t6 = _context4["catch"](47);

                    _iterator5.e(_context4.t6);

                case 88:
                    _context4.prev = 88;

                    _iterator5.f();

                    return _context4.finish(88);

                case 91:
                    //OK, so, having decoded the result, the question is: does it reencode to the original?
                    //first, we have to filter out the indexed arguments, and also get rid of the name information
                    debug("decodedArguments: %O", decodedArguments);
                    decodedArgumentValues = decodedArguments.map(function(argument) {
                        return argument.value;
                    });
                    reEncodedData = AbiData.Encode.encodeTupleAbi(decodedArgumentValues, info.allocations.abi); //are they equal? note the selector has been stripped off encodedData!

                    if (Evm.Utils.equalData(reEncodedData, encodedData)) {
                        _context4.next = 97;
                        break;
                    }

                    //if not, this allocation doesn't work
                    debug("rejected due to mismatch");
                    return _context4.abrupt("continue", 112);

                case 97:
                    //if we've made it here, the allocation works!  hooray!
                    debug("allocation accepted!");
                    decoding = void 0;
                    kind = allocation.kind;
                    _context4.t7 = kind;
                    _context4.next = _context4.t7 === "return" ? 103 : _context4.t7 === "revert" ? 105 : _context4.t7 === "selfdestruct" ? 107 : _context4.t7 === "failure" ? 109 : 111;
                    break;

                case 103:
                    decoding = {
                        kind: kind,
                        status: true,
                        arguments: decodedArguments,
                        decodingMode: decodingMode
                    };
                    return _context4.abrupt("break", 111);

                case 105:
                    decoding = {
                        kind: kind,
                        abi: allocation.abi,
                        status: false,
                        arguments: decodedArguments,
                        decodingMode: decodingMode
                    };
                    return _context4.abrupt("break", 111);

                case 107:
                    decoding = {
                        kind: kind,
                        status: true,
                        decodingMode: decodingMode
                    };
                    return _context4.abrupt("break", 111);

                case 109:
                    decoding = {
                        kind: kind,
                        status: false,
                        decodingMode: decodingMode
                    };
                    return _context4.abrupt("break", 111);

                case 111:
                    decodings.push(decoding);

                case 112:
                    _context4.next = 17;
                    break;

                case 114:
                    _context4.next = 119;
                    break;

                case 116:
                    _context4.prev = 116;
                    _context4.t8 = _context4["catch"](15);

                    _iterator4.e(_context4.t8);

                case 119:
                    _context4.prev = 119;

                    _iterator4.f();

                    return _context4.finish(119);

                case 122:
                    return _context4.abrupt("return", decodings);

                case 123:
                case "end":
                    return _context4.stop();
            }
        }
    }, _marked4, null, [
        [15, 116, 119, 122],
        [47, 85, 88, 91],
        [53, 59],
        [65, 71]
    ]);
}

exports.decodeReturndata = decodeReturndata; //note: requires the bytecode to be in returndata, not code

function decodeBytecode(info) {
    var decodingMode, bytecode, context, contractType, allocation, immutables, _iterator6, _step6, variable, dataType, value, decoding;

    return _regeneratorRuntime.wrap(function decodeBytecode$(_context5) {
        while (1) {
            switch (_context5.prev = _context5.next) {
                case 0:
                    decodingMode = "full"; //as always, degrade as necessary

                    bytecode = Conversion.toHexString(info.state.returndata);
                    context = Contexts.Utils.findContext(info.contexts, bytecode);

                    if (context) {
                        _context5.next = 5;
                        break;
                    }

                    return _context5.abrupt("return", {
                        kind: "unknownbytecode",
                        status: true,
                        decodingMode: "full",
                        bytecode: bytecode
                    });

                case 5:
                    contractType = Contexts.Import.contextToType(context); //now: ignore original allocation (which we didn't even pass :) )
                    //and lookup allocation by context

                    allocation = info.allocations.calldata.constructorAllocations[context.context].output;
                    debug("bytecode allocation: %O", allocation); //now: add immutables if applicable

                    if (!allocation.immutables) {
                        _context5.next = 42;
                        break;
                    }

                    immutables = []; //NOTE: if we're in here, we can assume decodingMode === "full"

                    _iterator6 = _createForOfIteratorHelper(allocation.immutables);
                    _context5.prev = 11;

                    _iterator6.s();

                case 13:
                    if ((_step6 = _iterator6.n()).done) {
                        _context5.next = 34;
                        break;
                    }

                    variable = _step6.value;
                    dataType = variable.type; //we don't conditioning on decodingMode here because we know it

                    value = void 0;
                    _context5.prev = 17;
                    return _context5.delegateYield(decode_1.default(dataType, variable.pointer, info, {
                        allowRetry: true,
                        strictAbiMode: true,
                        paddingMode: "zero" //force zero-padding!

                    }), "t0", 19);

                case 19:
                    value = _context5.t0;
                    _context5.next = 31;
                    break;

                case 22:
                    _context5.prev = 22;
                    _context5.t1 = _context5["catch"](17);

                    if (!(_context5.t1 instanceof errors_1.StopDecodingError && _context5.t1.allowRetry)) {
                        _context5.next = 30;
                        break;
                    }

                    //we "retry" by... not bothering with immutables :P
                    //(but we do set the mode to ABI)
                    decodingMode = "abi";
                    immutables = undefined;
                    return _context5.abrupt("break", 34);

                case 30:
                    return _context5.abrupt("return", null);

                case 31:
                    immutables.push({
                        name: variable.name,
                        class: variable.definedIn,
                        value: value
                    });

                case 32:
                    _context5.next = 13;
                    break;

                case 34:
                    _context5.next = 39;
                    break;

                case 36:
                    _context5.prev = 36;
                    _context5.t2 = _context5["catch"](11);

                    _iterator6.e(_context5.t2);

                case 39:
                    _context5.prev = 39;

                    _iterator6.f();

                    return _context5.finish(39);

                case 42:
                    decoding = {
                        kind: "bytecode",
                        status: true,
                        decodingMode: decodingMode,
                        bytecode: bytecode,
                        immutables: immutables,
                        class: contractType
                    }; //finally: add address if applicable

                    if (allocation.delegatecallGuard) {
                        decoding.address = Web3Utils.toChecksumAddress(bytecode.slice(4, 4 + 2 * Evm.Utils.ADDRESS_SIZE) //4 = "0x73".length
                        );
                    }

                    return _context5.abrupt("return", decoding);

                case 45:
                case "end":
                    return _context5.stop();
            }
        }
    }, _marked5, null, [
        [11, 36, 39, 42],
        [17, 22]
    ]);
}
/**
 * Decodes the return data from a failed call.
 *
 * @param returndata The returned data, as a Uint8Array.
 * @return An array of possible decodings.  At the moment it's
 *   impossible for there to be more than one.  (If the call didn't actually
 *   fail, or failed in a nonstandard way, you may get no decodings at all, though!)
 *
 *   Decodings can either be decodings of revert messages, or decodings
 *   indicating that there was no revert message.  If somehow both were to be
 *   possible, they'd go in that order, although as mentioned, there (at least
 *   currently) isn't any way for that to occur.
 * @Category Decoding convenience
 */


function decodeRevert(returndata) {
    //coercing because TS doesn't know it'll finish in one go
    return decodeReturndata({
        allocations: {},
        state: {
            storage: {},
            returndata: returndata
        }
    }, null, false).next().value;
}

exports.decodeRevert = decodeRevert;