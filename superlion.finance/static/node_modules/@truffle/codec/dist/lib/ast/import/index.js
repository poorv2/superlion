"use strict";

var _slicedToArray = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray");

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});

var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
        for (var k in mod) {
            if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }

    __setModuleDefault(result, mod);

    return result;
};

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.definitionToStoredType = exports.definitionToType = void 0;

var debug_1 = __importDefault(require("debug"));

var debug = debug_1.default("codec:ast:import");

var bn_js_1 = __importDefault(require("bn.js"));

var Compiler = __importStar(require("../../compiler"));

var Utils = __importStar(require("../utils"));

var import_1 = require("../../contexts/import"); //NOTE: the following function will *not* work for arbitrary nodes! It will,
//however, work well enough for what we need.  I.e., it will:
//1. work when given the actual variable definition as the node,
//2. work when given an elementary type as the node,
//3. work when given a user-defined type as the node,
//4. produce something of the correct size in all cases.
//Use beyond that is at your own risk!
//NOTE: set forceLocation to *null* to force no location. leave it undefined
//to not force a location.


function definitionToType(definition, compilationId, compiler, forceLocation) {
    var typeClass = Utils.typeClass(definition);
    var typeHint = Utils.typeStringWithoutLocation(definition);

    switch (typeClass) {
        case "bool":
            return {
                typeClass: typeClass,
                typeHint: typeHint
            };

        case "address":
            {
                switch (Compiler.Utils.solidityFamily(compiler)) {
                    case "unknown": //I guess?

                    case "pre-0.5.0":
                        return {
                            typeClass: typeClass,
                            kind: "general",
                            typeHint: typeHint
                        };

                    case "0.5.x":
                    case "0.8.x":
                        return {
                            typeClass: typeClass,
                            kind: "specific",
                            payable: Utils.typeIdentifier(definition) === "t_address_payable"
                        };
                }

                break; //to satisfy typescript
            }

        case "uint":
            {
                var bytes = Utils.specifiedSize(definition);
                return {
                    typeClass: typeClass,
                    bits: bytes * 8,
                    typeHint: typeHint
                };
            }

        case "int":
            {
                //typeScript won't let me group these for some reason
                var _bytes = Utils.specifiedSize(definition);

                return {
                    typeClass: typeClass,
                    bits: _bytes * 8,
                    typeHint: typeHint
                };
            }

        case "fixed":
            {
                //typeScript won't let me group these for some reason
                var _bytes2 = Utils.specifiedSize(definition);

                var places = Utils.decimalPlaces(definition);
                return {
                    typeClass: typeClass,
                    bits: _bytes2 * 8,
                    places: places,
                    typeHint: typeHint
                };
            }

        case "ufixed":
            {
                var _bytes3 = Utils.specifiedSize(definition);

                var _places = Utils.decimalPlaces(definition);

                return {
                    typeClass: typeClass,
                    bits: _bytes3 * 8,
                    places: _places,
                    typeHint: typeHint
                };
            }

        case "string":
            {
                if (forceLocation === null) {
                    return {
                        typeClass: typeClass,
                        typeHint: typeHint
                    };
                }

                var location = forceLocation || Utils.referenceType(definition);
                return {
                    typeClass: typeClass,
                    location: location,
                    typeHint: typeHint
                };
            }

        case "bytes":
            {
                var length = Utils.specifiedSize(definition);

                if (length !== null) {
                    return {
                        typeClass: typeClass,
                        kind: "static",
                        length: length,
                        typeHint: typeHint
                    };
                } else {
                    if (forceLocation === null) {
                        return {
                            typeClass: typeClass,
                            kind: "dynamic",
                            typeHint: typeHint
                        };
                    }

                    var _location = forceLocation || Utils.referenceType(definition);

                    return {
                        typeClass: typeClass,
                        kind: "dynamic",
                        location: _location,
                        typeHint: typeHint
                    };
                }
            }

        case "array":
            {
                var baseDefinition = Utils.baseDefinition(definition);
                var baseType = definitionToType(baseDefinition, compilationId, compiler, forceLocation);

                var _location2 = forceLocation || Utils.referenceType(definition);

                if (Utils.isDynamicArray(definition)) {
                    if (forceLocation !== null) {
                        return {
                            typeClass: typeClass,
                            baseType: baseType,
                            kind: "dynamic",
                            location: _location2,
                            typeHint: typeHint
                        };
                    } else {
                        return {
                            typeClass: typeClass,
                            baseType: baseType,
                            kind: "dynamic",
                            typeHint: typeHint
                        };
                    }
                } else {
                    var _length = new bn_js_1.default(Utils.staticLengthAsString(definition));

                    if (forceLocation !== null) {
                        return {
                            typeClass: typeClass,
                            baseType: baseType,
                            kind: "static",
                            length: _length,
                            location: _location2,
                            typeHint: typeHint
                        };
                    } else {
                        return {
                            typeClass: typeClass,
                            baseType: baseType,
                            kind: "static",
                            length: _length,
                            typeHint: typeHint
                        };
                    }
                }
            }

        case "mapping":
            {
                var keyDefinition = Utils.keyDefinition(definition); //note that we can skip the scopes argument here! that's only needed when
                //a general node, rather than a declaration, is being passed in

                var keyType = definitionToType(keyDefinition, compilationId, compiler, null); //suppress the location on the key type (it'll be given as memory but
                //this is meaningless)
                //also, we have to tell TypeScript ourselves that this will be an elementary
                //type; it has no way of knowing that

                debug("definition: %O", definition);
                var valueDefinition = Utils.valueDefinition(definition);
                var valueType = definitionToType(valueDefinition, compilationId, compiler, forceLocation);

                if (forceLocation === null) {
                    return {
                        typeClass: typeClass,
                        keyType: keyType,
                        valueType: valueType
                    };
                }

                return {
                    typeClass: typeClass,
                    keyType: keyType,
                    valueType: valueType,
                    location: "storage"
                };
            }

        case "function":
            {
                //WARNING! This case will not work unless given the actual
                //definition!  It should return something *roughly* usable, though.
                var visibility = Utils.visibility(definition); //undefined if bad node

                var mutability = Utils.mutability(definition); //undefined if bad node

                var _ref = Utils.parameters(definition) || [
                        [],
                        []
                    ],
                    _ref2 = _slicedToArray(_ref, 2),
                    inputParameters = _ref2[0],
                    outputParameters = _ref2[1]; //HACK
                //note: don't force a location on these! use the listed location!


                var inputParameterTypes = inputParameters.map(function(parameter) {
                    return definitionToType(parameter, compilationId, compiler);
                });
                var outputParameterTypes = outputParameters.map(function(parameter) {
                    return definitionToType(parameter, compilationId, compiler);
                });

                switch (visibility) {
                    case "internal":
                        return {
                            typeClass: typeClass,
                            visibility: visibility,
                            mutability: mutability,
                            inputParameterTypes: inputParameterTypes,
                            outputParameterTypes: outputParameterTypes
                        };

                    case "external":
                        return {
                            typeClass: typeClass,
                            visibility: visibility,
                            kind: "specific",
                            mutability: mutability,
                            inputParameterTypes: inputParameterTypes,
                            outputParameterTypes: outputParameterTypes
                        };
                }

                break; //to satisfy typescript
            }

        case "struct":
            {
                var id = import_1.makeTypeId(Utils.typeId(definition), compilationId);
                var qualifiedName = Utils.typeStringWithoutLocation(definition).match(/struct (.*)/)[1];
                var definingContractName;
                var typeName;

                if (qualifiedName.includes(".")) {
                    var _qualifiedName$split = qualifiedName.split(".");

                    var _qualifiedName$split2 = _slicedToArray(_qualifiedName$split, 2);

                    definingContractName = _qualifiedName$split2[0];
                    typeName = _qualifiedName$split2[1];
                } else {
                    typeName = qualifiedName; //leave definingContractName undefined
                }

                if (forceLocation === null) {
                    if (definingContractName) {
                        return {
                            typeClass: typeClass,
                            kind: "local",
                            id: id,
                            typeName: typeName,
                            definingContractName: definingContractName
                        };
                    } else {
                        return {
                            typeClass: typeClass,
                            kind: "global",
                            id: id,
                            typeName: typeName
                        };
                    }
                }

                var _location3 = forceLocation || Utils.referenceType(definition);

                if (definingContractName) {
                    return {
                        typeClass: typeClass,
                        kind: "local",
                        id: id,
                        typeName: typeName,
                        definingContractName: definingContractName,
                        location: _location3
                    };
                } else {
                    return {
                        typeClass: typeClass,
                        kind: "global",
                        id: id,
                        typeName: typeName,
                        location: _location3
                    };
                }
            }

        case "enum":
            {
                var _id = import_1.makeTypeId(Utils.typeId(definition), compilationId);

                var _qualifiedName = Utils.typeStringWithoutLocation(definition).match(/enum (.*)/)[1];

                var _definingContractName;

                var _typeName;

                if (_qualifiedName.includes(".")) {
                    var _qualifiedName$split3 = _qualifiedName.split(".");

                    var _qualifiedName$split4 = _slicedToArray(_qualifiedName$split3, 2);

                    _definingContractName = _qualifiedName$split4[0];
                    _typeName = _qualifiedName$split4[1];
                } else {
                    _typeName = _qualifiedName; //leave definingContractName undefined
                }

                if (_definingContractName) {
                    return {
                        typeClass: typeClass,
                        kind: "local",
                        id: _id,
                        typeName: _typeName,
                        definingContractName: _definingContractName
                    };
                } else {
                    return {
                        typeClass: typeClass,
                        kind: "global",
                        id: _id,
                        typeName: _typeName
                    };
                }
            }

        case "contract":
            {
                var _id2 = import_1.makeTypeId(Utils.typeId(definition), compilationId);

                var _typeName2 = Utils.typeStringWithoutLocation(definition).match(/(contract|library|interface) (.*)/)[2]; //note: we use the type string rather than the type identifier
                //in order to avoid having to deal with the underscore problem

                var contractKind = Utils.contractKind(definition);
                return {
                    typeClass: typeClass,
                    kind: "native",
                    id: _id2,
                    typeName: _typeName2,
                    contractKind: contractKind
                };
            }

        case "magic":
            {
                var typeIdentifier = Utils.typeIdentifier(definition);
                var variable = typeIdentifier.match(/^t_magic_(.*)$/)[1];
                return {
                    typeClass: typeClass,
                    variable: variable
                };
            }
    }
}

exports.definitionToType = definitionToType; //whereas the above takes variable definitions, this takes the actual type
//definition

function definitionToStoredType(definition, compilationId, compiler, referenceDeclarations) {
    switch (definition.nodeType) {
        case "StructDefinition":
            {
                var id = import_1.makeTypeId(definition.id, compilationId);
                var definingContractName;
                var typeName;

                if (definition.canonicalName.includes(".")) {
                    var _definition$canonical = definition.canonicalName.split(".");

                    var _definition$canonical2 = _slicedToArray(_definition$canonical, 2);

                    definingContractName = _definition$canonical2[0];
                    typeName = _definition$canonical2[1];
                } else {
                    typeName = definition.canonicalName; //leave definingContractName undefined
                }

                var memberTypes = definition.members.map(function(member) {
                    return {
                        name: member.name,
                        type: definitionToType(member, compilationId, compiler, null)
                    };
                });
                var definingContract;

                if (referenceDeclarations) {
                    var contractDefinition = Object.values(referenceDeclarations).find(function(node) {
                        return node.nodeType === "ContractDefinition" && node.nodes.some(function(subNode) {
                            return import_1.makeTypeId(subNode.id, compilationId) === id;
                        });
                    });

                    if (contractDefinition) {
                        definingContract = definitionToStoredType(contractDefinition, compilationId, compiler); //can skip reference declarations
                    }
                }

                if (definingContract) {
                    return {
                        typeClass: "struct",
                        kind: "local",
                        id: id,
                        typeName: typeName,
                        definingContractName: definingContractName,
                        definingContract: definingContract,
                        memberTypes: memberTypes
                    };
                } else {
                    return {
                        typeClass: "struct",
                        kind: "global",
                        id: id,
                        typeName: typeName,
                        memberTypes: memberTypes
                    };
                }
            }

        case "EnumDefinition":
            {
                var _id3 = import_1.makeTypeId(definition.id, compilationId);

                var _definingContractName2;

                var _typeName3;

                debug("typeName: %s", _typeName3);

                if (definition.canonicalName.includes(".")) {
                    var _definition$canonical3 = definition.canonicalName.split(".");

                    var _definition$canonical4 = _slicedToArray(_definition$canonical3, 2);

                    _definingContractName2 = _definition$canonical4[0];
                    _typeName3 = _definition$canonical4[1];
                } else {
                    _typeName3 = definition.canonicalName; //leave definingContractName undefined
                }

                var options = definition.members.map(function(member) {
                    return member.name;
                });

                var _definingContract;

                if (referenceDeclarations) {
                    var _contractDefinition = Object.values(referenceDeclarations).find(function(node) {
                        return node.nodeType === "ContractDefinition" && node.nodes.some(function(subNode) {
                            return import_1.makeTypeId(subNode.id, compilationId) === _id3;
                        });
                    });

                    if (_contractDefinition) {
                        _definingContract = definitionToStoredType(_contractDefinition, compilationId, compiler); //can skip reference declarations

                        debug("contractDefinition: %o", _contractDefinition);
                        debug("definingContract: %o", _definingContract);
                    }
                }

                if (_definingContract) {
                    return {
                        typeClass: "enum",
                        kind: "local",
                        id: _id3,
                        typeName: _typeName3,
                        definingContractName: _definingContractName2,
                        definingContract: _definingContract,
                        options: options
                    };
                } else {
                    return {
                        typeClass: "enum",
                        kind: "global",
                        id: _id3,
                        typeName: _typeName3,
                        options: options
                    };
                }
            }

        case "ContractDefinition":
            {
                var _id4 = import_1.makeTypeId(definition.id, compilationId);

                var _typeName4 = definition.name;
                var contractKind = definition.contractKind;
                var payable = Utils.isContractPayable(definition);
                return {
                    typeClass: "contract",
                    kind: "native",
                    id: _id4,
                    typeName: _typeName4,
                    contractKind: contractKind,
                    payable: payable
                };
            }
    }
}

exports.definitionToStoredType = definitionToStoredType;