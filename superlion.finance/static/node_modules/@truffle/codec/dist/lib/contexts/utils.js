"use strict";

var _defineProperty = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty");

var _slicedToArray = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray");

var _toConsumableArray = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray");

function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {};
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true,
        didErr = false,
        err;
    return {
        s: function s() {
            it = o[Symbol.iterator]();
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally {
                if (didErr) throw err;
            }
        }
    };
}

function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
    }
    return arr2;
}

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});

var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
        for (var k in mod) {
            if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }

    __setModuleDefault(result, mod);

    return result;
};

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.normalizeContexts = exports.matchContext = exports.findContext = void 0;

var debug_1 = __importDefault(require("debug"));

var debug = debug_1.default("codec:contexts:utils");

var Evm = __importStar(require("../evm"));

var lodash_escaperegexp_1 = __importDefault(require("lodash.escaperegexp"));

var cbor = __importStar(require("cbor"));

function findContext(contexts, binary) {
    var matchingContexts = Object.values(contexts).filter(function(context) {
        return matchContext(context, binary);
    }); //rather than just pick an arbitrary matching context, we're going
    //to pick one that isn't a descendant of any of the others.
    //(if there are multiple of *those*, then yeah it's arbitrary.)

    var context = matchingContexts.find(function(descendant) {
        return !matchingContexts.some(function(ancestor) {
                return descendant.compilationId === ancestor.compilationId && descendant.linearizedBaseContracts && ancestor.contractId !== undefined && descendant.linearizedBaseContracts.slice(1).includes(ancestor.contractId);
            } //we do slice one because everything is an an ancestor of itself; we only
            //care about *proper* ancestors
        );
    });
    return context || null;
}

exports.findContext = findContext;

function matchContext(context, givenBinary) {
    var binary = context.binary,
        isConstructor = context.isConstructor;
    var lengthDifference = givenBinary.length - binary.length; //first: if it's not a constructor, they'd better be equal in length.
    //if it is a constructor, the given binary must be at least as long,
    //and the difference must be a multiple of 64

    if (!isConstructor && lengthDifference !== 0 || lengthDifference < 0 || lengthDifference % (2 * Evm.Utils.WORD_SIZE) !== 0) {
        return false;
    }

    for (var i = 0; i < binary.length; i++) {
        //note: using strings like arrays is kind of dangerous in general in JS,
        //but everything here is ASCII so it's fine
        //note that we need to compare case-insensitive, since Solidity will
        //put addresses in checksum case in the compiled source
        //(we don't actually need that second toLowerCase(), but whatever)
        if (binary[i] !== "." && binary[i].toLowerCase() !== givenBinary[i].toLowerCase()) {
            return false;
        }
    }

    return true;
}

exports.matchContext = matchContext;

function normalizeContexts(contexts) {
    //unfortunately, due to our current link references format, we can't
    //really use the binary from the artifact directly -- neither for purposes
    //of matching, nor for purposes of decoding internal functions.  So, we
    //need to perform this normalization step on our contexts before using
    //them.  Once we have truffle-db, this step should largely go away.
    debug("normalizing contexts"); //first, let's clone the input
    //(let's do a 2-deep clone because we'll be altering binary)

    var newContexts = Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(contexts).map(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            contextHash = _ref2[0],
            context = _ref2[1];

        return _defineProperty({}, contextHash, Object.assign({}, context));
    }))));
    debug("contexts cloned"); //next, we get all the library names and sort them descending by length.
    //We're going to want to go in descending order of length so that we
    //don't run into problems when one name is a substring of another.
    //For simplicity, we'll exclude names of length <38, because we can
    //handle these with our more general check for link references at the end

    var fillerLength = 2 * Evm.Utils.ADDRESS_SIZE;
    var names = Object.values(newContexts).filter(function(context) {
            return context.contractKind === "library";
        }).map(function(context) {
            return context.contractName;
        }).filter(function(name) {
            return name.length >= fillerLength - 3;
        }) //the -3 is for 2 leading underscores and 1 trailing
        .sort(function(name1, name2) {
            return name2.length - name1.length;
        });
    debug("names sorted"); //now, we need to turn all these names into regular expressions, because,
    //unfortunately, str.replace() will only replace all if you use a /g regexp;
    //note that because names may contain '$', we need to escape them
    //(also we prepend "__" because that's the placeholder format)

    var regexps = names.map(function(name) {
        return new RegExp(lodash_escaperegexp_1.default("__" + name), "g");
    });
    debug("regexps prepared"); //having done so, we can do the replace for these names!

    var replacement = ".".repeat(fillerLength);

    var _iterator = _createForOfIteratorHelper(regexps),
        _step;

    try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var regexp = _step.value;

            for (var _i6 = 0, _Object$values6 = Object.values(newContexts); _i6 < _Object$values6.length; _i6++) {
                var _context4 = _Object$values6[_i6];
                _context4.binary = _context4.binary.replace(regexp, replacement);
            }
        }
    } catch (err) {
        _iterator.e(err);
    } finally {
        _iterator.f();
    }

    debug("long replacements complete"); //now we can do a generic replace that will catch all names of length
    //<40, while also catching the Solidity compiler's link reference format
    //as well as Truffle's.  Hooray!

    var genericRegexp = new RegExp("_.{" + (fillerLength - 2) + "}_", "g"); //we're constructing the regexp /_.{38}_/g, but I didn't want to use a
    //literal 38 :P

    for (var _i = 0, _Object$values = Object.values(newContexts); _i < _Object$values.length; _i++) {
        var context = _Object$values[_i];
        context.binary = context.binary.replace(genericRegexp, replacement);
    }

    debug("short replacements complete"); //now we must handle the delegatecall guard -- libraries' deployedBytecode will include
    //0s in place of their own address instead of a link reference at the
    //beginning, so we need to account for that too

    var pushAddressInstruction = (0x60 + Evm.Utils.ADDRESS_SIZE - 1).toString(16); //"73"

    for (var _i2 = 0, _Object$values2 = Object.values(newContexts); _i2 < _Object$values2.length; _i2++) {
        var _context = _Object$values2[_i2];

        if (_context.contractKind === "library" && !_context.isConstructor) {
            _context.binary = _context.binary.replace("0x" + pushAddressInstruction + "00".repeat(Evm.Utils.ADDRESS_SIZE), "0x" + pushAddressInstruction + replacement);
        }
    }

    debug("extra library replacements complete"); //now let's handle immutable references
    //(these are much nicer than link references due to not having to deal with the old format)

    for (var _i3 = 0, _Object$values3 = Object.values(newContexts); _i3 < _Object$values3.length; _i3++) {
        var _context2 = _Object$values3[_i3];

        if (_context2.immutableReferences) {
            for (var _i4 = 0, _Object$values4 = Object.values(_context2.immutableReferences); _i4 < _Object$values4.length; _i4++) {
                var variable = _Object$values4[_i4];

                var _iterator2 = _createForOfIteratorHelper(variable),
                    _step2;

                try {
                    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                        var _step2$value = _step2.value,
                            start = _step2$value.start,
                            length = _step2$value.length;
                        //Goddammit TS
                        var lowerStringIndex = 2 + 2 * start;
                        var upperStringIndex = 2 + 2 * (start + length);
                        _context2.binary = _context2.binary.slice(0, lowerStringIndex) + "..".repeat(length) + _context2.binary.slice(upperStringIndex);
                    }
                } catch (err) {
                    _iterator2.e(err);
                } finally {
                    _iterator2.f();
                }
            }
        }
    }

    debug("immutables complete"); //one last step: where there's CBOR with a metadata hash, we'll allow the
    //CBOR to vary, aside from the length (note: ideally here we would *only*
    //dot-out the metadata hash part of the CBOR, but, well, it's not worth the
    //trouble to detect that; doing that could potentially get pretty involved)
    //note that if the code isn't Solidity, that's fine -- we just won't get
    //valid CBOR and will not end up adding to our list of regular expressions

    var externalCborInfo = Object.values(newContexts).map(function(context) {
        return extractCborInfo(context.binary);
    }).filter(function(cborSegment) {
        return cborSegment !== null && isCborWithHash(cborSegment.cbor);
    });
    var cborRegexps = externalCborInfo.map(function(cborInfo) {
        return {
            input: new RegExp(cborInfo.cborSegment, "g"),
            output: "..".repeat(cborInfo.cborLength) + cborInfo.cborLengthHex
        };
    }); //HACK: we will replace *every* occurrence of *every* external CBOR occurring
    //in *every* context, in order to cover created contracts (including if there
    //are multiple or recursive ones)

    for (var _i5 = 0, _Object$values5 = Object.values(newContexts); _i5 < _Object$values5.length; _i5++) {
        var _context3 = _Object$values5[_i5];

        var _iterator3 = _createForOfIteratorHelper(cborRegexps),
            _step3;

        try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var _step3$value = _step3.value,
                    input = _step3$value.input,
                    output = _step3$value.output;
                _context3.binary = _context3.binary.replace(input, output);
            }
        } catch (err) {
            _iterator3.e(err);
        } finally {
            _iterator3.f();
        }
    }

    debug("external wildcards complete"); //finally, return this mess!

    return newContexts;
}

exports.normalizeContexts = normalizeContexts;

function extractCborInfo(binary) {
    debug("extracting cbor segement of %s", binary);
    var lastTwoBytes = binary.slice(2).slice(-2 * 2); //2 bytes * 2 for hex
    //the slice(2) there may seem unnecessary; it's to handle the possibility that the contract
    //has less than two bytes in its bytecode (that won't happen with Solidity, but let's be
    //certain)

    if (lastTwoBytes.length < 2 * 2) {
        return null; //don't try to handle this case!
    }

    var cborLength = parseInt(lastTwoBytes, 16);
    var cborEnd = binary.length - 2 * 2;
    var cborStart = cborEnd - cborLength * 2; //sanity check

    if (cborStart < 2) {
        //"0x"
        return null; //don't try to handle this case!
    }

    var cbor = binary.slice(cborStart, cborEnd);
    return {
        cborStart: cborStart,
        cborLength: cborLength,
        cborEnd: cborEnd,
        cborLengthHex: lastTwoBytes,
        cbor: cbor,
        cborSegment: cbor + lastTwoBytes
    };
}

function isCborWithHash(encoded) {
    debug("checking cbor, encoed: %s", encoded);
    var decoded;

    try {
        //note this *will* throw if there's data left over,
        //which is what we want it to do
        decoded = cbor.decodeFirstSync(encoded);
    } catch (_a) {
        debug("invalid cbor!");
        return false;
    }

    debug("decoded: %O", decoded);

    if (typeof decoded !== "object") {
        return false;
    } //borc sometimes returns maps and sometimes objects,
    //so let's make things consistent by converting to a map


    if (!(decoded instanceof Map)) {
        decoded = new Map(Object.entries(decoded));
    }

    var hashKeys = ["bzzr0", "bzzr1", "ipfs"];
    return hashKeys.some(function(key) {
        return decoded.has(key);
    });
}