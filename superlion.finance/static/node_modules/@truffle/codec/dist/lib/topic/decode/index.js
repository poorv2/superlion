"use strict";

var _regeneratorRuntime = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator");

var _marked = /*#__PURE__*/ _regeneratorRuntime.mark(decodeTopic);

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});

var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
        for (var k in mod) {
            if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }

    __setModuleDefault(result, mod);

    return result;
};

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.decodeTopic = void 0;

var debug_1 = __importDefault(require("debug"));

var debug = debug_1.default("codec:topic:decode");

var read_1 = __importDefault(require("../../read"));

var Basic = __importStar(require("../../basic"));

var Format = __importStar(require("../../format"));

var Conversion = __importStar(require("../../conversion"));

function decodeTopic(dataType, pointer, info) {
    var options,
        bytes,
        raw,
        _args = arguments;
    return _regeneratorRuntime.wrap(function decodeTopic$(_context) {
        while (1) {
            switch (_context.prev = _context.next) {
                case 0:
                    options = _args.length > 3 && _args[3] !== undefined ? _args[3] : {};

                    if (!(Format.Types.isReferenceType(dataType) || dataType.typeClass === "tuple")) {
                        _context.next = 6;
                        break;
                    }

                    return _context.delegateYield(read_1.default(pointer, info.state), "t0", 3);

                case 3:
                    bytes = _context.t0;
                    raw = Conversion.toHexString(bytes); //NOTE: even in strict mode we want to just return this, not throw an error here

                    return _context.abrupt("return", {
                        //dunno why TS is failing here
                        type: dataType,
                        kind: "error",
                        error: {
                            kind: "IndexedReferenceTypeError",
                            type: dataType,
                            raw: raw
                        }
                    });

                case 6:
                    return _context.delegateYield(Basic.Decode.decodeBasic(dataType, pointer, info, options), "t1", 7);

                case 7:
                    return _context.abrupt("return", _context.t1);

                case 8:
                case "end":
                    return _context.stop();
            }
        }
    }, _marked);
}

exports.decodeTopic = decodeTopic;