"use strict";

function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {};
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true,
        didErr = false,
        err;
    return {
        s: function s() {
            it = o[Symbol.iterator]();
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally {
                if (didErr) throw err;
            }
        }
    };
}

function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
    }
    return arr2;
}

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});

var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
        for (var k in mod) {
            if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }

    __setModuleDefault(result, mod);

    return result;
};

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isSkippedInMemoryStructs = exports.getMemoryAllocations = void 0;

var debug_1 = __importDefault(require("debug"));

var debug = debug_1.default("codec:memory:allocate");

var Evm = __importStar(require("../../evm"));

function getMemoryAllocations(userDefinedTypes) {
    var allocations = {};

    for (var _i = 0, _Object$values = Object.values(userDefinedTypes); _i < _Object$values.length; _i++) {
        var dataType = _Object$values[_i];

        if (dataType.typeClass === "struct") {
            allocations[dataType.id] = allocateStruct(dataType);
        }
    }

    return allocations;
}

exports.getMemoryAllocations = getMemoryAllocations;

function isSkippedInMemoryStructs(dataType) {
    if (dataType.typeClass === "mapping") {
        return true;
    } else if (dataType.typeClass === "array") {
        return isSkippedInMemoryStructs(dataType.baseType);
    } else {
        return false;
    }
}

exports.isSkippedInMemoryStructs = isSkippedInMemoryStructs; //unlike in storage and calldata, we'll just return the one allocation, nothing fancy
//that's because allocating one struct can never necessitate allocating another

function allocateStruct(dataType) {
    var memberAllocations = [];
    var position = 0;

    var _iterator = _createForOfIteratorHelper(dataType.memberTypes),
        _step;

    try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _step$value = _step.value,
                name = _step$value.name,
                memberType = _step$value.type;
            var length = isSkippedInMemoryStructs(memberType) ? 0 : Evm.Utils.WORD_SIZE;
            memberAllocations.push({
                name: name,
                type: memberType,
                pointer: {
                    location: "memory",
                    start: position,
                    length: length
                }
            });
            position += length;
        }
    } catch (err) {
        _iterator.e(err);
    } finally {
        _iterator.f();
    }

    return {
        members: memberAllocations
    };
}