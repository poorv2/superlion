"use strict";

var _toConsumableArray = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray");

var _regeneratorRuntime = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator");

var _marked = /*#__PURE__*/ _regeneratorRuntime.mark(decodeMemory),
    _marked2 = /*#__PURE__*/ _regeneratorRuntime.mark(decodeMemoryReferenceByAddress);

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});

var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
        for (var k in mod) {
            if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }

    __setModuleDefault(result, mod);

    return result;
};

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.decodeMemoryReferenceByAddress = exports.decodeMemory = void 0;

var debug_1 = __importDefault(require("debug"));

var debug = debug_1.default("codec:memory:decode");

var read_1 = __importDefault(require("../../read"));

var Conversion = __importStar(require("../../conversion"));

var Format = __importStar(require("../../format"));

var Basic = __importStar(require("../../basic"));

var Bytes = __importStar(require("../../bytes"));

var Evm = __importStar(require("../../evm"));

var allocate_1 = require("../allocate");

var errors_1 = require("../../errors");

function decodeMemory(dataType, pointer, info) {
    var options,
        _args = arguments;
    return _regeneratorRuntime.wrap(function decodeMemory$(_context) {
        while (1) {
            switch (_context.prev = _context.next) {
                case 0:
                    options = _args.length > 3 && _args[3] !== undefined ? _args[3] : {};

                    if (!Format.Types.isReferenceType(dataType)) {
                        _context.next = 10;
                        break;
                    }

                    if (!allocate_1.isSkippedInMemoryStructs(dataType)) {
                        _context.next = 6;
                        break;
                    }

                    return _context.abrupt("return", decodeMemorySkippedType(dataType));

                case 6:
                    return _context.delegateYield(decodeMemoryReferenceByAddress(dataType, pointer, info, options), "t0", 7);

                case 7:
                    return _context.abrupt("return", _context.t0);

                case 8:
                    _context.next = 12;
                    break;

                case 10:
                    return _context.delegateYield(Basic.Decode.decodeBasic(dataType, pointer, info, options), "t1", 11);

                case 11:
                    return _context.abrupt("return", _context.t1);

                case 12:
                case "end":
                    return _context.stop();
            }
        }
    }, _marked);
}

exports.decodeMemory = decodeMemory;

function decodeMemorySkippedType(dataType) {
    switch (dataType.typeClass) {
        case "mapping":
            return {
                type: dataType,
                kind: "value",
                value: []
            };

        case "array":
            return {
                type: dataType,
                kind: "value",
                value: []
            };
            //other cases should not arise!
    }
}

function decodeMemoryReferenceByAddress(dataType, pointer, info) {
    var options,
        state,
        memoryVisited,
        rawValue,
        startPositionAsBN,
        startPosition,
        objectPosition,
        rawLength,
        lengthAsBN,
        length,
        seenPreviously,
        childPointer,
        memoryNowVisited,
        baseType,
        decodedChildren,
        index,
        allocations,
        typeId,
        structAllocation,
        _memoryNowVisited,
        decodedMembers,
        _index,
        memberAllocation,
        memberPointer,
        _childPointer,
        memberName,
        memberType,
        _args2 = arguments;

    return _regeneratorRuntime.wrap(function decodeMemoryReferenceByAddress$(_context2) {
        while (1) {
            switch (_context2.prev = _context2.next) {
                case 0:
                    options = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : {};
                    state = info.state;
                    memoryVisited = options.memoryVisited || [];
                    debug("pointer %o", pointer);
                    _context2.prev = 4;
                    return _context2.delegateYield(read_1.default(pointer, state), "t0", 6);

                case 6:
                    rawValue = _context2.t0;
                    _context2.next = 12;
                    break;

                case 9:
                    _context2.prev = 9;
                    _context2.t1 = _context2["catch"](4);
                    return _context2.abrupt("return", errors_1.handleDecodingError(dataType, _context2.t1));

                case 12:
                    startPositionAsBN = Conversion.toBN(rawValue);
                    _context2.prev = 13;
                    startPosition = startPositionAsBN.toNumber();
                    _context2.next = 20;
                    break;

                case 17:
                    _context2.prev = 17;
                    _context2.t2 = _context2["catch"](13);
                    return _context2.abrupt("return", {
                        //again with the TS failures...
                        type: dataType,
                        kind: "error",
                        error: {
                            kind: "OverlargePointersNotImplementedError",
                            pointerAsBN: startPositionAsBN
                        }
                    });

                case 20:
                    //startPosition may get modified later, so let's save the current
                    //value for circularity detection purposes
                    objectPosition = startPosition;
                    _context2.t3 = dataType.typeClass;
                    _context2.next = _context2.t3 === "bytes" ? 24 : _context2.t3 === "string" ? 24 : _context2.t3 === "array" ? 43 : _context2.t3 === "struct" ? 80 : 108;
                    break;

                case 24:
                    _context2.prev = 24;
                    return _context2.delegateYield(read_1.default({
                        location: "memory",
                        start: startPosition,
                        length: Evm.Utils.WORD_SIZE
                    }, state), "t4", 26);

                case 26:
                    rawLength = _context2.t4;
                    _context2.next = 32;
                    break;

                case 29:
                    _context2.prev = 29;
                    _context2.t5 = _context2["catch"](24);
                    return _context2.abrupt("return", errors_1.handleDecodingError(dataType, _context2.t5));

                case 32:
                    lengthAsBN = Conversion.toBN(rawLength);
                    _context2.prev = 33;
                    length = lengthAsBN.toNumber();
                    _context2.next = 40;
                    break;

                case 37:
                    _context2.prev = 37;
                    _context2.t6 = _context2["catch"](33);
                    return _context2.abrupt("return", {
                        //again with the TS failures...
                        type: dataType,
                        kind: "error",
                        error: {
                            kind: "OverlongArraysAndStringsNotImplementedError",
                            lengthAsBN: lengthAsBN
                        }
                    });

                case 40:
                    childPointer = {
                        location: "memory",
                        start: startPosition + Evm.Utils.WORD_SIZE,
                        length: length
                    };
                    return _context2.delegateYield(Bytes.Decode.decodeBytes(dataType, childPointer, info), "t7", 42);

                case 42:
                    return _context2.abrupt("return", _context2.t7);

                case 43:
                    //first: circularity check!
                    seenPreviously = memoryVisited.indexOf(objectPosition);

                    if (!(seenPreviously !== -1)) {
                        _context2.next = 46;
                        break;
                    }

                    return _context2.abrupt("return", {
                        type: dataType,
                        kind: "value",
                        reference: seenPreviously + 1,
                        value: [] //will be fixed later by the tie function

                    });

                case 46:
                    if (!(dataType.kind === "dynamic")) {
                        _context2.next = 59;
                        break;
                    }

                    _context2.prev = 47;
                    return _context2.delegateYield(read_1.default({
                        location: "memory",
                        start: startPosition,
                        length: Evm.Utils.WORD_SIZE
                    }, state), "t8", 49);

                case 49:
                    rawLength = _context2.t8;
                    _context2.next = 55;
                    break;

                case 52:
                    _context2.prev = 52;
                    _context2.t9 = _context2["catch"](47);
                    return _context2.abrupt("return", errors_1.handleDecodingError(dataType, _context2.t9));

                case 55:
                    lengthAsBN = Conversion.toBN(rawLength);
                    startPosition += Evm.Utils.WORD_SIZE; //increment startPosition
                    //to next word, as first word was used for length

                    _context2.next = 60;
                    break;

                case 59:
                    lengthAsBN = dataType.length;

                case 60:
                    _context2.prev = 60;
                    length = lengthAsBN.toNumber();
                    _context2.next = 67;
                    break;

                case 64:
                    _context2.prev = 64;
                    _context2.t10 = _context2["catch"](60);
                    return _context2.abrupt("return", {
                        type: dataType,
                        kind: "error",
                        error: {
                            kind: "OverlongArraysAndStringsNotImplementedError",
                            lengthAsBN: lengthAsBN
                        }
                    });

                case 67:
                    memoryNowVisited = [objectPosition].concat(_toConsumableArray(memoryVisited));
                    baseType = dataType.baseType;
                    decodedChildren = [];
                    index = 0;

                case 71:
                    if (!(index < length)) {
                        _context2.next = 79;
                        break;
                    }

                    _context2.t11 = decodedChildren;
                    return _context2.delegateYield(decodeMemory(baseType, {
                        location: "memory",
                        start: startPosition + index * Evm.Utils.WORD_SIZE,
                        length: Evm.Utils.WORD_SIZE
                    }, info, {
                        memoryVisited: memoryNowVisited
                    }), "t12", 74);

                case 74:
                    _context2.t13 = _context2.t12;

                    _context2.t11.push.call(_context2.t11, _context2.t13);

                case 76:
                    index++;
                    _context2.next = 71;
                    break;

                case 79:
                    return _context2.abrupt("return", {
                        type: dataType,
                        kind: "value",
                        value: decodedChildren
                    });

                case 80:
                    //first: circularity check!
                    seenPreviously = memoryVisited.indexOf(objectPosition);

                    if (!(seenPreviously !== -1)) {
                        _context2.next = 83;
                        break;
                    }

                    return _context2.abrupt("return", {
                        type: dataType,
                        kind: "value",
                        reference: seenPreviously + 1,
                        value: [] //will be fixed later by the tie function

                    });

                case 83:
                    //otherwise, decode as normal
                    allocations = info.allocations.memory;
                    typeId = dataType.id;
                    structAllocation = allocations[typeId];

                    if (structAllocation) {
                        _context2.next = 88;
                        break;
                    }

                    return _context2.abrupt("return", {
                        type: dataType,
                        kind: "error",
                        error: {
                            kind: "UserDefinedTypeNotFoundError",
                            type: dataType
                        }
                    });

                case 88:
                    debug("structAllocation %O", structAllocation);
                    _memoryNowVisited = [objectPosition].concat(_toConsumableArray(memoryVisited));
                    decodedMembers = [];
                    _index = 0;

                case 92:
                    if (!(_index < structAllocation.members.length)) {
                        _context2.next = 107;
                        break;
                    }

                    memberAllocation = structAllocation.members[_index];
                    memberPointer = memberAllocation.pointer;
                    _childPointer = {
                        location: "memory",
                        start: startPosition + memberPointer.start,
                        length: memberPointer.length //always equals WORD_SIZE or 0

                    };
                    memberName = memberAllocation.name;
                    memberType = Format.Types.specifyLocation(memberAllocation.type, "memory");
                    _context2.t14 = decodedMembers;
                    _context2.t15 = memberName;
                    return _context2.delegateYield(decodeMemory(memberType, _childPointer, info, {
                        memoryVisited: _memoryNowVisited
                    }), "t16", 101);

                case 101:
                    _context2.t17 = _context2.t16;
                    _context2.t18 = {
                        name: _context2.t15,
                        value: _context2.t17
                    };

                    _context2.t14.push.call(_context2.t14, _context2.t18);

                case 104:
                    _index++;
                    _context2.next = 92;
                    break;

                case 107:
                    return _context2.abrupt("return", {
                        type: dataType,
                        kind: "value",
                        value: decodedMembers
                    });

                case 108:
                case "end":
                    return _context2.stop();
            }
        }
    }, _marked2, null, [
        [4, 9],
        [13, 17],
        [24, 29],
        [33, 37],
        [47, 52],
        [60, 64]
    ]);
}

exports.decodeMemoryReferenceByAddress = decodeMemoryReferenceByAddress;