var _regeneratorRuntime = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator");

var _asyncToGenerator = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator");

var debug = require("debug")("contract:utils");

var web3Utils = require("web3-utils");

var _require = require("ethers/utils/bignumber"),
    bigNumberify = _require.bigNumberify;

var abi = require("web3-eth-abi");

var BlockchainUtils = require("@truffle/blockchain-utils");

var reformat = require("../reformat");

var ens = require("./ens");

var allowedTxParams = new Set(["from", "to", "gas", "gasPrice", "value", "data", "nonce", "privateFor", "overwrite"]);
var Utils = {
    is_object: function is_object(val) {
        return typeof val === "object" && !Array.isArray(val);
    },
    is_big_number: function is_big_number(val) {
        if (typeof val !== "object") return false; //NOTE: For some reason, contrary to the docs,
        //web3Utils.isBigNumber returns true not only for
        //bignumber.js BigNumbers, but also for ethers BigNumbers,
        //even though these are totally different things.

        return web3Utils.isBN(val) || web3Utils.isBigNumber(val);
    },
    isTxParams: function isTxParams(val) {
        if (!Utils.is_object(val)) return false;
        if (Utils.is_big_number(val)) return false;
        return Object.keys(val).some(function(fieldName) {
            return allowedTxParams.has(fieldName);
        });
    },
    decodeLogs: function decodeLogs(_logs, isSingle) {
        var constructor = this;
        var logs = Utils.toTruffleLog(_logs, isSingle);
        return logs.map(function(log) {
            var logABI = constructor.events[log.topics[0]];
            if (logABI == null) return null;
            var copy = Utils.merge({}, log);
            copy.event = logABI.name;
            copy.topics = logABI.anonymous ? copy.topics : copy.topics.slice(1);
            if (copy.data === "0x") copy.data = "";
            var logArgs;

            try {
                logArgs = abi.decodeLog(logABI.inputs, copy.data, copy.topics);
                copy.args = reformat.numbers.call(constructor, logArgs, logABI.inputs);
            } catch (_) {
                return null;
            }

            delete copy.data;
            delete copy.topics;
            return copy;
        }).filter(function(log) {
            return log != null;
        });
    },
    toTruffleLog: function toTruffleLog(events, isSingle) {
        // Transform singletons (from event listeners) to the kind of
        // object we find on the receipt
        if (isSingle && typeof isSingle === "boolean") {
            var temp = [];
            temp.push(events);
            return temp.map(function(log) {
                log.data = log.raw.data;
                log.topics = log.raw.topics;
                return log;
            });
        } // Or reformat items in the existing array


        events.forEach(function(event) {
            if (event.raw) {
                event.data = event.raw.data;
                event.topics = event.raw.topics;
            }
        });
        return events;
    },
    merge: function merge() {
        var merged = {};
        var args = Array.prototype.slice.call(arguments);

        for (var i = 0; i < args.length; i++) {
            var object = args[i];
            var keys = Object.keys(object);

            for (var j = 0; j < keys.length; j++) {
                var key = keys[j];
                var value = object[key];
                merged[key] = value;
            }
        }

        return merged;
    },
    linkBytecode: function linkBytecode(bytecode, links) {
        Object.keys(links).forEach(function(library_name) {
            var library_address = links[library_name];
            var regex = new RegExp("__".concat(library_name, "_+"), "g");
            bytecode = bytecode.replace(regex, library_address.replace("0x", ""));
        });
        return bytecode;
    },
    // Extracts optional tx params from a list of fn arguments
    getTxParams: function getTxParams(methodABI, args) {
        var constructor = this;
        var expectedArgCount = methodABI ? methodABI.inputs.length : 0;
        var tx_params = {};
        var lastArg = args[args.length - 1];

        if (args.length === expectedArgCount + 1 && Utils.isTxParams(lastArg)) {
            tx_params = args.pop();
        }

        return Utils.merge(constructor.class_defaults, tx_params);
    },
    // Verifies that a contracts libraries have been linked correctly.
    // Throws on error
    checkLibraries: function checkLibraries() {
        var constructor = this;
        var regex = /__[^_]+_+/g;
        var unlinkedLibraries = constructor.binary.match(regex);

        if (unlinkedLibraries !== null) {
            unlinkedLibraries = unlinkedLibraries.map(function(name // Remove underscores
            ) {
                return name.replace(/_/g, "");
            }).sort().filter(function(name, index, arr) {
                // Remove duplicates
                if (index + 1 >= arr.length) {
                    return true;
                }

                return name !== arr[index + 1];
            }).join(", ");
            var error = "".concat(constructor.contractName, " contains unresolved libraries. You must deploy and link the following libraries before you can deploy a new version of ").concat(constructor.contractName, ": ").concat(unlinkedLibraries);
            throw new Error(error);
        }
    },
    convertToEthersBN: function convertToEthersBN(original) {
        var converted = [];
        original.forEach(function(item) {
            // Recurse for arrays
            if (Array.isArray(item)) {
                converted.push(Utils.convertToEthersBN(item)); // Convert Web3 BN / BigNumber
            } else if (Utils.is_big_number(item)) {
                //HACK: Since we can't rely on web3Utils.isBigNumber to tell
                //whether we have a bignumber.js BigNumber, we'll just check
                //whether it has the toFixed method
                var stringValue = item.toFixed ? item.toFixed() //prevents use of scientific notation
                    :
                    item.toString();
                var ethersBN = bigNumberify(stringValue);
                converted.push(ethersBN);
            } else {
                converted.push(item);
            }
        });
        return converted;
    },

    /**
     * Multiplies an ethers.js BigNumber and a number with decimal places using
     * integer math rather than using an arbitrary floating-point library like
     * `bignumber.js`.
     * @param  {BigNumber} bignum            an ethers.js BigNumber (use bigNumberify)
     * @param  {Number}    decimal           a number which has 0+ decimal places
     * @param  {Number}    [maxPrecision=5]  the max number of signficant figures
     *                                       `decimal` can have. (default: 5)
     * @return {BigNumber}                   floor(bignum * decimal)
     */
    multiplyBigNumberByDecimal: function multiplyBigNumberByDecimal(bignum, decimal, maxPrecision) {
        if (typeof maxPrecision === "undefined") {
            maxPrecision = 5;
        }

        var significantFigures = Math.min(decimal.toString().length - 1, // length less one because `.`
            maxPrecision);
        var denominator = bigNumberify(10).pow(significantFigures);
        var multiplier = Math.round(decimal * denominator);
        var numerator = bigNumberify(multiplier).mul(bignum);
        return numerator.div(denominator);
    },
    // checks if given contract instance has a set provider
    checkProvider: function checkProvider(_ref) {
        var currentProvider = _ref.currentProvider,
            contractName = _ref.contractName;
        if (!currentProvider) throw new Error("".concat(contractName, " error: Please call setProvider() first before calling new()."));
    },
    // verifies current network has been assigned to contract instance
    checkNetworkArtifactMatch: function checkNetworkArtifactMatch(_ref2) {
        var networks = _ref2.networks,
            network_id = _ref2.network_id,
            contractName = _ref2.contractName;
        if (networks[network_id] == null) throw new Error("".concat(contractName, " has not been deployed to detected network (network/artifact mismatch)"));
    },
    // verifies contract instance has been deployed
    checkDeployment: function checkDeployment(_ref3) {
        var isDeployed = _ref3.isDeployed,
            contractName = _ref3.contractName,
            network_id = _ref3.network_id;
        if (!isDeployed()) throw new Error("".concat(contractName, " has not been deployed to detected network (").concat(network_id, ")"));
    },
    // checks if provided contract address has on-chain code
    checkCode: function checkCode(onChainCode, contractName, address) {
        if (!onChainCode || onChainCode.replace("0x", "").replace(/0/g, "") === "") throw new Error("Cannot create instance of ".concat(contractName, "; no code at address ").concat(address));
    },
    // parses known contract instance networks
    parseKnownNetworks: function() {
        var _parseKnownNetworks = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee(_ref4, gasLimit) {
            var networks, currentProvider, setNetwork, network_id, network, networkMatches;
            return _regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                    switch (_context.prev = _context.next) {
                        case 0:
                            networks = _ref4.networks, currentProvider = _ref4.currentProvider, setNetwork = _ref4.setNetwork, network_id = _ref4.network_id;

                            if (!(!networks && Object.keys(networks).length === 0)) {
                                _context.next = 3;
                                break;
                            }

                            return _context.abrupt("return", false);

                        case 3:
                            _context.t0 = _regeneratorRuntime.keys(networks);

                        case 4:
                            if ((_context.t1 = _context.t0()).done) {
                                _context.next = 15;
                                break;
                            }

                            network = _context.t1.value;

                            if (!network.startsWith("blockchain://")) {
                                _context.next = 13;
                                break;
                            }

                            _context.next = 9;
                            return BlockchainUtils.matches(network, currentProvider);

                        case 9:
                            networkMatches = _context.sent;

                            if (!networkMatches) {
                                _context.next = 13;
                                break;
                            }

                            setNetwork(network);
                            return _context.abrupt("return", {
                                id: network_id,
                                blockLimit: gasLimit
                            });

                        case 13:
                            _context.next = 4;
                            break;

                        case 15:
                            return _context.abrupt("return", false);

                        case 16:
                        case "end":
                            return _context.stop();
                    }
                }
            }, _callee);
        }));

        function parseKnownNetworks(_x, _x2) {
            return _parseKnownNetworks.apply(this, arguments);
        }

        return parseKnownNetworks;
    }(),
    // sets a contract instance network ID
    setInstanceNetworkID: function() {
        var _setInstanceNetworkID = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee2(TruffleContractInstance, chainNetworkID, gasLimit) {
            var matchedNetwork;
            return _regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                    switch (_context2.prev = _context2.next) {
                        case 0:
                            if (!TruffleContractInstance.hasNetwork(chainNetworkID)) {
                                _context2.next = 3;
                                break;
                            }

                            TruffleContractInstance.setNetwork(chainNetworkID);
                            return _context2.abrupt("return", {
                                id: TruffleContractInstance.network_id,
                                blockLimit: gasLimit
                            });

                        case 3:
                            _context2.next = 5;
                            return Utils.parseKnownNetworks(TruffleContractInstance, gasLimit);

                        case 5:
                            matchedNetwork = _context2.sent;

                            if (!matchedNetwork) {
                                _context2.next = 8;
                                break;
                            }

                            return _context2.abrupt("return", matchedNetwork);

                        case 8:
                            // network unknown, trust the provider and use given chainNetworkID
                            TruffleContractInstance.setNetwork(chainNetworkID);
                            return _context2.abrupt("return", {
                                id: TruffleContractInstance.network_id,
                                blockLimit: gasLimit
                            });

                        case 10:
                        case "end":
                            return _context2.stop();
                    }
                }
            }, _callee2);
        }));

        function setInstanceNetworkID(_x3, _x4, _x5) {
            return _setInstanceNetworkID.apply(this, arguments);
        }

        return setInstanceNetworkID;
    }()
};
Utils.ens = ens;
Utils.bigNumberify = bigNumberify;
module.exports = Utils;