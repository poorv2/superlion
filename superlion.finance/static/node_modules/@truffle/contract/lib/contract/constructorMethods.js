var _regeneratorRuntime = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator");

var _asyncToGenerator = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator");

var _require = require("@truffle/interface-adapter"),
    Web3Shim = _require.Web3Shim,
    createInterfaceAdapter = _require.createInterfaceAdapter;

var utils = require("../utils");

var execute = require("../execute");

var bootstrap = require("./bootstrap");

var debug = require("debug")("contract:contract:constructorMethods");

var OS = require("os");

module.exports = function(Contract) {
    return {
        configureNetwork: function configureNetwork() {
            var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                networkType = _ref.networkType,
                provider = _ref.provider;

            // otherwise use existing value as default (at most one of these)
            networkType = networkType || this.networkType;
            provider = provider || this.currentProvider; // recreate interfaceadapter

            this.interfaceAdapter = createInterfaceAdapter({
                networkType: networkType,
                provider: provider
            });

            if (this.web3) {
                // update existing
                this.web3.setNetworkType(networkType);
                this.web3.setProvider(provider);
            } else {
                // create new
                this.web3 = new Web3Shim({
                    networkType: networkType,
                    provider: provider
                });
            } // save properties


            this.currentProvider = provider;
            this.networkType = networkType; //invalidate cached chain ID

            this._chainId = undefined;
        },
        setProvider: function setProvider(provider) {
            if (!provider) {
                throw new Error("Invalid provider passed to setProvider(); provider is ".concat(provider));
            }

            this.configureNetwork({
                provider: provider
            });
        },
        new: function _new() {
            utils.checkProvider(this);

            if (!this.bytecode || this.bytecode === "0x") {
                throw new Error("".concat(this.contractName, " error: contract binary not set. Can't deploy new instance.\n") + "This contract may be abstract, not implement an abstract parent's methods completely\n" + "or not invoke an inherited contract's constructor correctly\n");
            }

            var constructorABI = this.abi.filter(function(i) {
                return i.type === "constructor";
            })[0];
            return execute.deploy.call(this, constructorABI).apply(void 0, arguments);
        },
        at: function() {
            var _at = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee(address) {
                var onChainCode;
                return _regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                if (!(address == null || typeof address !== "string" || address.length !== 42)) {
                                    _context.next = 2;
                                    break;
                                }

                                throw new Error("Invalid address passed to ".concat(this.contractName, ".at(): ").concat(address));

                            case 2:
                                _context.next = 4;
                                return this.detectNetwork();

                            case 4:
                                _context.next = 6;
                                return this.interfaceAdapter.getCode(address);

                            case 6:
                                onChainCode = _context.sent;
                                _context.next = 9;
                                return utils.checkCode(onChainCode, this.contractName, address);

                            case 9:
                                return _context.abrupt("return", new this(address));

                            case 10:
                            case "end":
                                return _context.stop();
                        }
                    }
                }, _callee, this);
            }));

            function at(_x) {
                return _at.apply(this, arguments);
            }

            return at;
        }(),
        deployed: function() {
            var _deployed = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee2() {
                return _regeneratorRuntime.wrap(function _callee2$(_context2) {
                    while (1) {
                        switch (_context2.prev = _context2.next) {
                            case 0:
                                if (this.reloadJson) {
                                    this.reloadJson(); //truffle test monkey-patches in this method
                                }

                                utils.checkProvider(this);
                                _context2.next = 4;
                                return this.detectNetwork();

                            case 4:
                                utils.checkNetworkArtifactMatch(this);
                                utils.checkDeployment(this);
                                return _context2.abrupt("return", new this(this.address));

                            case 7:
                            case "end":
                                return _context2.stop();
                        }
                    }
                }, _callee2, this);
            }));

            function deployed() {
                return _deployed.apply(this, arguments);
            }

            return deployed;
        }(),
        defaults: function defaults(class_defaults) {
            var _this = this;

            if (this.class_defaults == null) {
                this.class_defaults = {};
            }

            if (class_defaults == null) {
                class_defaults = {};
            }

            Object.keys(class_defaults).forEach(function(key) {
                var value = class_defaults[key];
                _this.class_defaults[key] = value;
            });
            return this.class_defaults;
        },
        hasNetwork: function hasNetwork(network_id) {
            return this._json.networks["".concat(network_id)] != null;
        },
        isDeployed: function isDeployed() {
            if (this.network_id == null) {
                return false;
            }

            if (this._json.networks[this.network_id] == null) {
                return false;
            }

            return !!this.network.address;
        },
        detectNetwork: function() {
            var _detectNetwork = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee3() {
                var _yield$this$interface, _gasLimit, chainNetworkID, _yield$this$interface2, gasLimit;

                return _regeneratorRuntime.wrap(function _callee3$(_context3) {
                    while (1) {
                        switch (_context3.prev = _context3.next) {
                            case 0:
                                if (!(this.network_id && this.networks[this.network_id] != null)) {
                                    _context3.next = 6;
                                    break;
                                }

                                _context3.next = 3;
                                return this.interfaceAdapter.getBlock("latest");

                            case 3:
                                _yield$this$interface = _context3.sent;
                                _gasLimit = _yield$this$interface.gasLimit;
                                return _context3.abrupt("return", {
                                    id: this.network_id,
                                    blockLimit: _gasLimit
                                });

                            case 6:
                                _context3.next = 8;
                                return this.interfaceAdapter.getNetworkId();

                            case 8:
                                chainNetworkID = _context3.sent;
                                _context3.next = 11;
                                return this.interfaceAdapter.getBlock("latest");

                            case 11:
                                _yield$this$interface2 = _context3.sent;
                                gasLimit = _yield$this$interface2.gasLimit;
                                _context3.next = 15;
                                return utils.setInstanceNetworkID(this, chainNetworkID, gasLimit);

                            case 15:
                                return _context3.abrupt("return", _context3.sent);

                            case 16:
                            case "end":
                                return _context3.stop();
                        }
                    }
                }, _callee3, this);
            }));

            function detectNetwork() {
                return _detectNetwork.apply(this, arguments);
            }

            return detectNetwork;
        }(),
        setNetwork: function setNetwork(network_id) {
            if (!network_id) return;
            this.network_id = "".concat(network_id);
        },
        setNetworkType: function setNetworkType() {
            var networkType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "ethereum";
            this.configureNetwork({
                networkType: networkType
            });
        },
        setWallet: function setWallet(wallet) {
            this.configureNetwork();
            this.web3.eth.accounts.wallet = wallet;
        },
        // Overrides the deployed address to null.
        // You must call this explicitly so you don't inadvertently do this otherwise.
        resetAddress: function resetAddress() {
            delete this.network.address;
        },
        // accepts 4 input formats
        //  - (<name>, <address>)
        //  - (<contractType>) - must have a deployed instance with an address
        //  - (<contractInstance>)
        //  - ({ <libName>: <address>, <libName2>: <address2>, ... })
        link: function link(name, address) {
            var _this2 = this;

            switch (typeof name) {
                case "string":
                    // Case: Contract.link(<libraryName>, <address>)
                    if (this._json.networks[this.network_id] == null) {
                        this._json.networks[this.network_id] = {
                            events: {},
                            links: {}
                        };
                    }

                    this.network.links[name] = address;
                    return;

                case "function":
                    // Case: Contract.link(<contractType>)
                    var contract = name;

                    if (contract.isDeployed() === false) {
                        throw new Error("Cannot link contract without an address.");
                    }

                    this.link(contract.contractName, contract.address); // Merge events so this contract knows about library's events

                    Object.keys(contract.events).forEach(function(topic) {
                        _this2.network.events[topic] = contract.events[topic];
                    });
                    return;

                case "object":
                    // 2 Cases:
                    //   - Contract.link({<libraryName>: <address>, ... })
                    //   - Contract.link(<instance>)
                    var obj = name;

                    if (obj.constructor && typeof obj.constructor.contractName === "string" && obj.address) {
                        // obj is a Truffle contract instance
                        this.link(obj.constructor.contractName, obj.address);
                    } else {
                        // obj is of the form { <libraryName>: <address>, ... }
                        Object.keys(obj).forEach(function(name) {
                            return _this2.link(name, obj[name]);
                        });
                    }

                    return;

                default:
                    var invalidInput = "Input to the link method is in the incorrect" + " format. Input must be one of the following:".concat(OS.EOL) + "    - a library name and address                 > (\"MyLibrary\", " + "\"0x123456789...\")".concat(OS.EOL) + "    - a contract type                            > " + "(MyContract)".concat(OS.EOL) + "    - a contract instance                        > " + "(myContract)".concat(OS.EOL) + "    - an object with library names and addresses > ({ <libName>: " + "<address>, <libName2>: <address2>, ... })".concat(OS.EOL);
                    throw new Error(invalidInput);
            }
        },
        // Note, this function can be called with two input types:
        // 1. Object with a bunch of data; this data will be merged with the json data of contract being cloned.
        // 2. network id; this will clone the contract and set a specific network id upon cloning.
        clone: function clone(json) {
            json = json || {};

            var temp = function TruffleContract() {
                this.constructor = temp;
                return Contract.apply(this, arguments);
            };

            temp.prototype = Object.create(this.prototype);
            var network_id; // If we have a network id passed

            if (typeof json !== "object") {
                network_id = json;
                json = this._json;
            }

            json = utils.merge({}, this._json || {}, json);
            temp._constructorMethods = this._constructorMethods;
            temp._properties = this._properties;
            temp._property_values = {};
            temp._json = json;
            bootstrap(temp);
            temp.class_defaults = temp.prototype.defaults || {};

            if (network_id) {
                temp.setNetwork(network_id);
            }

            if (this.currentProvider) {
                temp.configureNetwork({
                    provider: this.currentProvider,
                    networkType: this.networkType
                });
            } // Copy over custom key/values to the contract class


            Object.keys(json).forEach(function(key) {
                if (key.indexOf("x-") !== 0) return;
                temp[key] = json[key];
            });
            return temp;
        },
        addProp: function addProp(key, fn) {
            var _this3 = this;

            var getter = function getter() {
                if (fn.get != null) {
                    return fn.get.call(_this3);
                }

                return _this3._property_values[key] || fn.call(_this3);
            };

            var setter = function setter(val) {
                if (fn.set != null) {
                    fn.set.call(_this3, val);
                    return;
                } // If there's not a setter, then the property is immutable.


                throw new Error("".concat(key, " property is immutable"));
            };

            var definition = {};
            definition.enumerable = false;
            definition.configurable = false;
            definition.get = getter;
            definition.set = setter;
            Object.defineProperty(this, key, definition);
        },
        toJSON: function toJSON() {
            return this._json;
        },
        decodeLogs: utils.decodeLogs
    };
};