var _regeneratorRuntime = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator");

var _asyncToGenerator = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator");

var debug = require("debug")("contract:handlers");

var StatusError = require("./statuserror");

var Utils = require("./utils");

var Reason = require("./reason");
/*
  Handlers for events emitted by `send` / `call` etc.
 */


var handlers = {
    // ----------------------------------- Constants -------------------------------------------------
    maxConfirmations: 24,
    // Maximum number of confirmation web3 emits
    defaultTimeoutBlocks: 50,
    // Maximum number of blocks web3 will wait before abandoning tx
    timeoutMessage: "50 blocks",
    // Substring of web3 timeout error.
    defaultWeb3Error: "please check your gas limit",
    // Substring of default Web3 error
    // -----------------------------------  Helpers --------------------------------------------------

    /**
     * Parses error message and determines if we should squash web3 timeout errors at user's request.
     * @param  {Object} contract contract instance
     * @param  {Object} message  error message
     * @return {Boolean}
     */
    ignoreTimeoutError: function ignoreTimeoutError(_ref, _ref2) {
        var contract = _ref.contract;
        var message = _ref2.message;
        var timedOut = message && message.includes(handlers.timeoutMessage);
        var shouldWait = contract && contract.timeoutBlocks && contract.timeoutBlocks > handlers.defaultTimeoutBlocks;
        var waitForTxPropagation = message && message.includes(handlers.defaultWeb3Error);
        return shouldWait && (timedOut || waitForTxPropagation);
    },

    /**
     * Attaches Truffle specific handlers to all of the events emitted by a web3 method.
     * @param {Object}       context  execution state
     * @param {PromiEvent}   emitter  promiEvent returned by a web3 method call
     */
    setup: function setup(emitter, context) {
        emitter.on("error", handlers.error.bind(emitter, context));
        emitter.on("transactionHash", handlers.hash.bind(emitter, context)); // web3 block polls if the confirmation listener is enabled so we want to
        // give users a way of opting out of this behavior - it causes problems in testing

        if (!context.contract.disableConfirmationListener) {
            emitter.on("confirmation", handlers.confirmation.bind(emitter, context));
        }

        emitter.on("receipt", handlers.receipt.bind(emitter, context));
    },
    // -----------------------------------  Handlers -------------------------------------------------

    /**
     * Error event handler. Emits error unless error is block timeout and user has
     * specified we should wait longer
     * @param  {Object} context   execution state
     * @param  {Object} error     error
     */
    error: function error(context, _error) {
        if (!handlers.ignoreTimeoutError(context, _error)) {
            context.promiEvent.eventEmitter.emit("error", _error);
            this.removeListener("error", handlers.error);
        }
    },

    /**
     * Transaction hash event handler. Attaches the hash to the context object
     * so it can be attached to the contract instance after a deployment resolves.
     * @param  {Object} context   execution state
     * @param  {String} hash      transaction hash
     */
    hash: function hash(context, _hash) {
        context.transactionHash = _hash;
        context.promiEvent.eventEmitter.emit("transactionHash", _hash);
        this.removeListener("transactionHash", handlers.hash);
    },
    confirmation: function confirmation(context, number, receipt) {
        context.promiEvent.eventEmitter.emit("confirmation", number, receipt); // Per web3: initial confirmation index is 0

        if (number === handlers.maxConfirmations + 1) {
            this.removeListener("confirmation", handlers.confirmation);
        }
    },

    /**
     * Receipt event handler. This handler decodes the event logs, re-emits the receipt,
     * and (for method calls only) resolves/rejects the promiEvent with the receipt.
     * @param  {Object} context   execution state
     * @param  {Object} receipt   transaction receipt
     */
    receipt: function() {
        var _receipt2 = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee(context, _receipt) {
            var reason, error;
            return _regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                    switch (_context.prev = _context.next) {
                        case 0:
                            // keep around the raw (not decoded) logs in the raw logs field as a
                            // stopgap until we can get the ABI for all events, not just the current
                            // contract
                            _receipt.rawLogs = _receipt.logs; // Decode logs, use as receipt.logs for ease of use.

                            _context.prev = 1;
                            _receipt.logs = _receipt.logs ? Utils.decodeLogs.call(context.contract, _receipt.logs) : [];
                            _context.next = 8;
                            break;

                        case 5:
                            _context.prev = 5;
                            _context.t0 = _context["catch"](1);
                            return _context.abrupt("return", context.promiEvent.reject(_context.t0));

                        case 8:
                            // Emit receipt
                            context.promiEvent.eventEmitter.emit("receipt", _receipt); // .new(): Exit early. We need the promiEvent to resolve a contract instance.

                            if (!context.onlyEmitReceipt) {
                                _context.next = 12;
                                break;
                            }

                            context.receipt = _receipt;
                            return _context.abrupt("return");

                        case 12:
                            if (!(_receipt.status !== undefined && !_receipt.status)) {
                                _context.next = 18;
                                break;
                            }

                            _context.next = 15;
                            return Reason.get(context.params, context.contract.web3, context.contract.interfaceAdapter);

                        case 15:
                            reason = _context.sent;
                            error = new StatusError(context.params, _receipt.transactionHash, _receipt, reason);
                            return _context.abrupt("return", context.promiEvent.reject(error));

                        case 18:
                            // This object has some duplicate data but is backward compatible.
                            context.promiEvent.resolve({
                                tx: _receipt.transactionHash,
                                receipt: _receipt,
                                logs: _receipt.logs
                            }); //HACK: adding this conditional for when the handler is invoked
                            //manually during stacktracing

                            if (this.removeListener) {
                                this.removeListener("receipt", handlers.receipt);
                            }

                        case 20:
                        case "end":
                            return _context.stop();
                    }
                }
            }, _callee, this, [
                [1, 5]
            ]);
        }));

        function receipt(_x, _x2) {
            return _receipt2.apply(this, arguments);
        }

        return receipt;
    }()
};
module.exports = handlers;