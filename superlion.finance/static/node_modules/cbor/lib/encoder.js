'use strict';

var _slicedToArray = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray");

var _toConsumableArray = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray");

var _classCallCheck = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck");

var _createClass = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass");

var _possibleConstructorReturn = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf");

var _inherits = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits");

function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {};
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true,
        didErr = false,
        err;
    return {
        s: function s() {
            it = o[Symbol.iterator]();
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally {
                if (didErr) throw err;
            }
        }
    };
}

function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
    }
    return arr2;
}

var stream = require('stream');

var url = require('url');

var bignumber = require('bignumber.js').BigNumber;

var NoFilter = require('nofilter');

var Tagged = require('./tagged');

var Simple = require('./simple');

var utils = require('./utils');

var constants = require('./constants');

var MT = constants.MT;
var NUMBYTES = constants.NUMBYTES;
var SHIFT32 = constants.SHIFT32;
var SYMS = constants.SYMS;
var TAG = constants.TAG;
var HALF = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.TWO;
var FLOAT = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.FOUR;
var DOUBLE = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.EIGHT;
var TRUE = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.TRUE;
var FALSE = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.FALSE;
var UNDEFINED = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.UNDEFINED;
var NULL = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.NULL;
var BREAK = Buffer.from([0xff]);
var BI = utils.bigIntize(constants.BI);
var BN = constants.BN;
var BUF_NAN = Buffer.from('f97e00', 'hex');
var BUF_INF_NEG = Buffer.from('f9fc00', 'hex');
var BUF_INF_POS = Buffer.from('f97c00', 'hex');
var BUF_NEG_ZERO = Buffer.from('f98000', 'hex');
var LOOP_DETECT = Symbol('CBOR_LOOP_DETECT');
/**
 * Transform JavaScript values into CBOR bytes.  The `Writable` side of
 * the stream is in object mode.
 *
 * @extends {stream.Transform}
 */

var Encoder = /*#__PURE__*/ function(_stream$Transform) {
    _inherits(Encoder, _stream$Transform);

    /**
     * Creates an instance of Encoder.
     *
     * @param {Object} [options={}] - options for the encoder
     * @param {any[]} [options.genTypes=[]] - array of pairs of `type`,
     *   `function(Encoder)` for semantic types to be encoded.  Not needed
     *   for Array, Date, Buffer, Map, RegExp, Set, Url, or bignumber.
     * @param {boolean} [options.canonical=false] - should the output be
     *   canonicalized
     * @param {boolean|Symbol} [options.detectLoops=false] - should object loops
     *   be detected?  This will currently modify the encoded object graph
     *   by adding a Symbol property to each object.  If this bothers you,
     *   call `removeLoopDetectors` on the encoded object when done.  Do not
     *   encode the same object twice on the same encoder, without calling
     *   `removeLoopDetectors` in between.
     * @param {("number"|"float"|"int"|"string")} [options.dateType="number"] -
     *   how should dates be encoded?  "number" means float or int, if no
     *   fractional seconds.
     * @param {any} [options.encodeUndefined=undefined] - How should an 
     *   "undefined" in the input be encoded.  By default, just encode a CBOR
     *   undefined.  If this is a buffer, use those bytes without re-encoding
     *   them.  If this is a function, the function will be called (which is
     *   a good time to throw an exception, if that's what you want), and the
     *   return value will be used according to these rules.  Anything
     *   else will be encoded as CBOR.
     * @param {boolean} [options.disallowUndefinedKeys=false] - Should "undefined"
     *   be disallowed as a key in a Map that is serialized?  If this is true,
     *   encode(new Map([[undefined, 1]])) will throw an exception.  Note that
     *   it is impossible to get a key of undefined in a normal JS object.
     * @param {boolean} [options.collapseBigIntegers=false] - Should integers
     *   that come in as BigNumber integers and ECMAscript bigint's be encoded
     *   as normal CBOR integers if they fit, discarding type information?
     */
    function Encoder(options) {
        var _this;

        _classCallCheck(this, Encoder);

        var opts = Object.assign({}, options, {
            readableObjectMode: false,
            writableObjectMode: true
        });
        _this = _possibleConstructorReturn(this, _getPrototypeOf(Encoder).call(this, opts));
        _this.canonical = opts.canonical;
        _this.encodeUndefined = opts.encodeUndefined;
        _this.disallowUndefinedKeys = !!opts.disallowUndefinedKeys;
        _this.dateType = opts.dateType != null ? opts.dateType.toLowerCase() : 'number';
        _this.collapseBigIntegers = !!opts.collapseBigIntegers; // new Symbol for each instance.  Note: means we can't re-use the same
        // encoder and encoded object

        if (typeof opts.detectLoops === 'symbol') {
            _this.detectLoops = opts.detectLoops;
        } else {
            _this.detectLoops = !!opts.detectLoops ? Symbol('CBOR_DETECT') : null;
        }

        _this.semanticTypes = {
            Array: _this._pushArray,
            Date: _this._pushDate,
            Buffer: _this._pushBuffer,
            Map: _this._pushMap,
            NoFilter: _this._pushNoFilter,
            RegExp: _this._pushRegexp,
            Set: _this._pushSet,
            BigNumber: _this._pushBigNumber,
            ArrayBuffer: _this._pushUint8Array,
            Uint8ClampedArray: _this._pushUint8Array,
            Uint8Array: _this._pushUint8Array,
            Uint16Array: _this._pushArray,
            Uint32Array: _this._pushArray,
            Int8Array: _this._pushArray,
            Int16Array: _this._pushArray,
            Int32Array: _this._pushArray,
            Float32Array: _this._pushFloat32Array,
            Float64Array: _this._pushFloat64Array
        }; // tsc doesn't know about old Url

        if (url['Url']) {
            _this.addSemanticType('Url', _this._pushUrl);
        }

        if (url['URL']) {
            _this.addSemanticType('URL', _this._pushURL);
        }

        var addTypes = opts.genTypes || [];

        for (var i = 0, len = addTypes.length; i < len; i += 2) {
            _this.addSemanticType(addTypes[i], addTypes[i + 1]);
        }

        return _this;
    }

    _createClass(Encoder, [{
        key: "_transform",
        value: function _transform(fresh, encoding, cb) {
            var ret = this.pushAny(fresh); // Old transformers might not return bool.  undefined !== false

            return cb(ret === false ? new Error('Push Error') : undefined);
        }
    }, {
        key: "_flush",
        value: function _flush(cb) {
            return cb();
        }
        /**
         * @callback encodeFunction
         * @param {Encoder} encoder - the encoder to serialize into.  Call "write"
         *   on the encoder as needed.
         * @return {bool} - true on success, else false
         */

        /**
         * Add an encoding function to the list of supported semantic types.  This is
         * useful for objects for which you can't add an encodeCBOR method
         *
         * @param {any} type
         * @param {any} fun
         * @returns {encodeFunction}
         */

    }, {
        key: "addSemanticType",
        value: function addSemanticType(type, fun) {
            if (typeof fun !== 'function') {
                throw new TypeError('fun must be of type function');
            }

            var typeName = typeof type === 'string' ? type : type.name;
            var old = this.semanticTypes[typeName];
            this.semanticTypes[typeName] = fun;
            return old;
        }
    }, {
        key: "_pushUInt8",
        value: function _pushUInt8(val) {
            var b = Buffer.allocUnsafe(1);
            b.writeUInt8(val, 0);
            return this.push(b);
        }
    }, {
        key: "_pushUInt16BE",
        value: function _pushUInt16BE(val) {
            var b = Buffer.allocUnsafe(2);
            b.writeUInt16BE(val, 0);
            return this.push(b);
        }
    }, {
        key: "_pushUInt32BE",
        value: function _pushUInt32BE(val) {
            var b = Buffer.allocUnsafe(4);
            b.writeUInt32BE(val, 0);
            return this.push(b);
        }
    }, {
        key: "_pushFloatBE",
        value: function _pushFloatBE(val) {
            var b = Buffer.allocUnsafe(4);
            b.writeFloatBE(val, 0);
            return this.push(b);
        }
    }, {
        key: "_pushDoubleBE",
        value: function _pushDoubleBE(val) {
            var b = Buffer.allocUnsafe(8);
            b.writeDoubleBE(val, 0);
            return this.push(b);
        }
    }, {
        key: "_pushNaN",
        value: function _pushNaN() {
            return this.push(BUF_NAN);
        }
    }, {
        key: "_pushInfinity",
        value: function _pushInfinity(obj) {
            var half = obj < 0 ? BUF_INF_NEG : BUF_INF_POS;
            return this.push(half);
        }
    }, {
        key: "_pushFloat",
        value: function _pushFloat(obj) {
            if (this.canonical) {
                // TODO: is this enough slower to hide behind canonical?
                // It's certainly enough of a hack (see utils.parseHalf)
                // From section 3.9:
                // If a protocol allows for IEEE floats, then additional canonicalization
                // rules might need to be added.  One example rule might be to have all
                // floats start as a 64-bit float, then do a test conversion to a 32-bit
                // float; if the result is the same numeric value, use the shorter value
                // and repeat the process with a test conversion to a 16-bit float.  (This
                // rule selects 16-bit float for positive and negative Infinity as well.)
                // which seems pretty much backwards to me.
                var b2 = Buffer.allocUnsafe(2);

                if (utils.writeHalf(b2, obj)) {
                    // I have convinced myself that there are no cases where writeHalf
                    // will return true but `utils.parseHalf(b2) !== obj)`
                    return this._pushUInt8(HALF) && this.push(b2);
                }
            }

            if (Math.fround(obj) === obj) {
                return this._pushUInt8(FLOAT) && this._pushFloatBE(obj);
            }

            return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj);
        }
    }, {
        key: "_pushInt",
        value: function _pushInt(obj, mt, orig) {
            var m = mt << 5;

            switch (false) {
                case !(obj < 24):
                    return this._pushUInt8(m | obj);

                case !(obj <= 0xff):
                    return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj);

                case !(obj <= 0xffff):
                    return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj);

                case !(obj <= 0xffffffff):
                    return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj);

                case !(obj <= Number.MAX_SAFE_INTEGER):
                    return this._pushUInt8(m | NUMBYTES.EIGHT) && this._pushUInt32BE(Math.floor(obj / SHIFT32)) && this._pushUInt32BE(obj % SHIFT32);

                default:
                    if (mt === MT.NEG_INT) {
                        return this._pushFloat(orig);
                    } else {
                        return this._pushFloat(obj);
                    }

            }
        }
    }, {
        key: "_pushIntNum",
        value: function _pushIntNum(obj) {
            if (Object.is(obj, -0)) {
                return this.push(BUF_NEG_ZERO);
            }

            if (obj < 0) {
                return this._pushInt(-obj - 1, MT.NEG_INT, obj);
            } else {
                return this._pushInt(obj, MT.POS_INT);
            }
        }
    }, {
        key: "_pushNumber",
        value: function _pushNumber(obj) {
            switch (false) {
                case !isNaN(obj):
                    return this._pushNaN();

                case isFinite(obj):
                    return this._pushInfinity(obj);

                case Math.round(obj) !== obj:
                    return this._pushIntNum(obj);

                default:
                    return this._pushFloat(obj);
            }
        }
    }, {
        key: "_pushString",
        value: function _pushString(obj) {
            var len = Buffer.byteLength(obj, 'utf8');
            return this._pushInt(len, MT.UTF8_STRING) && this.push(obj, 'utf8');
        }
    }, {
        key: "_pushBoolean",
        value: function _pushBoolean(obj) {
            return this._pushUInt8(obj ? TRUE : FALSE);
        }
    }, {
        key: "_pushUndefined",
        value: function _pushUndefined(obj) {
            switch (typeof this.encodeUndefined) {
                case 'undefined':
                    return this._pushUInt8(UNDEFINED);

                case 'function':
                    return this.pushAny(this.encodeUndefined.call(this, obj));

                case 'object':
                    if (Buffer.isBuffer(this.encodeUndefined)) {
                        return this.push(this.encodeUndefined);
                    }

            }

            return this.pushAny(this.encodeUndefined);
        }
    }, {
        key: "_pushNull",
        value: function _pushNull(obj) {
            return this._pushUInt8(NULL);
        }
    }, {
        key: "_pushArray",
        value: function _pushArray(gen, obj, opts) {
            opts = Object.assign({
                indefinite: false
            }, opts);
            var len = obj.length;

            if (opts.indefinite) {
                if (!gen._pushUInt8(MT.ARRAY << 5 | NUMBYTES.INDEFINITE)) {
                    return false;
                }
            } else if (!gen._pushInt(len, MT.ARRAY)) {
                return false;
            }

            for (var j = 0; j < len; j++) {
                if (!gen.pushAny(obj[j])) {
                    return false;
                }
            }

            if (opts.indefinite) {
                if (!gen.push(BREAK)) {
                    return false;
                }
            }

            return true;
        }
    }, {
        key: "_pushTag",
        value: function _pushTag(tag) {
            return this._pushInt(tag, MT.TAG);
        }
    }, {
        key: "_pushDate",
        value: function _pushDate(gen, obj) {
            switch (gen.dateType) {
                case 'string':
                    return gen._pushTag(TAG.DATE_STRING) && gen._pushString(obj.toISOString());

                case 'int':
                case 'integer':
                    return gen._pushTag(TAG.DATE_EPOCH) && gen._pushIntNum(Math.round(obj / 1000));

                case 'float':
                    // force float
                    return gen._pushTag(TAG.DATE_EPOCH) && gen._pushFloat(obj / 1000);

                case 'number':
                default:
                    // if we happen to have an integral number of seconds,
                    // use integer.  Otherwise, use float.
                    return gen._pushTag(TAG.DATE_EPOCH) && gen.pushAny(obj / 1000);
            }
        }
    }, {
        key: "_pushBuffer",
        value: function _pushBuffer(gen, obj) {
            return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj);
        }
    }, {
        key: "_pushNoFilter",
        value: function _pushNoFilter(gen, obj) {
            return gen._pushBuffer(gen, obj.slice());
        }
    }, {
        key: "_pushRegexp",
        value: function _pushRegexp(gen, obj) {
            return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source);
        }
    }, {
        key: "_pushSet",
        value: function _pushSet(gen, obj) {
            if (!gen._pushInt(obj.size, MT.ARRAY)) {
                return false;
            }

            var _iterator = _createForOfIteratorHelper(obj),
                _step;

            try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    var x = _step.value;

                    if (!gen.pushAny(x)) {
                        return false;
                    }
                }
            } catch (err) {
                _iterator.e(err);
            } finally {
                _iterator.f();
            }

            return true;
        }
    }, {
        key: "_pushUrl",
        value: function _pushUrl(gen, obj) {
            return gen._pushTag(TAG.URI) && gen.pushAny(obj.format());
        }
    }, {
        key: "_pushURL",
        value: function _pushURL(gen, obj) {
            return gen._pushTag(TAG.URI) && gen.pushAny(obj.toString());
        }
        /**
         * @param {bignumber} obj
         * @private
         */

    }, {
        key: "_pushBigint",
        value: function _pushBigint(obj) {
            var m = MT.POS_INT;
            var tag = TAG.POS_BIGINT;

            if (obj.isNegative()) {
                obj = obj.negated().minus(1);
                m = MT.NEG_INT;
                tag = TAG.NEG_BIGINT;
            }

            if (this.collapseBigIntegers && obj.lte(BN.MAXINT64)) {
                //  special handiling for 64bits
                if (obj.lte(BN.MAXINT32)) {
                    return this._pushInt(obj.toNumber(), m);
                }

                return this._pushUInt8(m << 5 | NUMBYTES.EIGHT) && this._pushUInt32BE(obj.dividedToIntegerBy(BN.SHIFT32).toNumber()) && this._pushUInt32BE(obj.mod(BN.SHIFT32).toNumber());
            }

            var str = obj.toString(16);

            if (str.length % 2) {
                str = '0' + str;
            }

            var buf = Buffer.from(str, 'hex');
            return this._pushTag(tag) && this._pushBuffer(this, buf);
        }
        /**
         * @param {bigint} obj
         * @private
         */

    }, {
        key: "_pushJSBigint",
        value: function _pushJSBigint(obj) {
            var m = MT.POS_INT;
            var tag = TAG.POS_BIGINT; // BigInt doesn't have -0

            if (obj < 0) {
                obj = -obj + BI.MINUS_ONE;
                m = MT.NEG_INT;
                tag = TAG.NEG_BIGINT;
            }

            if (this.collapseBigIntegers && obj <= BI.MAXINT64) {
                //  special handiling for 64bits
                if (obj <= 0xffffffff) {
                    return this._pushInt(Number(obj), m);
                }

                return this._pushUInt8(m << 5 | NUMBYTES.EIGHT) && this._pushUInt32BE(Number(obj / BI.SHIFT32)) && this._pushUInt32BE(Number(obj % BI.SHIFT32));
            }

            var str = obj.toString(16);

            if (str.length % 2) {
                str = '0' + str;
            }

            var buf = Buffer.from(str, 'hex');
            return this._pushTag(tag) && this._pushBuffer(this, buf);
        }
    }, {
        key: "_pushBigNumber",
        value: function _pushBigNumber(gen, obj) {
            if (obj.isNaN()) {
                return gen._pushNaN();
            }

            if (!obj.isFinite()) {
                return gen._pushInfinity(obj.isNegative() ? -Infinity : Infinity);
            }

            if (obj.isInteger()) {
                return gen._pushBigint(obj);
            }

            if (!(gen._pushTag(TAG.DECIMAL_FRAC) && gen._pushInt(2, MT.ARRAY))) {
                return false;
            }

            var dec = obj.decimalPlaces();
            var slide = obj.shiftedBy(dec);

            if (!gen._pushIntNum(-dec)) {
                return false;
            }

            if (slide.abs().isLessThan(BN.MAXINT)) {
                return gen._pushIntNum(slide.toNumber());
            } else {
                return gen._pushBigint(slide);
            }
        }
    }, {
        key: "_pushMap",
        value: function _pushMap(gen, obj, opts) {
            opts = Object.assign({
                indefinite: false
            }, opts);

            if (opts.indefinite) {
                if (!gen._pushUInt8(MT.MAP << 5 | NUMBYTES.INDEFINITE)) {
                    return false;
                }
            } else if (!gen._pushInt(obj.size, MT.MAP)) {
                return false;
            } // memoizing the cbor only helps in certain cases, and hurts in most
            // others.  Just avoid it.


            if (gen.canonical) {
                // keep the key/value pairs together, so we don't have to do odd
                // gets with object keys later
                var entries = _toConsumableArray(obj.entries());

                var enc = new Encoder(this); // TODO: fix genTypes

                var bs = new NoFilter({
                    highWaterMark: this.readableHighWaterMark
                });
                enc.pipe(bs);
                entries.sort(function(_ref, _ref2) {
                    var _ref3 = _slicedToArray(_ref, 1),
                        a = _ref3[0];

                    var _ref4 = _slicedToArray(_ref2, 1),
                        b = _ref4[0];

                    // a, b are the keys
                    enc.pushAny(a);
                    var a_cbor = bs.read();
                    enc.pushAny(b);
                    var b_cbor = bs.read();
                    return a_cbor.compare(b_cbor);
                });

                var _iterator2 = _createForOfIteratorHelper(entries),
                    _step2;

                try {
                    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                        var _step2$value = _slicedToArray(_step2.value, 2),
                            k = _step2$value[0],
                            v = _step2$value[1];

                        if (gen.disallowUndefinedKeys && typeof k === 'undefined') {
                            throw new Error('Invalid Map key: undefined');
                        }

                        if (!(gen.pushAny(k) && gen.pushAny(v))) {
                            return false;
                        }
                    }
                } catch (err) {
                    _iterator2.e(err);
                } finally {
                    _iterator2.f();
                }
            } else {
                var _iterator3 = _createForOfIteratorHelper(obj),
                    _step3;

                try {
                    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                        var _step3$value = _slicedToArray(_step3.value, 2),
                            _k = _step3$value[0],
                            _v = _step3$value[1];

                        if (gen.disallowUndefinedKeys && typeof _k === 'undefined') {
                            throw new Error('Invalid Map key: undefined');
                        }

                        if (!(gen.pushAny(_k) && gen.pushAny(_v))) {
                            return false;
                        }
                    }
                } catch (err) {
                    _iterator3.e(err);
                } finally {
                    _iterator3.f();
                }
            }

            if (opts.indefinite) {
                if (!gen.push(BREAK)) {
                    return false;
                }
            }

            return true;
        }
    }, {
        key: "_pushUint8Array",
        value: function _pushUint8Array(gen, obj) {
            return gen._pushBuffer(gen, Buffer.from(obj));
        }
    }, {
        key: "_pushFloat32Array",
        value: function _pushFloat32Array(gen, obj) {
            var len = obj.length;

            if (!gen._pushInt(len, MT.ARRAY)) {
                return false;
            }

            for (var j = 0; j < len; j++) {
                if (!gen._pushUInt8(FLOAT) || !gen._pushFloatBE(obj[j])) {
                    return false;
                }
            }

            return true;
        }
    }, {
        key: "_pushFloat64Array",
        value: function _pushFloat64Array(gen, obj) {
            var len = obj.length;

            if (!gen._pushInt(len, MT.ARRAY)) {
                return false;
            }

            for (var j = 0; j < len; j++) {
                if (!gen._pushUInt8(DOUBLE) || !gen._pushDoubleBE(obj[j])) {
                    return false;
                }
            }

            return true;
        }
        /**
         * Remove all of the loop detector additions to the given object.
         *
         * @param {Object} obj - object to clean
         * @returns {bool} - true when the object was cleaned, else false
         */

    }, {
        key: "removeLoopDetectors",
        value: function removeLoopDetectors(obj) {
            if (!this.detectLoops) {
                return false;
            }

            return Encoder.removeLoopDetectors(obj, this.detectLoops);
        }
        /**
         * Remove all of the loop detector additions to the given object.
         * The static version is easier to call when you don't have a full
         * encoder instance available; it uses a good heuristic to figure
         * out the loop detector symbol.
         *
         * @param {Object} obj - object to clean
         * @param {Symbol} [detector=null] - the symbol to clean, or null
         *   to use the first detected symbol
         * @returns {bool} - true when the object was cleaned, else false
         */

    }, {
        key: "_pushObject",
        value: function _pushObject(obj, opts) {
            if (!obj) {
                return this._pushNull(obj);
            }

            opts = Object.assign({
                indefinite: false,
                skipTypes: false
            }, opts);

            if (!opts.indefinite) {
                // this will only happen the first time through for indefinite encoding
                if (this.detectLoops) {
                    if (obj[LOOP_DETECT] === this.detectLoops) {
                        throw new Error('Loop detected while CBOR encoding');
                    } else {
                        obj[LOOP_DETECT] = this.detectLoops;
                    }
                }
            }

            if (!opts.skipTypes) {
                var f = obj.encodeCBOR;

                if (typeof f === 'function') {
                    return f.call(obj, this);
                }

                var converter = this.semanticTypes[obj.constructor.name];

                if (converter) {
                    return converter.call(obj, this, obj);
                }
            }

            var keys = Object.keys(obj).filter(function(k) {
                return typeof obj[k] !== 'function';
            });
            var cbor_keys = {};

            if (this.canonical) {
                // note: this can't be a normal sort, because 'b' needs to sort before
                // 'aa'
                keys.sort(function(a, b) {
                    // Always strings, so don't bother to pass options.
                    // hold on to the cbor versions, since there's no need
                    // to encode more than once
                    var a_cbor = cbor_keys[a] || (cbor_keys[a] = Encoder.encode(a));
                    var b_cbor = cbor_keys[b] || (cbor_keys[b] = Encoder.encode(b));
                    return a_cbor.compare(b_cbor);
                });
            }

            if (opts.indefinite) {
                if (!this._pushUInt8(MT.MAP << 5 | NUMBYTES.INDEFINITE)) {
                    return false;
                }
            } else if (!this._pushInt(keys.length, MT.MAP)) {
                return false;
            }

            var ck;

            for (var j = 0, len2 = keys.length; j < len2; j++) {
                var k = keys[j];

                if (this.canonical && (ck = cbor_keys[k])) {
                    if (!this.push(ck)) {
                        // already a Buffer
                        return false;
                    }
                } else {
                    if (!this._pushString(k)) {
                        return false;
                    }
                }

                if (!this.pushAny(obj[k])) {
                    return false;
                }
            }

            if (opts.indefinite) {
                if (!this.push(BREAK)) {
                    return false;
                }
            }

            return true;
        }
        /**
         * Push any supported type onto the encoded stream
         *
         * @param {any} obj
         * @returns {boolean} true on success
         */

    }, {
        key: "pushAny",
        value: function pushAny(obj) {
            switch (typeof obj) {
                case 'number':
                    return this._pushNumber(obj);

                case 'bigint':
                    return this._pushJSBigint(obj);

                case 'string':
                    return this._pushString(obj);

                case 'boolean':
                    return this._pushBoolean(obj);

                case 'undefined':
                    return this._pushUndefined(obj);

                case 'object':
                    return this._pushObject(obj);

                case 'symbol':
                    switch (obj) {
                        case SYMS.NULL:
                            return this._pushNull(null);

                        case SYMS.UNDEFINED:
                            return this._pushUndefined(void 0);
                            // TODO: Add pluggable support for other symbols

                        default:
                            throw new Error('Unknown symbol: ' + obj.toString());
                    }

                default:
                    throw new Error('Unknown type: ' + typeof obj + ', ' + (!!obj.toString ? obj.toString() : ''));
            }
        }
        /* backwards-compat wrapper */

    }, {
        key: "_pushAny",
        value: function _pushAny(obj) {
            // TODO: write deprecation warning
            return this.pushAny(obj);
        }
    }, {
        key: "_encodeAll",
        value: function _encodeAll(objs) {
            var bs = new NoFilter({
                highWaterMark: this.readableHighWaterMark
            });
            this.pipe(bs);

            var _iterator4 = _createForOfIteratorHelper(objs),
                _step4;

            try {
                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                    var o = _step4.value;
                    this.pushAny(o);
                }
            } catch (err) {
                _iterator4.e(err);
            } finally {
                _iterator4.f();
            }

            this.end();
            return bs.read();
        }
        /**
         * Encode the given object with indefinite length.  There are apparently
         * some (IMO) broken implementations of poorly-specified protocols that
         * REQUIRE indefinite-encoding.  Add this to an object or class as the
         * `encodeCBOR` function to get indefinite encoding:
         * @example
         * const o = {
         *   a: true,
         *   encodeCBOR: cbor.Encoder.encodeIndefinite
         * }
         * const m = []
         * m.encodeCBOR = cbor.Encoder.encodeIndefinite
         * cbor.encodeOne([o, m])
         *
         * @param {Encoder} - the encoder to use
         * @param {String|Buffer|Array|Map|Object} [obj] - the object to encode.  If
         *   null, use "this" instead.
         * @param {Object} [opts=null] - Options for encoding
         * @param {boolean} [opts.chunkSize=4096] - Number of characters or bytes
         *  for each chunk, if obj is a string or Buffer
         * @returns {boolean} - true on success
         */

    }], [{
        key: "removeLoopDetectors",
        value: function removeLoopDetectors(obj) {
            var detector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

            if (typeof obj !== 'object' || !obj) {
                return false;
            }

            var dl = obj[LOOP_DETECT];

            if (!dl) {
                // ironically, use loop marking to detect loops on removal as well
                return false;
            }

            if (detector == null) {
                detector = dl;
            } else {
                if (detector !== dl) {
                    return false;
                }
            }

            delete obj[LOOP_DETECT];

            if (Array.isArray(obj)) {
                var _iterator5 = _createForOfIteratorHelper(obj),
                    _step5;

                try {
                    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                        var i = _step5.value;
                        this.removeLoopDetectors(i, detector);
                    }
                } catch (err) {
                    _iterator5.e(err);
                } finally {
                    _iterator5.f();
                }
            } else {
                for (var k in obj) {
                    this.removeLoopDetectors(obj[k], detector);
                }
            }

            return true;
        }
    }, {
        key: "encodeIndefinite",
        value: function encodeIndefinite(gen, obj, opts) {
            if (obj == null) {
                if (this == null) {
                    throw new Error('No object to encode');
                }

                obj = this;
            }

            opts = Object.assign({
                chunkSize: 4096
            }, opts);
            var ret = true;
            var objType = typeof obj;

            if (objType === 'string') {
                // TODO: make sure not to split surrogate pairs at the edges of chunks,
                // since such half-surrogates cannot be legally encoded as UTF-8.
                ret = ret && gen._pushUInt8(MT.UTF8_STRING << 5 | NUMBYTES.INDEFINITE);
                var offset = 0;

                while (offset < obj.length) {
                    var endIndex = offset + opts.chunkSize;
                    ret = ret && gen._pushString(obj.slice(offset, endIndex));
                    offset = endIndex;
                }

                ret = ret && gen.push(BREAK);
            } else if (Buffer.isBuffer(obj)) {
                ret = ret && gen._pushUInt8(MT.BYTE_STRING << 5 | NUMBYTES.INDEFINITE);
                var _offset = 0;

                while (_offset < obj.length) {
                    var _endIndex = _offset + opts.chunkSize;

                    ret = ret && gen._pushBuffer(gen, obj.slice(_offset, _endIndex));
                    _offset = _endIndex;
                }

                ret = ret && gen.push(BREAK);
            } else if (Array.isArray(obj)) {
                ret = ret && gen._pushArray(gen, obj, {
                    indefinite: true
                });
            } else if (obj instanceof Map) {
                ret = ret && gen._pushMap(gen, obj, {
                    indefinite: true
                });
            } else {
                if (objType !== 'object') {
                    throw new Error('Invalid indefinite encoding');
                }

                ret = ret && gen._pushObject(obj, {
                    indefinite: true,
                    skipTypes: true
                });
            }

            return ret;
        }
        /**
         * Encode one or more JavaScript objects, and return a Buffer containing the
         * CBOR bytes.
         *
         * @param {...any} objs - the objects to encode
         * @returns {Buffer} - the encoded objects
         */

    }, {
        key: "encode",
        value: function encode() {
            for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {
                objs[_key] = arguments[_key];
            }

            return new Encoder()._encodeAll(objs);
        }
        /**
         * Encode one or more JavaScript objects canonically (slower!), and return
         * a Buffer containing the CBOR bytes.
         *
         * @param {...any} objs - the objects to encode
         * @returns {Buffer} - the encoded objects
         */

    }, {
        key: "encodeCanonical",
        value: function encodeCanonical() {
            for (var _len2 = arguments.length, objs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                objs[_key2] = arguments[_key2];
            }

            return new Encoder({
                canonical: true
            })._encodeAll(objs);
        }
        /**
         * Encode one JavaScript object using the given options.
         *
         * @static
         * @param {any} obj - the object to encode
         * @param {Object?} options - passed to the Encoder constructor
         * @returns {Buffer} - the encoded objects
         */

    }, {
        key: "encodeOne",
        value: function encodeOne(obj, options) {
            return new Encoder(options)._encodeAll([obj]);
        }
        /**
         * Encode one JavaScript object using the given options in a way that
         * is more resilient to objects being larger than the highWaterMark
         * number of bytes.  As with the other static encode functions, this 
         * will still use a large amount of memory.  Use a stream-based approach
         * directly if you need to process large and complicated inputs.
         *
         * @param {any} obj - the object to encode
         * @param {Object?} options - passed to the Encoder constructor
         */

    }, {
        key: "encodeAsync",
        value: function encodeAsync(obj, options) {
            return new Promise(function(resolve, reject) {
                var bufs = [];
                var enc = new Encoder(options);
                enc.on('data', function(buf) {
                    return bufs.push(buf);
                });
                enc.on('error', reject);
                enc.on('finish', function() {
                    return resolve(Buffer.concat(bufs));
                });
                enc.pushAny(obj);
                enc.end();
            });
        }
    }]);

    return Encoder;
}(stream.Transform);

module.exports = Encoder;