'use strict';

var _classCallCheck = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck");

var _createClass = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass");

var _possibleConstructorReturn = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf");

var _inherits = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits");

var _assertThisInitialized = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized");

var stream = require('stream');

var util = require('util');

var utils = require('./utils');

var Simple = require('./simple');

var Decoder = require('./decoder');

var constants = require('./constants');

var bignumber = require('bignumber.js').BigNumber;

var NoFilter = require('nofilter');

var MT = constants.MT;
var NUMBYTES = constants.NUMBYTES;
var SYMS = constants.SYMS;

function plural(c) {
    if (c > 1) {
        return 's';
    } else {
        return '';
    }
}
/**
 * Generate the expanded format of RFC 7049, section 2.2.1
 *
 * @extends {stream.Transform}
 */


var Commented = /*#__PURE__*/ function(_stream$Transform) {
    _inherits(Commented, _stream$Transform);

    /**
     * Create a CBOR commenter.
     *
     * @param {object} [options={}] - Stream options
     * @param {number} [options.max_depth=10] - how many times to indent
     *   the dashes
     * @param {number} [options.depth=1] - initial indentation depth
     * @param {boolean} [options.no_summary=false] - if true, omit the summary
     *   of the full bytes read at the end
     */
    function Commented(options) {
        var _this;

        _classCallCheck(this, Commented);

        var opts = Object.assign({
            depth: 1,
            max_depth: 10,
            no_summary: false
        }, options, {
            readableObjectMode: false,
            writableObjectMode: false
        });
        var max_depth = opts.max_depth;
        delete opts.max_depth;
        var depth = opts.depth;
        delete opts.depth;
        _this = _possibleConstructorReturn(this, _getPrototypeOf(Commented).call(this, opts));
        _this.depth = depth;
        _this.max_depth = max_depth;
        _this.all = new NoFilter();
        opts.tags = {
            24: _this._tag_24.bind(_assertThisInitialized(_assertThisInitialized(_this)))
        };
        _this.parser = new Decoder(opts);

        _this.parser.on('value', _this._on_value.bind(_assertThisInitialized(_assertThisInitialized(_this))));

        _this.parser.on('start', _this._on_start.bind(_assertThisInitialized(_assertThisInitialized(_this))));

        _this.parser.on('start-string', _this._on_start_string.bind(_assertThisInitialized(_assertThisInitialized(_this))));

        _this.parser.on('stop', _this._on_stop.bind(_assertThisInitialized(_assertThisInitialized(_this))));

        _this.parser.on('more-bytes', _this._on_more.bind(_assertThisInitialized(_assertThisInitialized(_this))));

        _this.parser.on('error', _this._on_error.bind(_assertThisInitialized(_assertThisInitialized(_this))));

        if (!opts.no_summary) {
            _this.parser.on('data', _this._on_data.bind(_assertThisInitialized(_assertThisInitialized(_this))));
        }

        _this.parser.bs.on('read', _this._on_read.bind(_assertThisInitialized(_assertThisInitialized(_this))));

        return _this;
    }
    /**
     * @private
     */


    _createClass(Commented, [{
        key: "_tag_24",
        value: function _tag_24(v) {
            var _this2 = this;

            var c = new Commented({
                depth: this.depth + 1,
                no_summary: true
            });
            c.on('data', function(b) {
                return _this2.push(b);
            });
            c.on('error', function(er) {
                return _this2.emit('error', er);
            });
            c.end(v);
        }
    }, {
        key: "_transform",
        value: function _transform(fresh, encoding, cb) {
            this.parser.write(fresh, encoding, cb);
        }
        /**
         * @private
         */

    }, {
        key: "_flush",
        value: function _flush(cb) {
            // TODO: find the test that covers this, and look at the return value
            return this.parser._flush(cb);
        }
        /**
         * @callback commentCallback
         * @param {Error} [error] - if one was generated
         * @param {string} [commented] - the comment string
         */

        /**
         * @typedef CommentOptions
         * @property {number} [max_depth=10] how many times to indent the dashes
         * @property {string} [encoding='hex'] encoding of the input
         */

        /**
         * Comment on an input Buffer or string, creating a string passed to the
         * callback.  If callback not specified, a promise is returned.
         *
         * @static
         * @param {string|Buffer} input
         * @param {CommentOptions|commentCallback|string} [options] or callback
         * @param {commentCallback=} cb
         * @returns {Promise} if cb not specified
         */

    }, {
        key: "_on_error",

        /**
         * @private
         */
        value: function _on_error(er) {
            this.push('ERROR: ');
            this.push(er.toString());
            this.push('\n');
        }
        /**
         * @private
         */

    }, {
        key: "_on_read",
        value: function _on_read(buf) {
            this.all.write(buf);
            var hex = buf.toString('hex');
            this.push(new Array(this.depth + 1).join('  '));
            this.push(hex);
            var ind = (this.max_depth - this.depth) * 2;
            ind -= hex.length;

            if (ind < 1) {
                ind = 1;
            }

            this.push(new Array(ind + 1).join(' '));
            return this.push('-- ');
        }
        /**
         * @private
         */

    }, {
        key: "_on_more",
        value: function _on_more(mt, len, parent_mt, pos) {
            this.depth++;
            var desc = '';

            switch (mt) {
                case MT.POS_INT:
                    desc = 'Positive number,';
                    break;

                case MT.NEG_INT:
                    desc = 'Negative number,';
                    break;

                case MT.ARRAY:
                    desc = 'Array, length';
                    break;

                case MT.MAP:
                    desc = 'Map, count';
                    break;

                case MT.BYTE_STRING:
                    desc = 'Bytes, length';
                    break;

                case MT.UTF8_STRING:
                    desc = 'String, length';
                    break;

                case MT.SIMPLE_FLOAT:
                    if (len === 1) {
                        desc = 'Simple value,';
                    } else {
                        desc = 'Float,';
                    }

                    break;
            }

            return this.push(desc + ' next ' + len + ' byte' + plural(len) + '\n');
        }
        /**
         * @private
         */

    }, {
        key: "_on_start_string",
        value: function _on_start_string(mt, tag, parent_mt, pos) {
            this.depth++;
            var desc = '';

            switch (mt) {
                case MT.BYTE_STRING:
                    desc = 'Bytes, length: ' + tag;
                    break;

                case MT.UTF8_STRING:
                    desc = 'String, length: ' + tag.toString();
                    break;
            }

            return this.push(desc + '\n');
        }
        /**
         * @private
         */

    }, {
        key: "_on_start",
        value: function _on_start(mt, tag, parent_mt, pos) {
            this.depth++;

            if (tag !== SYMS.BREAK) {
                switch (parent_mt) {
                    case MT.ARRAY:
                        this.push("[".concat(pos, "], "));
                        break;

                    case MT.MAP:
                        if (pos % 2) {
                            this.push("{Val:".concat(Math.floor(pos / 2), "}, "));
                        } else {
                            this.push("{Key:".concat(Math.floor(pos / 2), "}, "));
                        }

                        break;
                }
            }

            switch (mt) {
                case MT.TAG:
                    this.push("Tag #".concat(tag));

                    if (tag == 24) {
                        this.push(' Encoded CBOR data item');
                    }

                    break;

                case MT.ARRAY:
                    if (tag === SYMS.STREAM) {
                        this.push('Array (streaming)');
                    } else {
                        this.push("Array, ".concat(tag, " item").concat(plural(tag)));
                    }

                    break;

                case MT.MAP:
                    if (tag === SYMS.STREAM) {
                        this.push('Map (streaming)');
                    } else {
                        this.push("Map, ".concat(tag, " pair").concat(plural(tag)));
                    }

                    break;

                case MT.BYTE_STRING:
                    this.push('Bytes (streaming)');
                    break;

                case MT.UTF8_STRING:
                    this.push('String (streaming)');
                    break;
            }

            return this.push('\n');
        }
        /**
         * @private
         */

    }, {
        key: "_on_stop",
        value: function _on_stop(mt) {
            return this.depth--;
        }
        /**
         * @private
         */

    }, {
        key: "_on_value",
        value: function _on_value(val, parent_mt, pos, ai) {
            if (val !== SYMS.BREAK) {
                switch (parent_mt) {
                    case MT.ARRAY:
                        this.push("[".concat(pos, "], "));
                        break;

                    case MT.MAP:
                        if (pos % 2) {
                            this.push("{Val:".concat(Math.floor(pos / 2), "}, "));
                        } else {
                            this.push("{Key:".concat(Math.floor(pos / 2), "}, "));
                        }

                        break;
                }
            }

            if (val === SYMS.BREAK) {
                this.push('BREAK\n');
            } else if (val === SYMS.NULL) {
                this.push('null\n');
            } else if (val === SYMS.UNDEFINED) {
                this.push('undefined\n');
            } else if (typeof val === 'string') {
                this.depth--;

                if (val.length > 0) {
                    this.push(JSON.stringify(val));
                    this.push('\n');
                }
            } else if (Buffer.isBuffer(val)) {
                this.depth--;

                if (val.length > 0) {
                    this.push(val.toString('hex'));
                    this.push('\n');
                }
            } else if (val instanceof bignumber) {
                this.push(val.toString());
                this.push('\n');
            } else {
                this.push(util.inspect(val));
                this.push('\n');
            }

            switch (ai) {
                case NUMBYTES.ONE:
                case NUMBYTES.TWO:
                case NUMBYTES.FOUR:
                case NUMBYTES.EIGHT:
                    this.depth--;
            }
        }
        /**
         * @private
         */

    }, {
        key: "_on_data",
        value: function _on_data() {
            this.push('0x');
            this.push(this.all.read().toString('hex'));
            return this.push('\n');
        }
    }], [{
        key: "comment",
        value: function comment(input, options, cb) {
            if (input == null) {
                throw new Error('input required');
            }

            var encoding = typeof input === 'string' ? 'hex' : void 0;
            var max_depth = 10;

            switch (typeof options) {
                case 'function':
                    cb = options;
                    break;

                case 'string':
                    encoding = options;
                    break;

                case 'number':
                    max_depth = options;
                    break;

                case 'object':
                    var ref1 = options.encoding;
                    var ref2 = options.max_depth;
                    encoding = ref1 != null ? ref1 : encoding;
                    max_depth = ref2 != null ? ref2 : max_depth;
                    break;

                case 'undefined':
                    break;

                default:
                    throw new Error('Unknown option type');
            }

            var bs = new NoFilter();
            var d = new Commented({
                max_depth: max_depth
            });
            var p = null;

            if (typeof cb === 'function') {
                d.on('end', function() {
                    cb(null, bs.toString('utf8'));
                });
                d.on('error', cb);
            } else {
                p = new Promise(function(resolve, reject) {
                    d.on('end', function() {
                        resolve(bs.toString('utf8'));
                    });
                    return d.on('error', reject);
                });
            }

            d.pipe(bs);
            d.end(input, encoding);
            return p;
        }
    }]);

    return Commented;
}(stream.Transform);

module.exports = Commented;