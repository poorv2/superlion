'use strict';

var _classCallCheck = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck");

var _createClass = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass");

var util = require('util');

var constants = require('./constants');

var MT = constants.MT;
var SIMPLE = constants.SIMPLE;
var SYMS = constants.SYMS;
/**
 * A CBOR Simple Value that does not map onto a known constant.
 */

var Simple = /*#__PURE__*/ function() {
    /**
     * Creates an instance of Simple.
     *
     * @param {number} value - the simple value's integer value
     */
    function Simple(value) {
        _classCallCheck(this, Simple);

        if (typeof value !== 'number') {
            throw new Error('Invalid Simple type: ' + typeof value);
        }

        if (value < 0 || value > 255 || (value | 0) !== value) {
            throw new Error('value must be a small positive integer: ' + value);
        }

        this.value = value;
    }
    /**
     * Debug string for simple value
     *
     * @returns {string} simple(value)
     */


    _createClass(Simple, [{
        key: "toString",
        value: function toString() {
            return 'simple(' + this.value + ')';
        }
        /**
         * Debug string for simple value
         *
         * @returns {string} simple(value)
         */

    }, {
        key: util.inspect.custom,
        value: function value(depth, opts) {
            return 'simple(' + this.value + ')';
        }
        /**
         * Debug string for simple value (backward-compatibility version)
         *
         * @returns {string} simple(value)
         */

    }, {
        key: "inspect",
        value: function inspect(depth, opts) {
            return 'simple(' + this.value + ')';
        }
        /**
         * Push the simple value onto the CBOR stream
         *
         * @param {Object} gen The generator to push onto
         */

    }, {
        key: "encodeCBOR",
        value: function encodeCBOR(gen) {
            return gen._pushInt(this.value, MT.SIMPLE_FLOAT);
        }
        /**
         * Is the given object a Simple?
         *
         * @param {any} obj - object to test
         * @returns {boolean} - is it Simple?
         */

    }], [{
        key: "isSimple",
        value: function isSimple(obj) {
            return obj instanceof Simple;
        }
        /**
         * Decode from the CBOR additional information into a JavaScript value.
         * If the CBOR item has no parent, return a "safe" symbol instead of
         * `null` or `undefined`, so that the value can be passed through a
         * stream in object mode.
         *
         * @param {number} val - the CBOR additional info to convert
         * @param {boolean} [has_parent=true] - Does the CBOR item have a parent?
         * @param {boolean} [parent_indefinite=false] - Is the parent element
         *   indefinitely encoded?
         * @returns {(null|undefined|boolean|Symbol|Simple)} - the decoded value
         */

    }, {
        key: "decode",
        value: function decode(val) {
            var has_parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            var parent_indefinite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

            switch (val) {
                case SIMPLE.FALSE:
                    return false;

                case SIMPLE.TRUE:
                    return true;

                case SIMPLE.NULL:
                    if (has_parent) {
                        return null;
                    } else {
                        return SYMS.NULL;
                    }

                case SIMPLE.UNDEFINED:
                    if (has_parent) {
                        return void 0;
                    } else {
                        return SYMS.UNDEFINED;
                    }

                case -1:
                    if (!has_parent || !parent_indefinite) {
                        throw new Error('Invalid BREAK');
                    }

                    return SYMS.BREAK;

                default:
                    return new Simple(val);
            }
        }
    }]);

    return Simple;
}();

module.exports = Simple;