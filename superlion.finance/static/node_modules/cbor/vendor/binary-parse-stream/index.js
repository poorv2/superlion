// Tweaked version of nathan7's binary-parse-stream
// (see https://github.com/nathan7/binary-parse-stream)
// Uses NoFilter instead of the readable in the original.  Removes
// the ability to read -1, which was odd and un-needed.
// License for binary-parse-stream: MIT
// binary-parse-stream is now unmaintained, so I'm going to rewrite it as
// more modern JS so I can get tsc to help check types.
'use strict';

var _regeneratorRuntime = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator");

var _classCallCheck = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck");

var _createClass = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass");

var _possibleConstructorReturn = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf");

var _inherits = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits");

var Stream = require('stream');

var NoFilter = require('nofilter');

var TransformStream = Stream.Transform;
/**
 * BinaryParseStream is a TransformStream that consumes buffers and outputs
 * objects on the other end.  It expects your subclass to implement a `_parse`
 * method that is a generator.  When your generator yields a number, it'll be
 * fed a buffer of that length from the input.  When your generator returns,
 * the return value will be pushed to the output side.
 *
 * @class BinaryParseStream
 * @extends {TransformStream}
 */

var BinaryParseStream = /*#__PURE__*/ function(_TransformStream) {
    _inherits(BinaryParseStream, _TransformStream);

    function BinaryParseStream(options) {
        var _this;

        _classCallCheck(this, BinaryParseStream);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(BinaryParseStream).call(this, options)); // doesn't work to pass these in as opts, for some reason

        _this['_writableState'].objectMode = false;
        _this['_readableState'].objectMode = true;
        _this.bs = new NoFilter();

        _this.__restart();

        return _this;
    }

    _createClass(BinaryParseStream, [{
        key: "_transform",
        value: function _transform(fresh, encoding, cb) {
            this.bs.write(fresh);

            while (this.bs.length >= this.__needed) {
                var ret = void 0;
                var chunk = this.__needed === null ? undefined : this.bs.read(this.__needed);

                try {
                    ret = this.__parser.next(chunk);
                } catch (e) {
                    return cb(e);
                }

                if (this.__needed) {
                    this.__fresh = false;
                }

                if (!ret.done) {
                    this.__needed = ret.value || 0;
                } else {
                    this.push(ret.value);

                    this.__restart();
                }
            }

            return cb();
        }
        /**
         * @abstract
         */

        /* istanbul ignore next */

    }, {
        key: "_parse",
        value: /*#__PURE__*/ _regeneratorRuntime.mark(function _parse() {
            return _regeneratorRuntime.wrap(function _parse$(_context) {
                while (1) {
                    switch (_context.prev = _context.next) {
                        case 0:
                            throw new Error('Must be implemented in subclass');

                        case 1:
                        case "end":
                            return _context.stop();
                    }
                }
            }, _parse);
        })
    }, {
        key: "__restart",
        value: function __restart() {
            this.__needed = null;
            this.__parser = this._parse();
            this.__fresh = true;
        }
    }, {
        key: "_flush",
        value: function _flush(cb) {
            cb(this.__fresh ? null : new Error('unexpected end of input'));
        }
    }]);

    return BinaryParseStream;
}(TransformStream);

module.exports = BinaryParseStream;