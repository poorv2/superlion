'use strict';

var _classCallCheck = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck");

var _createClass = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass");

var _possibleConstructorReturn = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf");

var _inherits = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits");

var Mixin = require('../../utils/mixin');

var Tokenizer = require('../../tokenizer');

var LocationInfoTokenizerMixin = require('./tokenizer-mixin');

var LocationInfoOpenElementStackMixin = require('./open-element-stack-mixin');

var HTML = require('../../common/html'); //Aliases


var $ = HTML.TAG_NAMES;

var LocationInfoParserMixin = /*#__PURE__*/ function(_Mixin) {
    _inherits(LocationInfoParserMixin, _Mixin);

    function LocationInfoParserMixin(parser) {
        var _this;

        _classCallCheck(this, LocationInfoParserMixin);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(LocationInfoParserMixin).call(this, parser));
        _this.parser = parser;
        _this.treeAdapter = _this.parser.treeAdapter;
        _this.posTracker = null;
        _this.lastStartTagToken = null;
        _this.lastFosterParentingLocation = null;
        _this.currentToken = null;
        return _this;
    }

    _createClass(LocationInfoParserMixin, [{
        key: "_setStartLocation",
        value: function _setStartLocation(element) {
            var loc = null;

            if (this.lastStartTagToken) {
                loc = Object.assign({}, this.lastStartTagToken.location);
                loc.startTag = this.lastStartTagToken.location;
            }

            this.treeAdapter.setNodeSourceCodeLocation(element, loc);
        }
    }, {
        key: "_setEndLocation",
        value: function _setEndLocation(element, closingToken) {
            var loc = this.treeAdapter.getNodeSourceCodeLocation(element);

            if (loc) {
                if (closingToken.location) {
                    var ctLoc = closingToken.location;
                    var tn = this.treeAdapter.getTagName(element); // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
                    // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.

                    var isClosingEndTag = closingToken.type === Tokenizer.END_TAG_TOKEN && tn === closingToken.tagName;
                    var endLoc = {};

                    if (isClosingEndTag) {
                        endLoc.endTag = Object.assign({}, ctLoc);
                        endLoc.endLine = ctLoc.endLine;
                        endLoc.endCol = ctLoc.endCol;
                        endLoc.endOffset = ctLoc.endOffset;
                    } else {
                        endLoc.endLine = ctLoc.startLine;
                        endLoc.endCol = ctLoc.startCol;
                        endLoc.endOffset = ctLoc.startOffset;
                    }

                    this.treeAdapter.updateNodeSourceCodeLocation(element, endLoc);
                }
            }
        }
    }, {
        key: "_getOverriddenMethods",
        value: function _getOverriddenMethods(mxn, orig) {
            return {
                _bootstrap: function _bootstrap(document, fragmentContext) {
                    orig._bootstrap.call(this, document, fragmentContext);

                    mxn.lastStartTagToken = null;
                    mxn.lastFosterParentingLocation = null;
                    mxn.currentToken = null;
                    var tokenizerMixin = Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);
                    mxn.posTracker = tokenizerMixin.posTracker;
                    Mixin.install(this.openElements, LocationInfoOpenElementStackMixin, {
                        onItemPop: function onItemPop(element) {
                            mxn._setEndLocation(element, mxn.currentToken);
                        }
                    });
                },
                _runParsingLoop: function _runParsingLoop(scriptHandler) {
                    orig._runParsingLoop.call(this, scriptHandler); // NOTE: generate location info for elements
                    // that remains on open element stack


                    for (var i = this.openElements.stackTop; i >= 0; i--) {
                        mxn._setEndLocation(this.openElements.items[i], mxn.currentToken);
                    }
                },
                //Token processing
                _processTokenInForeignContent: function _processTokenInForeignContent(token) {
                    mxn.currentToken = token;

                    orig._processTokenInForeignContent.call(this, token);
                },
                _processToken: function _processToken(token) {
                    mxn.currentToken = token;

                    orig._processToken.call(this, token); //NOTE: <body> and <html> are never popped from the stack, so we need to updated
                    //their end location explicitly.


                    var requireExplicitUpdate = token.type === Tokenizer.END_TAG_TOKEN && (token.tagName === $.HTML || token.tagName === $.BODY && this.openElements.hasInScope($.BODY));

                    if (requireExplicitUpdate) {
                        for (var i = this.openElements.stackTop; i >= 0; i--) {
                            var element = this.openElements.items[i];

                            if (this.treeAdapter.getTagName(element) === token.tagName) {
                                mxn._setEndLocation(element, token);

                                break;
                            }
                        }
                    }
                },
                //Doctype
                _setDocumentType: function _setDocumentType(token) {
                    orig._setDocumentType.call(this, token);

                    var documentChildren = this.treeAdapter.getChildNodes(this.document);
                    var cnLength = documentChildren.length;

                    for (var i = 0; i < cnLength; i++) {
                        var node = documentChildren[i];

                        if (this.treeAdapter.isDocumentTypeNode(node)) {
                            this.treeAdapter.setNodeSourceCodeLocation(node, token.location);
                            break;
                        }
                    }
                },
                //Elements
                _attachElementToTree: function _attachElementToTree(element) {
                    //NOTE: _attachElementToTree is called from _appendElement, _insertElement and _insertTemplate methods.
                    //So we will use token location stored in this methods for the element.
                    mxn._setStartLocation(element);

                    mxn.lastStartTagToken = null;

                    orig._attachElementToTree.call(this, element);
                },
                _appendElement: function _appendElement(token, namespaceURI) {
                    mxn.lastStartTagToken = token;

                    orig._appendElement.call(this, token, namespaceURI);
                },
                _insertElement: function _insertElement(token, namespaceURI) {
                    mxn.lastStartTagToken = token;

                    orig._insertElement.call(this, token, namespaceURI);
                },
                _insertTemplate: function _insertTemplate(token) {
                    mxn.lastStartTagToken = token;

                    orig._insertTemplate.call(this, token);

                    var tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);
                    this.treeAdapter.setNodeSourceCodeLocation(tmplContent, null);
                },
                _insertFakeRootElement: function _insertFakeRootElement() {
                    orig._insertFakeRootElement.call(this);

                    this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current, null);
                },
                //Comments
                _appendCommentNode: function _appendCommentNode(token, parent) {
                    orig._appendCommentNode.call(this, token, parent);

                    var children = this.treeAdapter.getChildNodes(parent);
                    var commentNode = children[children.length - 1];
                    this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);
                },
                //Text
                _findFosterParentingLocation: function _findFosterParentingLocation() {
                    //NOTE: store last foster parenting location, so we will be able to find inserted text
                    //in case of foster parenting
                    mxn.lastFosterParentingLocation = orig._findFosterParentingLocation.call(this);
                    return mxn.lastFosterParentingLocation;
                },
                _insertCharacters: function _insertCharacters(token) {
                    orig._insertCharacters.call(this, token);

                    var hasFosterParent = this._shouldFosterParentOnInsertion();

                    var parent = hasFosterParent && mxn.lastFosterParentingLocation.parent || this.openElements.currentTmplContent || this.openElements.current;
                    var siblings = this.treeAdapter.getChildNodes(parent);
                    var textNodeIdx = hasFosterParent && mxn.lastFosterParentingLocation.beforeElement ? siblings.indexOf(mxn.lastFosterParentingLocation.beforeElement) - 1 : siblings.length - 1;
                    var textNode = siblings[textNodeIdx]; //NOTE: if we have location assigned by another token, then just update end position

                    var tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);

                    if (tnLoc) {
                        var _token$location = token.location,
                            endLine = _token$location.endLine,
                            endCol = _token$location.endCol,
                            endOffset = _token$location.endOffset;
                        this.treeAdapter.updateNodeSourceCodeLocation(textNode, {
                            endLine: endLine,
                            endCol: endCol,
                            endOffset: endOffset
                        });
                    } else {
                        this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);
                    }
                }
            };
        }
    }]);

    return LocationInfoParserMixin;
}(Mixin);

module.exports = LocationInfoParserMixin;