/*
    This file is part of web3.js.
    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.
    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * @file ResolverMethodHandler.js
 *
 * @author Samuel Furter <samuel@ethereum.org>
 * @date 2018
 */
"use strict";

var _regeneratorRuntime = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator");

var _asyncToGenerator = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator");

var PromiEvent = require('web3-core-promievent');

var namehash = require('eth-ens-namehash');

var errors = require('web3-core-helpers').errors;

var _ = require('underscore');

var interfaceIds = require('../config').interfaceIds;
/**
 * @param {Registry} registry
 * @constructor
 */


function ResolverMethodHandler(registry) {
    this.registry = registry;
}
/**
 * Executes an resolver method and returns an eventifiedPromise
 *
 * @param {string} ensName
 * @param {string} methodName
 * @param {array} methodArguments
 * @param {function} callback
 * @returns {Object}
 */


ResolverMethodHandler.prototype.method = function(ensName, methodName, methodArguments, outputFormatter, callback) {
    return {
        call: this.call.bind({
            ensName: ensName,
            methodName: methodName,
            methodArguments: methodArguments,
            callback: callback,
            parent: this,
            outputFormatter: outputFormatter
        }),
        send: this.send.bind({
            ensName: ensName,
            methodName: methodName,
            methodArguments: methodArguments,
            callback: callback,
            parent: this
        })
    };
};
/**
 * Executes call
 *
 * @returns {eventifiedPromise}
 */


ResolverMethodHandler.prototype.call = function(callback) {
    var self = this;
    var promiEvent = new PromiEvent();
    var preparedArguments = this.parent.prepareArguments(this.ensName, this.methodArguments);
    var outputFormatter = this.outputFormatter || null;
    this.parent.registry.getResolver(this.ensName).then( /*#__PURE__*/ function() {
        var _ref = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee(resolver) {
            return _regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                    switch (_context.prev = _context.next) {
                        case 0:
                            _context.next = 2;
                            return self.parent.checkInterfaceSupport(resolver, self.methodName);

                        case 2:
                            self.parent.handleCall(promiEvent, resolver.methods[self.methodName], preparedArguments, outputFormatter, callback);

                        case 3:
                        case "end":
                            return _context.stop();
                    }
                }
            }, _callee);
        }));

        return function(_x) {
            return _ref.apply(this, arguments);
        };
    }()).catch(function(error) {
        if (_.isFunction(callback)) {
            callback(error, null);
            return;
        }

        promiEvent.reject(error);
    });
    return promiEvent.eventEmitter;
};
/**
 * Executes send
 *
 * @param {Object} sendOptions
 * @param {function} callback
 * @returns {eventifiedPromise}
 */


ResolverMethodHandler.prototype.send = function(sendOptions, callback) {
    var self = this;
    var promiEvent = new PromiEvent();
    var preparedArguments = this.parent.prepareArguments(this.ensName, this.methodArguments);
    this.parent.registry.getResolver(this.ensName).then( /*#__PURE__*/ function() {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee2(resolver) {
            return _regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                    switch (_context2.prev = _context2.next) {
                        case 0:
                            _context2.next = 2;
                            return self.parent.checkInterfaceSupport(resolver, self.methodName);

                        case 2:
                            self.parent.handleSend(promiEvent, resolver.methods[self.methodName], preparedArguments, sendOptions, callback);

                        case 3:
                        case "end":
                            return _context2.stop();
                    }
                }
            }, _callee2);
        }));

        return function(_x2) {
            return _ref2.apply(this, arguments);
        };
    }()).catch(function(error) {
        if (_.isFunction(callback)) {
            callback(error, null);
            return;
        }

        promiEvent.reject(error);
    });
    return promiEvent.eventEmitter;
};
/**
 * Handles a call method
 *
 * @param {eventifiedPromise} promiEvent
 * @param {function} method
 * @param {array} preparedArguments
 * @param {function} callback
 * @returns {eventifiedPromise}
 */


ResolverMethodHandler.prototype.handleCall = function(promiEvent, method, preparedArguments, outputFormatter, callback) {
    method.apply(this, preparedArguments).call().then(function(result) {
        if (outputFormatter) {
            result = outputFormatter(result);
        }

        if (_.isFunction(callback)) {
            // It's required to pass the receipt to the second argument to be backwards compatible and to have the required consistency
            callback(result, result);
            return;
        }

        promiEvent.resolve(result);
    }).catch(function(error) {
        if (_.isFunction(callback)) {
            callback(error, null);
            return;
        }

        promiEvent.reject(error);
    });
    return promiEvent;
};
/**
 * Handles a send method
 *
 * @param {eventifiedPromise} promiEvent
 * @param {function} method
 * @param {array} preparedArguments
 * @param {Object} sendOptions
 * @param {function} callback
 * @returns {eventifiedPromise}
 */


ResolverMethodHandler.prototype.handleSend = function(promiEvent, method, preparedArguments, sendOptions, callback) {
    method.apply(this, preparedArguments).send(sendOptions).on('sending', function() {
        promiEvent.eventEmitter.emit('sending');
    }).on('sent', function() {
        promiEvent.eventEmitter.emit('sent');
    }).on('transactionHash', function(hash) {
        promiEvent.eventEmitter.emit('transactionHash', hash);
    }).on('confirmation', function(confirmationNumber, receipt) {
        promiEvent.eventEmitter.emit('confirmation', confirmationNumber, receipt);
    }).on('receipt', function(receipt) {
        promiEvent.eventEmitter.emit('receipt', receipt);
        promiEvent.resolve(receipt);

        if (_.isFunction(callback)) {
            // It's required to pass the receipt to the second argument to be backwards compatible and to have the required consistency
            callback(receipt, receipt);
        }
    }).on('error', function(error) {
        promiEvent.eventEmitter.emit('error', error);

        if (_.isFunction(callback)) {
            callback(error, null);
            return;
        }

        promiEvent.reject(error);
    });
    return promiEvent;
};
/**
 * Adds the ENS node to the arguments
 *
 * @param {string} name
 * @param {array} methodArguments
 *
 * @returns {array}
 */


ResolverMethodHandler.prototype.prepareArguments = function(name, methodArguments) {
    var node = namehash.hash(name);

    if (methodArguments.length > 0) {
        methodArguments.unshift(node);
        return methodArguments;
    }

    return [node];
};
/**
 *
 *
 * @param {Contract} resolver
 * @param {string} methodName
 *
 * @returns {Promise}
 */


ResolverMethodHandler.prototype.checkInterfaceSupport = /*#__PURE__*/ function() {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee3(resolver, methodName) {
        var supported;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
                switch (_context3.prev = _context3.next) {
                    case 0:
                        if (interfaceIds[methodName]) {
                            _context3.next = 2;
                            break;
                        }

                        return _context3.abrupt("return");

                    case 2:
                        supported = false;
                        _context3.prev = 3;
                        _context3.next = 6;
                        return resolver.methods.supportsInterface(interfaceIds[methodName]).call();

                    case 6:
                        supported = _context3.sent;
                        _context3.next = 12;
                        break;

                    case 9:
                        _context3.prev = 9;
                        _context3.t0 = _context3["catch"](3);
                        console.warn('Could not verify interface of resolver contract at "' + resolver.options.address + '". ');

                    case 12:
                        if (supported) {
                            _context3.next = 14;
                            break;
                        }

                        throw errors.ResolverMethodMissingError(resolver.options.address, methodName);

                    case 14:
                    case "end":
                        return _context3.stop();
                }
            }
        }, _callee3, null, [
            [3, 9]
        ]);
    }));

    return function(_x3, _x4) {
        return _ref3.apply(this, arguments);
    };
}();

module.exports = ResolverMethodHandler;