"use strict";

var _slicedToArray = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray");

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ethErrors = void 0;

var classes_1 = require("./classes");

var utils_1 = require("./utils");

var error_constants_1 = require("./error-constants");

exports.ethErrors = {
    rpc: {
        /**
         * Get a JSON RPC 2.0 Parse (-32700) error.
         */
        parse: function parse(arg) {
            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.parse, arg);
        },

        /**
         * Get a JSON RPC 2.0 Invalid Request (-32600) error.
         */
        invalidRequest: function invalidRequest(arg) {
            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidRequest, arg);
        },

        /**
         * Get a JSON RPC 2.0 Invalid Params (-32602) error.
         */
        invalidParams: function invalidParams(arg) {
            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidParams, arg);
        },

        /**
         * Get a JSON RPC 2.0 Method Not Found (-32601) error.
         */
        methodNotFound: function methodNotFound(arg) {
            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotFound, arg);
        },

        /**
         * Get a JSON RPC 2.0 Internal (-32603) error.
         */
        internal: function internal(arg) {
            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.internal, arg);
        },

        /**
         * Get a JSON RPC 2.0 Server error.
         * Permits integer error codes in the [ -32099 <= -32005 ] range.
         * Codes -32000 through -32004 are reserved by EIP-1474.
         */
        server: function server(opts) {
            if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {
                throw new Error('Ethereum RPC Server errors must provide single object argument.');
            }

            var code = opts.code;

            if (!Number.isInteger(code) || code > -32005 || code < -32099) {
                throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
            }

            return getEthJsonRpcError(code, opts);
        },

        /**
         * Get an Ethereum JSON RPC Invalid Input (-32000) error.
         */
        invalidInput: function invalidInput(arg) {
            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.invalidInput, arg);
        },

        /**
         * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
         */
        resourceNotFound: function resourceNotFound(arg) {
            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceNotFound, arg);
        },

        /**
         * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
         */
        resourceUnavailable: function resourceUnavailable(arg) {
            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.resourceUnavailable, arg);
        },

        /**
         * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
         */
        transactionRejected: function transactionRejected(arg) {
            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.transactionRejected, arg);
        },

        /**
         * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
         */
        methodNotSupported: function methodNotSupported(arg) {
            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.methodNotSupported, arg);
        },

        /**
         * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
         */
        limitExceeded: function limitExceeded(arg) {
            return getEthJsonRpcError(error_constants_1.errorCodes.rpc.limitExceeded, arg);
        }
    },
    provider: {
        /**
         * Get an Ethereum Provider User Rejected Request (4001) error.
         */
        userRejectedRequest: function userRejectedRequest(arg) {
            return getEthProviderError(error_constants_1.errorCodes.provider.userRejectedRequest, arg);
        },

        /**
         * Get an Ethereum Provider Unauthorized (4100) error.
         */
        unauthorized: function unauthorized(arg) {
            return getEthProviderError(error_constants_1.errorCodes.provider.unauthorized, arg);
        },

        /**
         * Get an Ethereum Provider Unsupported Method (4200) error.
         */
        unsupportedMethod: function unsupportedMethod(arg) {
            return getEthProviderError(error_constants_1.errorCodes.provider.unsupportedMethod, arg);
        },

        /**
         * Get an Ethereum Provider Not Connected (4900) error.
         */
        disconnected: function disconnected(arg) {
            return getEthProviderError(error_constants_1.errorCodes.provider.disconnected, arg);
        },

        /**
         * Get an Ethereum Provider Chain Not Connected (4901) error.
         */
        chainDisconnected: function chainDisconnected(arg) {
            return getEthProviderError(error_constants_1.errorCodes.provider.chainDisconnected, arg);
        },

        /**
         * Get a custom Ethereum Provider error.
         */
        custom: function custom(opts) {
            if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {
                throw new Error('Ethereum Provider custom errors must provide single object argument.');
            }

            var code = opts.code,
                message = opts.message,
                data = opts.data;

            if (!message || typeof message !== 'string') {
                throw new Error('"message" must be a nonempty string');
            }

            return new classes_1.EthereumProviderError(code, message, data);
        }
    }
}; // Internal

function getEthJsonRpcError(code, arg) {
    var _parseOpts = parseOpts(arg),
        _parseOpts2 = _slicedToArray(_parseOpts, 2),
        message = _parseOpts2[0],
        data = _parseOpts2[1];

    return new classes_1.EthereumRpcError(code, message || utils_1.getMessageFromCode(code), data);
}

function getEthProviderError(code, arg) {
    var _parseOpts3 = parseOpts(arg),
        _parseOpts4 = _slicedToArray(_parseOpts3, 2),
        message = _parseOpts4[0],
        data = _parseOpts4[1];

    return new classes_1.EthereumProviderError(code, message || utils_1.getMessageFromCode(code), data);
}

function parseOpts(arg) {
    if (arg) {
        if (typeof arg === 'string') {
            return [arg];
        } else if (typeof arg === 'object' && !Array.isArray(arg)) {
            var message = arg.message,
                data = arg.data;

            if (message && typeof message !== 'string') {
                throw new Error('Must specify string message.');
            }

            return [message || undefined, data];
        }
    }

    return [];
}