"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.serializeError = exports.isValidCode = exports.getMessageFromCode = exports.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;

var error_constants_1 = require("./error-constants");

var classes_1 = require("./classes");

var FALLBACK_ERROR_CODE = error_constants_1.errorCodes.rpc.internal;
var FALLBACK_MESSAGE = 'Unspecified error message. This is a bug, please report it.';
var FALLBACK_ERROR = {
    code: FALLBACK_ERROR_CODE,
    message: getMessageFromCode(FALLBACK_ERROR_CODE)
};
exports.JSON_RPC_SERVER_ERROR_MESSAGE = 'Unspecified server error.';
/**
 * Gets the message for a given code, or a fallback message if the code has
 * no corresponding message.
 */

function getMessageFromCode(code) {
    var fallbackMessage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FALLBACK_MESSAGE;

    if (Number.isInteger(code)) {
        var codeString = code.toString();

        if (hasKey(error_constants_1.errorValues, codeString)) {
            return error_constants_1.errorValues[codeString].message;
        }

        if (isJsonRpcServerError(code)) {
            return exports.JSON_RPC_SERVER_ERROR_MESSAGE;
        }
    }

    return fallbackMessage;
}

exports.getMessageFromCode = getMessageFromCode;
/**
 * Returns whether the given code is valid.
 * A code is only valid if it has a message.
 */

function isValidCode(code) {
    if (!Number.isInteger(code)) {
        return false;
    }

    var codeString = code.toString();

    if (error_constants_1.errorValues[codeString]) {
        return true;
    }

    if (isJsonRpcServerError(code)) {
        return true;
    }

    return false;
}

exports.isValidCode = isValidCode;
/**
 * Serializes the given error to an Ethereum JSON RPC-compatible error object.
 * Merely copies the given error's values if it is already compatible.
 * If the given error is not fully compatible, it will be preserved on the
 * returned object's data.originalError property.
 */

function serializeError(error) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$fallbackError = _ref.fallbackError,
        fallbackError = _ref$fallbackError === void 0 ? FALLBACK_ERROR : _ref$fallbackError,
        _ref$shouldIncludeSta = _ref.shouldIncludeStack,
        shouldIncludeStack = _ref$shouldIncludeSta === void 0 ? false : _ref$shouldIncludeSta;

    var _a, _b;

    if (!fallbackError || !Number.isInteger(fallbackError.code) || typeof fallbackError.message !== 'string') {
        throw new Error('Must provide fallback error with integer number code and string message.');
    }

    if (error instanceof classes_1.EthereumRpcError) {
        return error.serialize();
    }

    var serialized = {};

    if (error && typeof error === 'object' && !Array.isArray(error) && hasKey(error, 'code') && isValidCode(error.code)) {
        var _error = error;
        serialized.code = _error.code;

        if (_error.message && typeof _error.message === 'string') {
            serialized.message = _error.message;

            if (hasKey(_error, 'data')) {
                serialized.data = _error.data;
            }
        } else {
            serialized.message = getMessageFromCode(serialized.code);
            serialized.data = {
                originalError: assignOriginalError(error)
            };
        }
    } else {
        serialized.code = fallbackError.code;
        var message = (_a = error) === null || _a === void 0 ? void 0 : _a.message;
        serialized.message = message && typeof message === 'string' ? message : fallbackError.message;
        serialized.data = {
            originalError: assignOriginalError(error)
        };
    }

    var stack = (_b = error) === null || _b === void 0 ? void 0 : _b.stack;

    if (shouldIncludeStack && error && stack && typeof stack === 'string') {
        serialized.stack = stack;
    }

    return serialized;
}

exports.serializeError = serializeError; // Internal

function isJsonRpcServerError(code) {
    return code >= -32099 && code <= -32000;
}

function assignOriginalError(error) {
    if (error && typeof error === 'object' && !Array.isArray(error)) {
        return Object.assign({}, error);
    }

    return error;
}

function hasKey(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}