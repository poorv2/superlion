"use strict";

var _regeneratorRuntime = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator");

var _asyncToGenerator = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator");

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createAsyncMiddleware = void 0;
/**
 * JsonRpcEngine only accepts callback-based middleware directly.
 * createAsyncMiddleware exists to enable consumers to pass in async middleware
 * functions.
 *
 * Async middleware have no "end" function. Instead, they "end" if they return
 * without calling "next". Rather than passing in explicit return handlers,
 * async middleware can simply await "next", and perform operations on the
 * response object when execution resumes.
 *
 * To accomplish this, createAsyncMiddleware passes the async middleware a
 * wrapped "next" function. That function calls the internal JsonRpcEngine
 * "next" function with a return handler that resolves a promise when called.
 *
 * The return handler will always be called. Its resolution of the promise
 * enables the control flow described above.
 */

function createAsyncMiddleware(asyncMiddleware) {
    return /*#__PURE__*/ function() {
        var _ref = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee2(req, res, next, end) {
            var resolveNextPromise, nextPromise, returnHandlerCallback, nextWasCalled, asyncNext;
            return _regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                    switch (_context2.prev = _context2.next) {
                        case 0:
                            // nextPromise is the key to the implementation
                            // it is resolved by the return handler passed to the
                            // "next" function
                            nextPromise = new Promise(function(resolve) {
                                resolveNextPromise = resolve;
                            });
                            returnHandlerCallback = null;
                            nextWasCalled = false; // This will be called by the consumer's async middleware.

                            asyncNext = /*#__PURE__*/ function() {
                                var _ref2 = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee() {
                                    return _regeneratorRuntime.wrap(function _callee$(_context) {
                                        while (1) {
                                            switch (_context.prev = _context.next) {
                                                case 0:
                                                    nextWasCalled = true; // We pass a return handler to next(). When it is called by the engine,
                                                    // the consumer's async middleware will resume executing.
                                                    // eslint-disable-next-line node/callback-return

                                                    next(function(runReturnHandlersCallback) {
                                                        // This callback comes from JsonRpcEngine._runReturnHandlers
                                                        returnHandlerCallback = runReturnHandlersCallback;
                                                        resolveNextPromise();
                                                    });
                                                    _context.next = 4;
                                                    return nextPromise;

                                                case 4:
                                                case "end":
                                                    return _context.stop();
                                            }
                                        }
                                    }, _callee);
                                }));

                                return function asyncNext() {
                                    return _ref2.apply(this, arguments);
                                };
                            }();

                            _context2.prev = 4;
                            _context2.next = 7;
                            return asyncMiddleware(req, res, asyncNext);

                        case 7:
                            if (!nextWasCalled) {
                                _context2.next = 13;
                                break;
                            }

                            _context2.next = 10;
                            return nextPromise;

                        case 10:
                            // we must wait until the return handler is called
                            returnHandlerCallback(null);
                            _context2.next = 14;
                            break;

                        case 13:
                            end(null);

                        case 14:
                            _context2.next = 19;
                            break;

                        case 16:
                            _context2.prev = 16;
                            _context2.t0 = _context2["catch"](4);

                            if (returnHandlerCallback) {
                                returnHandlerCallback(_context2.t0);
                            } else {
                                end(_context2.t0);
                            }

                        case 19:
                        case "end":
                            return _context2.stop();
                    }
                }
            }, _callee2, null, [
                [4, 16]
            ]);
        }));

        return function(_x, _x2, _x3, _x4) {
            return _ref.apply(this, arguments);
        };
    }();
}

exports.createAsyncMiddleware = createAsyncMiddleware;