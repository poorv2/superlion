var _regeneratorRuntime = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator");

var _asyncToGenerator = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator");

var SafeEventEmitter = require('@metamask/safe-event-emitter').default;

var createScaffoldMiddleware = require('eth-json-rpc-middleware/scaffold');

var _require = require('json-rpc-engine'),
    createAsyncMiddleware = _require.createAsyncMiddleware;

var createFilterMiddleware = require('./index.js');

var _require2 = require('./hexUtils.js'),
    unsafeRandomBytes = _require2.unsafeRandomBytes,
    incrementHexInt = _require2.incrementHexInt;

var getBlocksForRange = require('./getBlocksForRange.js');

module.exports = createSubscriptionMiddleware;

function createSubscriptionMiddleware(_ref) {
    var blockTracker = _ref.blockTracker,
        provider = _ref.provider;
    // state and utilities for handling subscriptions
    var subscriptions = {};
    var filterManager = createFilterMiddleware({
        blockTracker: blockTracker,
        provider: provider
    }); // internal flag

    var isDestroyed = false; // create subscriptionManager api object

    var events = new SafeEventEmitter();
    var middleware = createScaffoldMiddleware({
        eth_subscribe: createAsyncMiddleware(subscribe),
        eth_unsubscribe: createAsyncMiddleware(unsubscribe)
    });
    middleware.destroy = destroy;
    return {
        events: events,
        middleware: middleware
    };

    function subscribe(_x, _x2) {
        return _subscribe.apply(this, arguments);
    }

    function _subscribe() {
        _subscribe = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee4(req, res) {
            var subscriptionType, subId, sub, filterParams, filter, createSubNewHeads, createSubFromFilter;
            return _regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) {
                    switch (_context4.prev = _context4.next) {
                        case 0:
                            createSubFromFilter = function _createSubFromFilter(_ref4) {
                                var subId = _ref4.subId,
                                    filter = _ref4.filter;
                                filter.on('update', function(result) {
                                    return _emitSubscriptionResult(subId, result);
                                });
                                var sub = {
                                    type: subscriptionType,
                                    destroy: function() {
                                        var _destroy2 = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee3() {
                                            return _regeneratorRuntime.wrap(function _callee3$(_context3) {
                                                while (1) {
                                                    switch (_context3.prev = _context3.next) {
                                                        case 0:
                                                            _context3.next = 2;
                                                            return filterManager.uninstallFilter(filter.idHex);

                                                        case 2:
                                                            return _context3.abrupt("return", _context3.sent);

                                                        case 3:
                                                        case "end":
                                                            return _context3.stop();
                                                    }
                                                }
                                            }, _callee3);
                                        }));

                                        function destroy() {
                                            return _destroy2.apply(this, arguments);
                                        }

                                        return destroy;
                                    }()
                                };
                                return sub;
                            };

                            createSubNewHeads = function _createSubNewHeads(_ref2) {
                                var subId = _ref2.subId;
                                var sub = {
                                    type: subscriptionType,
                                    destroy: function() {
                                        var _destroy = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee() {
                                            return _regeneratorRuntime.wrap(function _callee$(_context) {
                                                while (1) {
                                                    switch (_context.prev = _context.next) {
                                                        case 0:
                                                            blockTracker.removeListener('sync', sub.update);

                                                        case 1:
                                                        case "end":
                                                            return _context.stop();
                                                    }
                                                }
                                            }, _callee);
                                        }));

                                        function destroy() {
                                            return _destroy.apply(this, arguments);
                                        }

                                        return destroy;
                                    }(),
                                    update: function() {
                                        var _update = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee2(_ref3) {
                                            var oldBlock, newBlock, toBlock, fromBlock, rawBlocks, results;
                                            return _regeneratorRuntime.wrap(function _callee2$(_context2) {
                                                while (1) {
                                                    switch (_context2.prev = _context2.next) {
                                                        case 0:
                                                            oldBlock = _ref3.oldBlock, newBlock = _ref3.newBlock;
                                                            // for newHeads
                                                            toBlock = newBlock;
                                                            fromBlock = incrementHexInt(oldBlock);
                                                            _context2.next = 5;
                                                            return getBlocksForRange({
                                                                provider: provider,
                                                                fromBlock: fromBlock,
                                                                toBlock: toBlock
                                                            });

                                                        case 5:
                                                            rawBlocks = _context2.sent;
                                                            results = rawBlocks.map(normalizeBlock);
                                                            results.forEach(function(value) {
                                                                _emitSubscriptionResult(subId, value);
                                                            });

                                                        case 8:
                                                        case "end":
                                                            return _context2.stop();
                                                    }
                                                }
                                            }, _callee2);
                                        }));

                                        function update(_x5) {
                                            return _update.apply(this, arguments);
                                        }

                                        return update;
                                    }()
                                }; // check for subscription updates on new block

                                blockTracker.on('sync', sub.update);
                                return sub;
                            };

                            if (!isDestroyed) {
                                _context4.next = 4;
                                break;
                            }

                            throw new Error('SubscriptionManager - attempting to use after destroying');

                        case 4:
                            subscriptionType = req.params[0]; // subId is 16 byte hex string

                            subId = unsafeRandomBytes(16); // create sub

                            _context4.t0 = subscriptionType;
                            _context4.next = _context4.t0 === 'newHeads' ? 9 : _context4.t0 === 'logs' ? 11 : 17;
                            break;

                        case 9:
                            sub = createSubNewHeads({
                                subId: subId
                            });
                            return _context4.abrupt("break", 18);

                        case 11:
                            filterParams = req.params[1];
                            _context4.next = 14;
                            return filterManager.newLogFilter(filterParams);

                        case 14:
                            filter = _context4.sent;
                            sub = createSubFromFilter({
                                subId: subId,
                                filter: filter
                            });
                            return _context4.abrupt("break", 18);

                        case 17:
                            throw new Error("SubscriptionManager - unsupported subscription type \"".concat(subscriptionType, "\""));

                        case 18:
                            subscriptions[subId] = sub;
                            res.result = subId;
                            return _context4.abrupt("return");

                        case 21:
                        case "end":
                            return _context4.stop();
                    }
                }
            }, _callee4);
        }));
        return _subscribe.apply(this, arguments);
    }

    function unsubscribe(_x3, _x4) {
        return _unsubscribe.apply(this, arguments);
    }

    function _unsubscribe() {
        _unsubscribe = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee5(req, res) {
            var id, subscription;
            return _regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) {
                    switch (_context5.prev = _context5.next) {
                        case 0:
                            if (!isDestroyed) {
                                _context5.next = 2;
                                break;
                            }

                            throw new Error('SubscriptionManager - attempting to use after destroying');

                        case 2:
                            id = req.params[0];
                            subscription = subscriptions[id]; // if missing, return "false" to indicate it was not removed

                            if (subscription) {
                                _context5.next = 7;
                                break;
                            }

                            res.result = false;
                            return _context5.abrupt("return");

                        case 7:
                            // cleanup subscription
                            delete subscriptions[id];
                            _context5.next = 10;
                            return subscription.destroy();

                        case 10:
                            res.result = true;

                        case 11:
                        case "end":
                            return _context5.stop();
                    }
                }
            }, _callee5);
        }));
        return _unsubscribe.apply(this, arguments);
    }

    function _emitSubscriptionResult(filterIdHex, value) {
        events.emit('notification', {
            jsonrpc: '2.0',
            method: 'eth_subscription',
            params: {
                subscription: filterIdHex,
                result: value
            }
        });
    }

    function destroy() {
        events.removeAllListeners();

        for (var id in subscriptions) {
            subscriptions[id].destroy();
            delete subscriptions[id];
        }

        isDestroyed = true;
    }
}

function normalizeBlock(block) {
    return {
        hash: block.hash,
        parentHash: block.parentHash,
        sha3Uncles: block.sha3Uncles,
        miner: block.miner,
        stateRoot: block.stateRoot,
        transactionsRoot: block.transactionsRoot,
        receiptsRoot: block.receiptsRoot,
        logsBloom: block.logsBloom,
        difficulty: block.difficulty,
        number: block.number,
        gasLimit: block.gasLimit,
        gasUsed: block.gasUsed,
        nonce: block.nonce,
        mixHash: block.mixHash,
        timestamp: block.timestamp,
        extraData: block.extraData
    };
}