'use strict';

var _regeneratorRuntime = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator");

var _objectSpread = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread");

var _asyncToGenerator = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator");

function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {};
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true,
        didErr = false,
        err;
    return {
        s: function s() {
            it = o[Symbol.iterator]();
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally {
                if (didErr) throw err;
            }
        }
    };
}

function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
    }
    return arr2;
}

var path = require('path');

var fs = require('fs');

var _require = require('util'),
    promisify = _require.promisify;

var pLocate = require('p-locate');

var fsStat = promisify(fs.stat);
var fsLStat = promisify(fs.lstat);
var typeMappings = {
    directory: 'isDirectory',
    file: 'isFile'
};

function checkType(_ref) {
    var type = _ref.type;

    if (type in typeMappings) {
        return;
    }

    throw new Error("Invalid type specified: ".concat(type));
}

var matchType = function matchType(type, stat) {
    return type === undefined || stat[typeMappings[type]]();
};

module.exports = /*#__PURE__*/ function() {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee2(paths, options) {
        var statFn;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
                switch (_context2.prev = _context2.next) {
                    case 0:
                        options = _objectSpread({
                            cwd: process.cwd(),
                            type: 'file',
                            allowSymlinks: true
                        }, options);
                        checkType(options);
                        statFn = options.allowSymlinks ? fsStat : fsLStat;
                        return _context2.abrupt("return", pLocate(paths, /*#__PURE__*/ function() {
                            var _ref3 = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee(path_) {
                                var stat;
                                return _regeneratorRuntime.wrap(function _callee$(_context) {
                                    while (1) {
                                        switch (_context.prev = _context.next) {
                                            case 0:
                                                _context.prev = 0;
                                                _context.next = 3;
                                                return statFn(path.resolve(options.cwd, path_));

                                            case 3:
                                                stat = _context.sent;
                                                return _context.abrupt("return", matchType(options.type, stat));

                                            case 7:
                                                _context.prev = 7;
                                                _context.t0 = _context["catch"](0);
                                                return _context.abrupt("return", false);

                                            case 10:
                                            case "end":
                                                return _context.stop();
                                        }
                                    }
                                }, _callee, null, [
                                    [0, 7]
                                ]);
                            }));

                            return function(_x3) {
                                return _ref3.apply(this, arguments);
                            };
                        }(), options));

                    case 4:
                    case "end":
                        return _context2.stop();
                }
            }
        }, _callee2);
    }));

    return function(_x, _x2) {
        return _ref2.apply(this, arguments);
    };
}();

module.exports.sync = function(paths, options) {
    options = _objectSpread({
        cwd: process.cwd(),
        allowSymlinks: true,
        type: 'file'
    }, options);
    checkType(options);
    var statFn = options.allowSymlinks ? fs.statSync : fs.lstatSync;

    var _iterator = _createForOfIteratorHelper(paths),
        _step;

    try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var path_ = _step.value;

            try {
                var stat = statFn(path.resolve(options.cwd, path_));

                if (matchType(options.type, stat)) {
                    return path_;
                }
            } catch (_) {}
        }
    } catch (err) {
        _iterator.e(err);
    } finally {
        _iterator.f();
    }
};