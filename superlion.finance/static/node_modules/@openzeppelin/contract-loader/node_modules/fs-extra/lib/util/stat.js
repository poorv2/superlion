'use strict';

var fs = require('graceful-fs');

var path = require('path');

var NODE_VERSION_MAJOR_WITH_BIGINT = 10;
var NODE_VERSION_MINOR_WITH_BIGINT = 5;
var NODE_VERSION_PATCH_WITH_BIGINT = 0;
var nodeVersion = process.versions.node.split('.');
var nodeVersionMajor = Number.parseInt(nodeVersion[0], 10);
var nodeVersionMinor = Number.parseInt(nodeVersion[1], 10);
var nodeVersionPatch = Number.parseInt(nodeVersion[2], 10);

function nodeSupportsBigInt() {
    if (nodeVersionMajor > NODE_VERSION_MAJOR_WITH_BIGINT) {
        return true;
    } else if (nodeVersionMajor === NODE_VERSION_MAJOR_WITH_BIGINT) {
        if (nodeVersionMinor > NODE_VERSION_MINOR_WITH_BIGINT) {
            return true;
        } else if (nodeVersionMinor === NODE_VERSION_MINOR_WITH_BIGINT) {
            if (nodeVersionPatch >= NODE_VERSION_PATCH_WITH_BIGINT) {
                return true;
            }
        }
    }

    return false;
}

function getStats(src, dest, cb) {
    if (nodeSupportsBigInt()) {
        fs.stat(src, {
            bigint: true
        }, function(err, srcStat) {
            if (err) return cb(err);
            fs.stat(dest, {
                bigint: true
            }, function(err, destStat) {
                if (err) {
                    if (err.code === 'ENOENT') return cb(null, {
                        srcStat: srcStat,
                        destStat: null
                    });
                    return cb(err);
                }

                return cb(null, {
                    srcStat: srcStat,
                    destStat: destStat
                });
            });
        });
    } else {
        fs.stat(src, function(err, srcStat) {
            if (err) return cb(err);
            fs.stat(dest, function(err, destStat) {
                if (err) {
                    if (err.code === 'ENOENT') return cb(null, {
                        srcStat: srcStat,
                        destStat: null
                    });
                    return cb(err);
                }

                return cb(null, {
                    srcStat: srcStat,
                    destStat: destStat
                });
            });
        });
    }
}

function getStatsSync(src, dest) {
    var srcStat, destStat;

    if (nodeSupportsBigInt()) {
        srcStat = fs.statSync(src, {
            bigint: true
        });
    } else {
        srcStat = fs.statSync(src);
    }

    try {
        if (nodeSupportsBigInt()) {
            destStat = fs.statSync(dest, {
                bigint: true
            });
        } else {
            destStat = fs.statSync(dest);
        }
    } catch (err) {
        if (err.code === 'ENOENT') return {
            srcStat: srcStat,
            destStat: null
        };
        throw err;
    }

    return {
        srcStat: srcStat,
        destStat: destStat
    };
}

function checkPaths(src, dest, funcName, cb) {
    getStats(src, dest, function(err, stats) {
        if (err) return cb(err);
        var srcStat = stats.srcStat,
            destStat = stats.destStat;

        if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
            return cb(new Error('Source and destination must not be the same.'));
        }

        if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
            return cb(new Error(errMsg(src, dest, funcName)));
        }

        return cb(null, {
            srcStat: srcStat,
            destStat: destStat
        });
    });
}

function checkPathsSync(src, dest, funcName) {
    var _getStatsSync = getStatsSync(src, dest),
        srcStat = _getStatsSync.srcStat,
        destStat = _getStatsSync.destStat;

    if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
        throw new Error('Source and destination must not be the same.');
    }

    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
    }

    return {
        srcStat: srcStat,
        destStat: destStat
    };
} // recursively check if dest parent is a subdirectory of src.
// It works for all file types including symlinks since it
// checks the src and dest inodes. It starts from the deepest
// parent and stops once it reaches the src parent or the root path.


function checkParentPaths(src, srcStat, dest, funcName, cb) {
    var srcParent = path.resolve(path.dirname(src));
    var destParent = path.resolve(path.dirname(dest));
    if (destParent === srcParent || destParent === path.parse(destParent).root) return cb();

    if (nodeSupportsBigInt()) {
        fs.stat(destParent, {
            bigint: true
        }, function(err, destStat) {
            if (err) {
                if (err.code === 'ENOENT') return cb();
                return cb(err);
            }

            if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
                return cb(new Error(errMsg(src, dest, funcName)));
            }

            return checkParentPaths(src, srcStat, destParent, funcName, cb);
        });
    } else {
        fs.stat(destParent, function(err, destStat) {
            if (err) {
                if (err.code === 'ENOENT') return cb();
                return cb(err);
            }

            if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
                return cb(new Error(errMsg(src, dest, funcName)));
            }

            return checkParentPaths(src, srcStat, destParent, funcName, cb);
        });
    }
}

function checkParentPathsSync(src, srcStat, dest, funcName) {
    var srcParent = path.resolve(path.dirname(src));
    var destParent = path.resolve(path.dirname(dest));
    if (destParent === srcParent || destParent === path.parse(destParent).root) return;
    var destStat;

    try {
        if (nodeSupportsBigInt()) {
            destStat = fs.statSync(destParent, {
                bigint: true
            });
        } else {
            destStat = fs.statSync(destParent);
        }
    } catch (err) {
        if (err.code === 'ENOENT') return;
        throw err;
    }

    if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
        throw new Error(errMsg(src, dest, funcName));
    }

    return checkParentPathsSync(src, srcStat, destParent, funcName);
} // return true if dest is a subdir of src, otherwise false.
// It only checks the path strings.


function isSrcSubdir(src, dest) {
    var srcArr = path.resolve(src).split(path.sep).filter(function(i) {
        return i;
    });
    var destArr = path.resolve(dest).split(path.sep).filter(function(i) {
        return i;
    });
    return srcArr.reduce(function(acc, cur, i) {
        return acc && destArr[i] === cur;
    }, true);
}

function errMsg(src, dest, funcName) {
    return "Cannot ".concat(funcName, " '").concat(src, "' to a subdirectory of itself, '").concat(dest, "'.");
}

module.exports = {
    checkPaths: checkPaths,
    checkPathsSync: checkPathsSync,
    checkParentPaths: checkParentPaths,
    checkParentPathsSync: checkParentPathsSync,
    isSrcSubdir: isSrcSubdir
};