var _toConsumableArray = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray");

var _regeneratorRuntime = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator");

var _asyncToGenerator = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator");

var debug = require("debug")("contract:execute");

var PromiEvent = require("./promievent");

var EventEmitter = require("events");

var utils = require("./utils");

var StatusError = require("./statuserror");

var Reason = require("./reason");

var handlers = require("./handlers");

var override = require("./override");

var reformat = require("./reformat");

var _require = require("./manual-send"),
    sendTransactionManual = _require.sendTransactionManual;

var execute = {
    // -----------------------------------  Helpers --------------------------------------------------

    /**
     * Retrieves gas estimate multiplied by the set gas multiplier for a `sendTransaction` call.
     * @param  {Object} params     `sendTransaction` parameters
     * @param  {Number} blockLimit  most recent network block.blockLimit
     * @return {Number}             gas estimate
     */
    getGasEstimate: function getGasEstimate(params, blockLimit) {
        var constructor = this;
        var interfaceAdapter = this.interfaceAdapter;
        return new Promise(function(accept) {
            // Always prefer specified gas - this includes gas set by class_defaults
            if (params.gas) return accept(params.gas);
            if (!constructor.autoGas) return accept();
            interfaceAdapter.estimateGas(params).then(function(gas) {
                var bestEstimate = utils.multiplyBigNumberByDecimal(utils.bigNumberify(gas), constructor.gasMultiplier); // Don't go over blockLimit

                var limit = utils.bigNumberify(blockLimit);
                bestEstimate.gte(limit) ? accept(limit.sub(1).toHexString()) : accept(bestEstimate.toHexString()); // We need to let txs that revert through.
                // Often that's exactly what you are testing.
            }).catch(function() {
                return accept();
            });
        });
    },

    /**
     * Prepares simple wrapped calls by checking network and organizing the method inputs into
     * objects web3 can consume.
     * @param  {Object} constructor   TruffleContract constructor
     * @param  {Object} methodABI     Function ABI segment w/ inputs & outputs keys.
     * @param  {Array}  _arguments    Arguments passed to method invocation
     * @return {Promise}              Resolves object w/ tx params disambiguated from arguments
     */
    prepareCall: function() {
        var _prepareCall = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee(constructor, methodABI, _arguments) {
            var args, params, web3, processedValues, network;
            return _regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                    switch (_context.prev = _context.next) {
                        case 0:
                            args = Array.prototype.slice.call(_arguments);
                            params = utils.getTxParams.call(constructor, methodABI, args);
                            args = utils.convertToEthersBN(args);

                            if (!(constructor.ens && constructor.ens.enabled)) {
                                _context.next = 10;
                                break;
                            }

                            web3 = constructor.web3;
                            _context.next = 7;
                            return utils.ens.convertENSNames({
                                ensSettings: constructor.ens,
                                inputArgs: args,
                                inputParams: params,
                                methodABI: methodABI,
                                web3: web3
                            });

                        case 7:
                            processedValues = _context.sent;
                            args = processedValues.args;
                            params = processedValues.params;

                        case 10:
                            _context.next = 12;
                            return constructor.detectNetwork();

                        case 12:
                            network = _context.sent;
                            return _context.abrupt("return", {
                                args: args,
                                params: params,
                                network: network
                            });

                        case 14:
                        case "end":
                            return _context.stop();
                    }
                }
            }, _callee);
        }));

        function prepareCall(_x, _x2, _x3) {
            return _prepareCall.apply(this, arguments);
        }

        return prepareCall;
    }(),

    /**
     * Disambiguates between transaction parameter objects and BN / BigNumber objects
     * @param  {Any}  arg
     * @return {Boolean}
     */
    hasTxParams: function hasTxParams(arg) {
        return utils.is_object(arg) && !utils.is_big_number(arg);
    },

    /**
     * Parses function arguments to discover if the terminal argument specifies the `defaultBlock`
     * to execute a call at.
     * @param  {Array}  args      `arguments` that were passed to method
     * @param  {Any}    lastArg    terminal argument passed to method
     * @param  {Array}  inputs     ABI segment defining method arguments
     * @return {Boolean}           true if final argument is `defaultBlock`
     */
    hasDefaultBlock: function hasDefaultBlock(args, lastArg, inputs) {
        var hasDefaultBlock = !execute.hasTxParams(lastArg) && args.length > inputs.length;
        var hasDefaultBlockWithParams = execute.hasTxParams(lastArg) && args.length - 1 > inputs.length;
        return hasDefaultBlock || hasDefaultBlockWithParams;
    },
    // -----------------------------------  Methods --------------------------------------------------

    /**
     * Executes method as .call and processes optional `defaultBlock` argument.
     * @param  {Function} fn         method
     * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.
     * @return {Promise}             Return value of the call.
     */
    call: function call(fn, methodABI, address) {
        var constructor = this;
        return function() {
            var defaultBlock = constructor.web3.eth.defaultBlock || "latest";
            var args = Array.prototype.slice.call(arguments);
            var lastArg = args[args.length - 1];
            var promiEvent = new PromiEvent(); // Extract defaultBlock parameter

            if (execute.hasDefaultBlock(args, lastArg, methodABI.inputs)) {
                defaultBlock = args.pop();
            }

            execute.prepareCall(constructor, methodABI, args).then( /*#__PURE__*/ function() {
                var _ref2 = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee2(_ref) {
                    var args, params, result;
                    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
                        while (1) {
                            switch (_context2.prev = _context2.next) {
                                case 0:
                                    args = _ref.args, params = _ref.params;
                                    params.to = address;
                                    promiEvent.eventEmitter.emit("execute:call:method", {
                                        fn: fn,
                                        args: args,
                                        address: address,
                                        abi: methodABI,
                                        contract: constructor
                                    });
                                    _context2.next = 5;
                                    return fn.apply(void 0, _toConsumableArray(args)).call(params, defaultBlock);

                                case 5:
                                    result = _context2.sent;
                                    result = reformat.numbers.call(constructor, result, methodABI.outputs);
                                    return _context2.abrupt("return", promiEvent.resolve(result));

                                case 8:
                                case "end":
                                    return _context2.stop();
                            }
                        }
                    }, _callee2);
                }));

                return function(_x4) {
                    return _ref2.apply(this, arguments);
                };
            }()).catch(promiEvent.reject);
            return promiEvent.eventEmitter;
        };
    },

    /**
     * Executes method as .send
     * @param  {Function} fn         Method to invoke
     * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.
     * @param  {String}   address    Deployed address of the targeted instance
     * @return {PromiEvent}          Resolves a transaction receipt (via the receipt handler)
     */
    send: function send(fn, methodABI, address) {
        var constructor = this;
        var web3 = constructor.web3;
        return function() {
            var promiEvent = new PromiEvent(false, constructor.debugger);
            execute.prepareCall(constructor, methodABI, arguments).then( /*#__PURE__*/ function() {
                var _ref4 = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee3(_ref3) {
                    var args, params, network, context;
                    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
                        while (1) {
                            switch (_context3.prev = _context3.next) {
                                case 0:
                                    args = _ref3.args, params = _ref3.params, network = _ref3.network;
                                    context = {
                                        contract: constructor,
                                        // Can't name this field `constructor` or `_constructor`
                                        promiEvent: promiEvent,
                                        params: params
                                    };
                                    params.to = address;
                                    params.data = fn ? fn.apply(void 0, _toConsumableArray(args)).encodeABI() : params.data;
                                    promiEvent.eventEmitter.emit("execute:send:method", {
                                        fn: fn,
                                        args: args,
                                        address: address,
                                        abi: methodABI,
                                        contract: constructor
                                    });
                                    _context3.prev = 5;
                                    _context3.next = 8;
                                    return execute.getGasEstimate.call(constructor, params, network.blockLimit);

                                case 8:
                                    params.gas = _context3.sent;
                                    _context3.next = 15;
                                    break;

                                case 11:
                                    _context3.prev = 11;
                                    _context3.t0 = _context3["catch"](5);
                                    promiEvent.reject(_context3.t0);
                                    return _context3.abrupt("return");

                                case 15:
                                    execute.sendTransaction(web3, params, promiEvent, context) //the crazy things we do for stacktracing...
                                        .then(function(receipt) {
                                            if (promiEvent.debug) {
                                                // in this case, we need to manually invoke the handler since it
                                                // hasn't been set up (hack?)
                                                handlers.receipt(context, receipt);
                                            } //otherwise, just let the handlers handle things

                                        }).catch(override.start.bind(constructor, context));

                                case 16:
                                case "end":
                                    return _context3.stop();
                            }
                        }
                    }, _callee3, null, [
                        [5, 11]
                    ]);
                }));

                return function(_x5) {
                    return _ref4.apply(this, arguments);
                };
            }()).catch(promiEvent.reject);
            return promiEvent.eventEmitter;
        };
    },

    /**
     * Deploys an instance
     * @param  {Object} constructorABI  Constructor ABI segment w/ inputs & outputs keys
     * @return {PromiEvent}             Resolves a TruffleContract instance
     */
    deploy: function deploy(constructorABI) {
        var constructor = this;
        var web3 = constructor.web3;
        return function() {
            var deferred;
            var promiEvent = new PromiEvent(false, constructor.debugger, true);
            execute.prepareCall(constructor, constructorABI, arguments).then( /*#__PURE__*/ function() {
                var _ref6 = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee4(_ref5) {
                    var args, params, network, blockLimit, context, options, contract, receipt, reason, error, web3Instance;
                    return _regeneratorRuntime.wrap(function _callee4$(_context4) {
                        while (1) {
                            switch (_context4.prev = _context4.next) {
                                case 0:
                                    args = _ref5.args, params = _ref5.params, network = _ref5.network;
                                    blockLimit = network.blockLimit;
                                    utils.checkLibraries.apply(constructor); // Promievent and flag that allows instance to resolve (rather than just receipt)

                                    context = {
                                        contract: constructor,
                                        promiEvent: promiEvent,
                                        onlyEmitReceipt: true
                                    };
                                    options = {
                                        data: constructor.binary,
                                        arguments: args
                                    };
                                    contract = new web3.eth.Contract(constructor.abi);
                                    params.data = contract.deploy(options).encodeABI();
                                    _context4.next = 9;
                                    return execute.getGasEstimate.call(constructor, params, blockLimit);

                                case 9:
                                    params.gas = _context4.sent;
                                    context.params = params;
                                    promiEvent.eventEmitter.emit("execute:deploy:method", {
                                        args: args,
                                        abi: constructorABI,
                                        contract: constructor
                                    });
                                    deferred = execute.sendTransaction(web3, params, promiEvent, context); //the crazy things we do for stacktracing...

                                    _context4.prev = 13;
                                    _context4.next = 16;
                                    return deferred;

                                case 16:
                                    receipt = _context4.sent;

                                    if (!(receipt.status !== undefined && !receipt.status)) {
                                        _context4.next = 23;
                                        break;
                                    }

                                    _context4.next = 20;
                                    return Reason.get(params, web3);

                                case 20:
                                    reason = _context4.sent;
                                    error = new StatusError(params, context.transactionHash, receipt, reason);
                                    return _context4.abrupt("return", context.promiEvent.reject(error));

                                case 23:
                                    web3Instance = new web3.eth.Contract(constructor.abi, receipt.contractAddress);
                                    web3Instance.transactionHash = context.transactionHash;
                                    context.promiEvent.resolve(new constructor(web3Instance));
                                    _context4.next = 32;
                                    break;

                                case 28:
                                    _context4.prev = 28;
                                    _context4.t0 = _context4["catch"](13);
                                    _context4.next = 32;
                                    return override.start.call(constructor, context, _context4.t0);

                                case 32:
                                case "end":
                                    return _context4.stop();
                            }
                        }
                    }, _callee4, null, [
                        [13, 28]
                    ]);
                }));

                return function(_x6) {
                    return _ref6.apply(this, arguments);
                };
            }()).catch(promiEvent.reject);
            return promiEvent.eventEmitter;
        };
    },

    /**
     * Begins listening for an event OR manages the event callback
     * @param  {Function} fn  Solidity event method
     * @return {Emitter}      Event emitter
     */
    event: function event(fn) {
        var constructor = this;
        var decode = utils.decodeLogs;
        var currentLogID = null; // Someone upstream is firing duplicates :/

        function dedupe(id) {
            return id === currentLogID ? false : currentLogID = id;
        }

        return function(params, callback) {
            if (typeof params === "function") {
                callback = params;
                params = {};
            } // As callback


            if (callback !== undefined) {
                var intermediary = function intermediary(err, e) {
                    if (err) return callback(err);
                    if (!dedupe(e.id)) return;
                    callback(null, decode.call(constructor, e, true)[0]);
                };

                return constructor.detectNetwork().then(function() {
                    return fn.call(constructor.events, params, intermediary);
                });
            } // As EventEmitter


            var emitter = new EventEmitter();
            constructor.detectNetwork().then(function() {
                var event = fn(params);
                event.on("data", function(e) {
                    return dedupe(e.id) && emitter.emit("data", decode.call(constructor, e, true)[0]);
                });
                event.on("changed", function(e) {
                    return dedupe(e.id) && emitter.emit("changed", decode.call(constructor, e, true)[0]);
                });
                event.on("error", function(e) {
                    return emitter.emit("error", e);
                });
            });
            return emitter;
        };
    },

    /**
     * Wraps web3 `allEvents`, with additional log decoding
     * @return {PromiEvent}  EventEmitter
     */
    allEvents: function allEvents(web3Instance) {
        var constructor = this;
        var decode = utils.decodeLogs;
        var currentLogID = null; // Someone upstream is firing duplicates :/

        function dedupe(id) {
            return id === currentLogID ? false : currentLogID = id;
        }

        return function(params) {
            var emitter = new EventEmitter();
            constructor.detectNetwork().then(function() {
                var event = web3Instance.events.allEvents(params);
                event.on("data", function(e) {
                    return dedupe(e.id) && emitter.emit("data", decode.call(constructor, e, true)[0]);
                });
                event.on("changed", function(e) {
                    return dedupe(e.id) && emitter.emit("changed", decode.call(constructor, e, true)[0]);
                });
                event.on("error", function(e) {
                    return emitter.emit("error", e);
                });
            });
            return emitter;
        };
    },

    /**
     * Wraps web3 `getPastEvents`, with additional log decoding
     * @return {Promise}  Resolves array of event objects
     */
    getPastEvents: function getPastEvents(web3Instance) {
        var constructor = this;
        var decode = utils.decodeLogs;
        return function(event, options) {
            return web3Instance.getPastEvents(event, options).then(function(events) {
                return decode.call(constructor, events, false);
            });
        };
    },

    /**
     * Estimates gas cost of a method invocation
     * @param  {Function} fn  Method to target
     * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.
     * @return {Promise}
     */
    estimate: function estimate(fn, methodABI) {
        var constructor = this;
        return function() {
            return execute.prepareCall(constructor, methodABI, arguments).then(function(res) {
                return fn.apply(void 0, _toConsumableArray(res.args)).estimateGas(res.params);
            });
        };
    },

    /**
     *
     * @param  {Function} fn  Method to target
     * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.
     * @return {Promise}
     */
    request: function request(fn, methodABI, address) {
        var constructor = this;
        return function() {
            return execute.prepareCall(constructor, methodABI, arguments).then(function(res) {
                //clone res.params
                var tx = {};

                for (var key in res.params) {
                    tx[key] = res.params[key];
                } //set to


                tx.to = address; //set data

                tx.data = fn.apply(void 0, _toConsumableArray(res.args)).encodeABI();
                return tx;
            });
        };
    },
    // This gets attached to `.new` (declared as a static_method in `contract`)
    // during bootstrapping as `estimateGas`
    estimateDeployment: function estimateDeployment() {
        var constructor = this;
        var constructorABI = constructor.abi.filter(function(i) {
            return i.type === "constructor";
        })[0];
        return execute.prepareCall(constructor, constructorABI, arguments).then(function(res) {
            var options = {
                data: constructor.binary,
                arguments: res.args
            };
            delete res.params["data"]; // Is this necessary?

            var instance = new constructor.web3.eth.Contract(constructor.abi, res.params);
            return instance.deploy(options).estimateGas(res.params);
        });
    },
    // This gets attached to `.new` (declared as a static_method in `contract`)
    // during bootstrapping as `request`
    requestDeployment: function requestDeployment() {
        var constructor = this;
        var constructorABI = constructor.abi.filter(function(i) {
            return i.type === "constructor";
        })[0];
        return execute.prepareCall(constructor, constructorABI, arguments).then(function(res) {
            //clone res.params
            var tx = {};

            for (var key in res.params) {
                tx[key] = res.params[key];
            }

            var options = {
                data: constructor.binary,
                arguments: res.args
            };
            var instance = new constructor.web3.eth.Contract(constructor.abi, res.params);
            tx.data = instance.deploy(options).encodeABI();
            return tx;
        });
    },
    //our own custom sendTransaction function, made to mimic web3's,
    //while also being able to do things, like, say, store the transaction
    //hash even in case of failure.  it's not as powerful in some ways,
    //as it just returns an ordinary Promise rather than web3's PromiEvent,
    //but it's more suited to our purposes (we're not using that PromiEvent
    //functionality here anyway)
    //input works the same as input to web3.sendTransaction
    //(well, OK, it's lacking some things there too, but again, good enough
    //for our purposes)
    sendTransaction: function() {
        var _sendTransaction = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee5(web3, params, promiEvent, context) {
            var chainId, deferred;
            return _regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) {
                    switch (_context5.prev = _context5.next) {
                        case 0:
                            if (!context.contract._chainId) {
                                _context5.next = 4;
                                break;
                            }

                            chainId = context.contract._chainId;
                            _context5.next = 9;
                            break;

                        case 4:
                            _context5.next = 6;
                            return web3.eth.net.getId();

                        case 6:
                            chainId = _context5.sent;
                            chainId = "0x".concat(chainId.toString(16)); //cache it in a field on the contract
                            //(I'd do this in setProvider instead of here, but that's not async)

                            context.contract._chainId = chainId;

                        case 9:
                            params.chainId = chainId; //if we don't need the debugger, let's not risk any errors on our part,
                            //and just have web3 do everything

                            if (!(!promiEvent || !promiEvent.debug)) {
                                _context5.next = 14;
                                break;
                            }

                            deferred = web3.eth.sendTransaction(params);
                            handlers.setup(deferred, context);
                            return _context5.abrupt("return", deferred);

                        case 14:
                            return _context5.abrupt("return", sendTransactionManual(web3, params, promiEvent));

                        case 15:
                        case "end":
                            return _context5.stop();
                    }
                }
            }, _callee5);
        }));

        function sendTransaction(_x7, _x8, _x9, _x10) {
            return _sendTransaction.apply(this, arguments);
        }

        return sendTransaction;
    }()
};
module.exports = execute;