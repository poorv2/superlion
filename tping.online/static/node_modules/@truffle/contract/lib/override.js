var _regeneratorRuntime = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator");

var _asyncToGenerator = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator");

var Reason = require("./reason");

var handlers = require("./handlers");

var override = {
    timeoutMessage: "not mined within",
    // Substring of timeout err fired by web3
    defaultWeb3Error: "please check your gas limit",
    // Substring of default Web3 error
    defaultMaxBlocks: 50,
    // Max # of blocks web3 will wait for a tx
    pollingInterval: 1000,

    /**
     * Attempts to extract receipt object from Web3 error message
     * @param  {Object} message       web3 error
     * @return {Object|undefined} receipt
     */
    extractReceipt: function extractReceipt(message) {
        var hasReceipt = message && message.includes("{");
        message.includes("}");

        if (hasReceipt) {
            var receiptString = "{" + message.split("{")[1].trim();

            try {
                return JSON.parse(receiptString);
            } catch (err) { // ignore
            }
        }
    },

    /**
     * Fired after web3 ceases to support subscriptions if user has specified
     * a higher block wait time than web3's 50 blocks limit. Opens a subscription to listen
     * for new blocks and begins evaluating whether block height has reached the user
     * defined timeout threshhold. Resolves either a contract instance or a transaction receipt.
     *
     * @param  {Object} context execution state
     * @param  {Object} err     error
     */
    start: function() {
        var _start = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee2(context, web3Error) {
            var constructor, currentBlock, receipt, reason, listener, currentPollingBlock, pollID;
            return _regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                    switch (_context2.prev = _context2.next) {
                        case 0:
                            constructor = this;
                            currentBlock = override.defaultMaxBlocks; // Reject after attempting to get reason string if we shouldn't be waiting.

                            if (handlers.ignoreTimeoutError(context, web3Error)) {
                                _context2.next = 13;
                                break;
                            }

                            // We might have been routed here in web3 >= beta.34 by their own status check
                            // error. We want to extract the receipt, emit a receipt event
                            // and reject it ourselves.
                            receipt = override.extractReceipt(web3Error.message);

                            if (!receipt) {
                                _context2.next = 8;
                                break;
                            }

                            _context2.next = 7;
                            return handlers.receipt(context, receipt);

                        case 7:
                            return _context2.abrupt("return");

                        case 8:
                            _context2.next = 10;
                            return Reason.get(context.params, constructor.web3, constructor.interfaceAdapter);

                        case 10:
                            reason = _context2.sent;

                            if (reason) {
                                web3Error.reason = reason;
                                web3Error.message += " -- Reason given: ".concat(reason, ".");
                            }

                            return _context2.abrupt("return", context.promiEvent.reject(web3Error));

                        case 13:
                            // This will run every block from now until contract.timeoutBlocks
                            listener = function listener(pollID) {
                                currentBlock++;

                                if (currentBlock > constructor.timeoutBlocks) {
                                    clearInterval(pollID);
                                    return;
                                }

                                constructor.interfaceAdapter.getTransactionReceipt(context.transactionHash).then(function(result) {
                                    if (!result) return; // make sure reporter receives tx receipt promievent

                                    handlers.receipt(context, result);
                                    result.contractAddress ? constructor.at(result.contractAddress).then(context.promiEvent.resolve).catch(context.promiEvent.reject) : constructor.promiEvent.resolve(result);
                                }).catch(function(err) {
                                    clearInterval(pollID);
                                    context.promiEvent.reject(err);
                                });
                            }; // Start polling


                            _context2.next = 16;
                            return constructor.interfaceAdapter.getBlockNumber();

                        case 16:
                            currentPollingBlock = _context2.sent;
                            pollID = setInterval( /*#__PURE__*/ _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee() {
                                var newBlock;
                                return _regeneratorRuntime.wrap(function _callee$(_context) {
                                    while (1) {
                                        switch (_context.prev = _context.next) {
                                            case 0:
                                                _context.next = 2;
                                                return constructor.interfaceAdapter.getBlockNumber();

                                            case 2:
                                                newBlock = _context.sent;

                                                if (newBlock > currentPollingBlock) {
                                                    currentPollingBlock = newBlock;
                                                    listener(pollID);
                                                }

                                            case 4:
                                            case "end":
                                                return _context.stop();
                                        }
                                    }
                                }, _callee);
                            })), override.pollingInterval);

                        case 18:
                        case "end":
                            return _context2.stop();
                    }
                }
            }, _callee2, this);
        }));

        function start(_x, _x2) {
            return _start.apply(this, arguments);
        }

        return start;
    }()
};
module.exports = override;