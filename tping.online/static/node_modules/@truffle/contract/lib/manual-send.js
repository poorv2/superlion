var _regeneratorRuntime = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator");

var _defineProperty = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty");

var _slicedToArray = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray");

var _toConsumableArray = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray");

var _asyncToGenerator = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator");

var debug = require("debug")("contract:manual-send");

var ethers = require("ethers");

var Utils = require("./utils");

var _require = require("web3-core-helpers"),
    formatters = _require.formatters; //used for reproducing web3's behavior
//this is less manual now, it uses ethers, whew
//(it's still more manual than using web3)


function sendTransactionManual(_x, _x2, _x3) {
    return _sendTransactionManual.apply(this, arguments);
}

function _sendTransactionManual() {
    _sendTransactionManual = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee(web3, params, promiEvent) {
        var ethersProvider, _setUpParameters, transaction, from, account, ethersSigner, txHash, receipt, ethersResponse, _handleError;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        debug("executing manually!"); //set up ethers provider

                        ethersProvider = new ethers.providers.Web3Provider(web3.currentProvider); //let's clone params and set it up properly

                        _setUpParameters = setUpParameters(params, web3), transaction = _setUpParameters.transaction, from = _setUpParameters.from; //now: if the from address is in the wallet, web3 will sign the transaction before
                        //sending, so we have to account for that

                        account = web3.eth.accounts.wallet[from];
                        ethersSigner = account ? new ethers.Wallet(account.privateKey, ethersProvider) : ethersProvider.getSigner(from);
                        debug("got signer");
                        _context.prev = 6;
                        _context.next = 9;
                        return ethersSigner.sendTransaction(transaction);

                    case 9:
                        ethersResponse = _context.sent;
                        txHash = ethersResponse.hash;
                        _context.next = 13;
                        return ethersProvider.waitForTransaction(txHash);

                    case 13:
                        receipt = _context.sent;
                        debug("no error");
                        _context.next = 26;
                        break;

                    case 17:
                        _context.prev = 17;
                        _context.t0 = _context["catch"](6);
                        _handleError = handleError(_context.t0);
                        txHash = _handleError.txHash;
                        receipt = _handleError.receipt;

                        if (receipt) {
                            _context.next = 26;
                            break;
                        }

                        _context.next = 25;
                        return ethersProvider.waitForTransaction(txHash);

                    case 25:
                        receipt = _context.sent;

                    case 26:
                        debug("txHash: %s", txHash);
                        receipt = translateReceipt(receipt);
                        promiEvent.setTransactionHash(txHash); //this here is why I wrote this function @_@

                        _context.next = 31;
                        return handleResult(receipt, transaction.to == null);

                    case 31:
                        return _context.abrupt("return", _context.sent);

                    case 32:
                    case "end":
                        return _context.stop();
                }
            }
        }, _callee, null, [
            [6, 17]
        ]);
    }));
    return _sendTransactionManual.apply(this, arguments);
}

function handleError(error) {
    debug("error: %O", error);

    if (error.data && Object.keys(error.data).length === 3) {
        //error.data will have 3 keys: stack, name, and the txHash
        var transactionHash = Object.keys(error.data).find(function(key) {
            return key !== "stack" && key !== "name";
        });
        return {
            txHash: transactionHash
        };
    } else if (error.transactionHash && error.receipt) {
        return {
            txHash: error.transactionHash,
            receipt: error.receipt
        };
    } else {
        throw error; //rethrow unexpected errors
    }
}

function handleResult(_x4, _x5) {
    return _handleResult.apply(this, arguments);
}

function _handleResult() {
    _handleResult = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee2(receipt, isDeployment) {
        var deploymentFailedMessage;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
                switch (_context2.prev = _context2.next) {
                    case 0:
                        deploymentFailedMessage = "The contract code couldn't be stored, please check your gas limit.";

                        if (!receipt.status) {
                            _context2.next = 11;
                            break;
                        }

                        if (!isDeployment) {
                            _context2.next = 8;
                            break;
                        }

                        _context2.next = 5;
                        return web3.eth.getCode(receipt.contractAddress);

                    case 5:
                        _context2.t0 = _context2.sent;

                        if (!(_context2.t0 === "0x")) {
                            _context2.next = 8;
                            break;
                        }

                        throw new Error(deploymentFailedMessage);

                    case 8:
                        return _context2.abrupt("return", receipt);

                    case 11:
                        if (!isDeployment) {
                            _context2.next = 13;
                            break;
                        }

                        throw new Error(deploymentFailedMessage);

                    case 13:
                        throw new Error("Transaction has been reverted by the EVM:" + "\n" + JSON.stringify(receipt));

                    case 14:
                    case "end":
                        return _context2.stop();
                }
            }
        }, _callee2);
    }));
    return _handleResult.apply(this, arguments);
}

function setUpParameters(params, web3) {
    var transaction = Object.assign({}, params);
    transaction.from = transaction.from != undefined ? transaction.from : web3.eth.defaultAccount; //now let's have web3 check our inputs

    transaction = formatters.inputTransactionFormatter(transaction); //warning, not a pure fn
    //...but ethers uses gasLimit instead of gas like web3

    transaction.gasLimit = transaction.gas;
    delete transaction.gas; //also, it insists "from" be kept separate

    var _transaction = transaction,
        from = _transaction.from;
    delete transaction.from;
    return {
        transaction: transaction,
        from: from
    };
} //translate the receipt to web3 format by converting BigNumbers
//(note: these are *ethers* BigNumbers) to numbers


function translateReceipt(receipt) {
    return Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(receipt).map(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            key = _ref2[0],
            value = _ref2[1];

        return _defineProperty({}, key, Utils.is_big_number(value) ? value.toNumber() : value);
    }))));
}

module.exports = {
    sendTransactionManual: sendTransactionManual
};