"use strict";

var _defineProperty = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty");

var _slicedToArray = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray");

var _toConsumableArray = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray");

var _classCallCheck = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck");

var _possibleConstructorReturn = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf");

var _inherits = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits");

var _wrapNativeSuper = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper");

function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {};
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true,
        didErr = false,
        err;
    return {
        s: function s() {
            it = o[Symbol.iterator]();
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally {
                if (didErr) throw err;
            }
        }
    };
}

function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
    }
    return arr2;
}

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});

var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
        for (var k in mod) {
            if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }

    __setModuleDefault(result, mod);

    return result;
};

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.storageSize = exports.getStateAllocations = exports.getStorageAllocations = exports.UnknownBaseContractIdError = void 0;

var debug_1 = __importDefault(require("debug"));

var debug = debug_1.default("codec:storage:allocate");

var Common = __importStar(require("../../common"));

var Basic = __importStar(require("../../basic"));

var Utils = __importStar(require("../utils"));

var Ast = __importStar(require("../../ast"));

var Evm = __importStar(require("../../evm"));

var Format = __importStar(require("../../format"));

var bn_js_1 = __importDefault(require("bn.js"));

var lodash_partition_1 = __importDefault(require("lodash.partition"));

var UnknownBaseContractIdError = /*#__PURE__*/ function(_Error) {
    _inherits(UnknownBaseContractIdError, _Error);

    function UnknownBaseContractIdError(derivedId, derivedName, derivedKind, baseId) {
        var _this;

        _classCallCheck(this, UnknownBaseContractIdError);

        var message = "Cannot locate base contract ID ".concat(baseId, " of ").concat(derivedKind, " ").concat(derivedName, " (ID ").concat(derivedId, ")");
        _this = _possibleConstructorReturn(this, _getPrototypeOf(UnknownBaseContractIdError).call(this, message));
        _this.name = "UnknownBaseContractIdError";
        _this.derivedId = derivedId;
        _this.derivedName = derivedName;
        _this.derivedKind = derivedKind;
        _this.baseId = baseId;
        return _this;
    }

    return UnknownBaseContractIdError;
}(_wrapNativeSuper(Error));

exports.UnknownBaseContractIdError = UnknownBaseContractIdError; //contracts contains only the contracts to be allocated; any base classes not
//being allocated should just be in referenceDeclarations

function getStorageAllocations(userDefinedTypes) {
    var allocations = {};

    for (var _i = 0, _Object$values = Object.values(userDefinedTypes); _i < _Object$values.length; _i++) {
        var dataType = _Object$values[_i];

        if (dataType.typeClass === "struct") {
            try {
                allocations = allocateStruct(dataType, userDefinedTypes, allocations);
            } catch (_) { //if allocation fails... oh well, allocation fails, we do nothing and just move on :P
                //note: a better way of handling this would probably be to *mark* it
                //as failed rather than throwing an exception as that would lead to less
                //recomputation, but this is simpler and I don't think the recomputation
                //should really be a problem
            }
        }
    }

    return allocations;
}

exports.getStorageAllocations = getStorageAllocations;
/**
 * This function gets allocations for the state variables of the contracts;
 * this is distinct from getStorageAllocations, which gets allocations for
 * storage structs.
 *
 * While mostly state variables are kept in storage, constant ones are not.
 * And immutable ones, once those are introduced, will be kept in code!
 * (But those don't exist yet so this function doesn't handle them yet.)
 */

function getStateAllocations(contracts, referenceDeclarations, userDefinedTypes, storageAllocations) {
    var existingAllocations = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
    var allocations = existingAllocations;

    var _iterator = _createForOfIteratorHelper(contracts),
        _step;

    try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var contractInfo = _step.value;
            var contract = contractInfo.contractNode,
                immutableReferences = contractInfo.immutableReferences,
                compiler = contractInfo.compiler,
                compilationId = contractInfo.compilationId;

            try {
                allocations = allocateContractState(contract, immutableReferences, compilationId, compiler, referenceDeclarations[compilationId], userDefinedTypes, storageAllocations, allocations);
            } catch (_) { //we're just going to allow failure here and catch the problem elsewhere
            }
        }
    } catch (err) {
        _iterator.e(err);
    } finally {
        _iterator.f();
    }

    return allocations;
}

exports.getStateAllocations = getStateAllocations;

function allocateStruct(dataType, userDefinedTypes, existingAllocations) {
    //NOTE: dataType here should be a *stored* type!
    //it is up to the caller to take care of this
    return allocateMembers(dataType.id, dataType.memberTypes, userDefinedTypes, existingAllocations);
}

function allocateMembers(parentId, members, userDefinedTypes, existingAllocations) {
    var offset = 0; //will convert to BN when placing in slot

    var index = Evm.Utils.WORD_SIZE - 1; //don't allocate things that have already been allocated

    if (parentId in existingAllocations) {
        return existingAllocations;
    }

    var allocations = Object.assign({}, existingAllocations); //otherwise, we'll be adding to this, so we better clone
    //otherwise, we need to allocate

    var memberAllocations = [];

    var _iterator2 = _createForOfIteratorHelper(members),
        _step2;

    try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var member = _step2.value;
            var size = void 0;

            var _storageSizeAndAlloca = storageSizeAndAllocate(member.type, userDefinedTypes, allocations);

            size = _storageSizeAndAlloca.size;
            allocations = _storageSizeAndAlloca.allocations;

            //if it's sized in words (and we're not at the start of slot) we need to start on a new slot
            //if it's sized in bytes but there's not enough room, we also need a new slot
            if (Utils.isWordsLength(size) ? index < Evm.Utils.WORD_SIZE - 1 : size.bytes > index + 1) {
                index = Evm.Utils.WORD_SIZE - 1;
                offset += 1;
            } //otherwise, we remain in place


            var range = void 0;

            if (Utils.isWordsLength(size)) {
                //words case
                range = {
                    from: {
                        slot: {
                            offset: new bn_js_1.default(offset) //start at the current slot...

                        },
                        index: 0 //...at the beginning of the word.

                    },
                    to: {
                        slot: {
                            offset: new bn_js_1.default(offset + size.words - 1) //end at the current slot plus # of words minus 1...

                        },
                        index: Evm.Utils.WORD_SIZE - 1 //...at the end of the word.

                    }
                };
            } else {
                //bytes case
                range = {
                    from: {
                        slot: {
                            offset: new bn_js_1.default(offset) //start at the current slot...

                        },
                        index: index - (size.bytes - 1) //...early enough to fit what's being allocated.

                    },
                    to: {
                        slot: {
                            offset: new bn_js_1.default(offset) //end at the current slot...

                        },
                        index: index //...at the current position.

                    }
                };
            }

            memberAllocations.push({
                name: member.name,
                type: member.type,
                pointer: {
                    location: "storage",
                    range: range
                }
            }); //finally, adjust the current position.
            //if it was sized in words, move down that many slots and reset position w/in slot

            if (Utils.isWordsLength(size)) {
                offset += size.words;
                index = Evm.Utils.WORD_SIZE - 1;
            } //if it was sized in bytes, move down an appropriate number of bytes.
            else {
                index -= size.bytes; //but if this puts us into the next word, move to the next word.

                if (index < 0) {
                    index = Evm.Utils.WORD_SIZE - 1;
                    offset += 1;
                }
            }
        } //finally, let's determine the overall siz; we're dealing with a struct, so
        //the size is measured in words
        //it's one plus the last word used, i.e. one plus the current word... unless the
        //current word remains entirely unused, then it's just the current word
        //SPECIAL CASE: if *nothing* has been used, allocate a single word (that's how
        //empty structs behave in versions where they're legal)

    } catch (err) {
        _iterator2.e(err);
    } finally {
        _iterator2.f();
    }

    var totalSize;

    if (index === Evm.Utils.WORD_SIZE - 1 && offset !== 0) {
        totalSize = {
            words: offset
        };
    } else {
        totalSize = {
            words: offset + 1
        };
    } //having made our allocation, let's add it to allocations!


    allocations[parentId] = {
        members: memberAllocations,
        size: totalSize
    }; //...and we're done!

    return allocations;
}

function getStateVariables(contractNode) {
    // process for state variables
    return contractNode.nodes.filter(function(node) {
        return node.nodeType === "VariableDeclaration" && node.stateVariable;
    });
}

function allocateContractState(contract, immutableReferences, compilationId, compiler, referenceDeclarations, userDefinedTypes, storageAllocations) {
    var _ref4;

    var existingAllocations = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {};
    //we're going to do a 2-deep clone here
    var allocations = Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(existingAllocations).map(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            compilationId = _ref2[0],
            compilationAllocations = _ref2[1];

        return _defineProperty({}, compilationId, Object.assign({}, compilationAllocations));
    }))));

    if (!immutableReferences) {
        immutableReferences = {}; //also, let's set this up for convenience
    } //base contracts are listed from most derived to most base, so we
    //have to reverse before processing, but reverse() is in place, so we
    //clone with slice first


    var linearizedBaseContractsFromBase = contract.linearizedBaseContracts.slice().reverse(); //first, let's get all the variables under consideration

    var variables = (_ref4 = []).concat.apply(_ref4, _toConsumableArray(linearizedBaseContractsFromBase.map(function(id) {
        var baseNode = referenceDeclarations[id];

        if (baseNode === undefined) {
            throw new UnknownBaseContractIdError(contract.id, contract.name, contract.contractKind, id);
        }

        return getStateVariables(baseNode).map(function(definition) {
            return {
                definition: definition,
                definedIn: baseNode
            };
        });
    }))); //just in case the constant field ever gets removed


    var isConstant = function isConstant(definition) {
        return definition.constant || definition.mutability === "constant";
    }; //now: we split the variables into storage, constant, and code


    var _lodash_partition_1$d = lodash_partition_1.default(variables, function(variable) {
            return isConstant(variable.definition);
        }),
        _lodash_partition_1$d2 = _slicedToArray(_lodash_partition_1$d, 2),
        constantVariables = _lodash_partition_1$d2[0],
        variableVariables = _lodash_partition_1$d2[1]; //why use this function instead of just checking
    //definition.mutability?
    //because of a bug in Solidity 0.6.5 that causes the mutability field
    //not to exist.  So, we also have to check against immutableReferences.


    var isImmutable = function isImmutable(definition) {
        return definition.mutability === "immutable" || definition.id.toString() in immutableReferences;
    };

    var _lodash_partition_1$d3 = lodash_partition_1.default(variableVariables, function(variable) {
            return isImmutable(variable.definition);
        }),
        _lodash_partition_1$d4 = _slicedToArray(_lodash_partition_1$d3, 2),
        immutableVariables = _lodash_partition_1$d4[0],
        storageVariables = _lodash_partition_1$d4[1]; //transform storage variables into data types


    var storageVariableTypes = storageVariables.map(function(variable) {
        return {
            name: variable.definition.name,
            type: Ast.Import.definitionToType(variable.definition, compilationId, compiler)
        };
    }); //let's allocate the storage variables using a fictitious ID

    var id = "-1";
    var storageVariableStorageAllocations = allocateMembers(id, storageVariableTypes, userDefinedTypes, storageAllocations)[id]; //transform to new format

    var storageVariableAllocations = storageVariables.map(function(_ref5, index) {
        var definition = _ref5.definition,
            definedIn = _ref5.definedIn;
        return {
            definition: definition,
            definedIn: definedIn,
            compilationId: compilationId,
            pointer: storageVariableStorageAllocations.members[index].pointer
        };
    }); //now let's create allocations for the immutables

    var immutableVariableAllocations = immutableVariables.map(function(_ref6) {
        var definition = _ref6.definition,
            definedIn = _ref6.definedIn;
        var references = immutableReferences[definition.id.toString()] || [];
        var pointer;

        if (references.length === 0) {
            pointer = {
                location: "nowhere"
            };
        } else {
            pointer = {
                location: "code",
                start: references[0].start,
                length: references[0].length
            };
        }

        return {
            definition: definition,
            definedIn: definedIn,
            compilationId: compilationId,
            pointer: pointer
        };
    }); //and let's create allocations for the constants

    var constantVariableAllocations = constantVariables.map(function(_ref7) {
        var definition = _ref7.definition,
            definedIn = _ref7.definedIn;
        return {
            definition: definition,
            definedIn: definedIn,
            compilationId: compilationId,
            pointer: {
                location: "definition",
                definition: definition.value
            }
        };
    }); //now, reweave the three together

    var contractAllocation = [];

    var _iterator3 = _createForOfIteratorHelper(variables),
        _step3;

    try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var variable = _step3.value;
            var arrayToGrabFrom = isConstant(variable.definition) ? constantVariableAllocations : isImmutable(variable.definition) ? immutableVariableAllocations : storageVariableAllocations;
            contractAllocation.push(arrayToGrabFrom.shift()); //note that push and shift both modify!
        } //finally, set things and return

    } catch (err) {
        _iterator3.e(err);
    } finally {
        _iterator3.f();
    }

    if (!allocations[compilationId]) {
        allocations[compilationId] = {};
    }

    allocations[compilationId][contract.id] = {
        members: contractAllocation
    };
    return allocations;
} //NOTE: This wrapper function is for use in decoding ONLY, after allocation is done.
//The allocator should (and does) instead use a direct call to storageSizeAndAllocate,
//not to the wrapper, because it may need the allocations returned.


function storageSize(dataType, userDefinedTypes, allocations) {
    return storageSizeAndAllocate(dataType, userDefinedTypes, allocations).size;
}

exports.storageSize = storageSize;

function storageSizeAndAllocate(dataType, userDefinedTypes, existingAllocations) {
    //we'll only directly handle reference types here;
    //direct types will be handled by dispatching to Basic.Allocate.byteLength
    //in the default case
    switch (dataType.typeClass) {
        case "bytes":
            {
                switch (dataType.kind) {
                    case "static":
                        //really a basic type :)
                        return {
                            size: {
                                bytes: Basic.Allocate.byteLength(dataType, userDefinedTypes)
                            },
                            allocations: existingAllocations
                        };

                    case "dynamic":
                        return {
                            size: {
                                words: 1
                            },
                            allocations: existingAllocations
                        };
                }
            }

        case "string":
        case "mapping":
            return {
                size: {
                    words: 1
                },
                allocations: existingAllocations
            };

        case "array":
            {
                switch (dataType.kind) {
                    case "dynamic":
                        return {
                            size: {
                                words: 1
                            },
                            allocations: existingAllocations
                        };

                    case "static":
                        //static array case
                        var length = dataType.length.toNumber(); //warning! but if it's too big we have a problem

                        if (length === 0) {
                            //in versions of Solidity where it's legal, arrays of length 0 still take up 1 word
                            return {
                                size: {
                                    words: 1
                                },
                                allocations: existingAllocations
                            };
                        }

                        var _storageSizeAndAlloca2 = storageSizeAndAllocate(dataType.baseType, userDefinedTypes, existingAllocations),
                            baseSize = _storageSizeAndAlloca2.size,
                            allocations = _storageSizeAndAlloca2.allocations;

                        if (!Utils.isWordsLength(baseSize)) {
                            //bytes case
                            var perWord = Math.floor(Evm.Utils.WORD_SIZE / baseSize.bytes);
                            debug("length %o", length);
                            var numWords = Math.ceil(length / perWord);
                            return {
                                size: {
                                    words: numWords
                                },
                                allocations: allocations
                            };
                        } else {
                            //words case
                            return {
                                size: {
                                    words: baseSize.words * length
                                },
                                allocations: allocations
                            };
                        }

                }
            }

        case "struct":
            {
                var _allocations = existingAllocations;
                var allocation = _allocations[dataType.id]; //may be undefined!

                if (allocation === undefined) {
                    //if we don't find an allocation, we'll have to do the allocation ourselves
                    var storedType = userDefinedTypes[dataType.id];

                    if (!storedType) {
                        throw new Common.UnknownUserDefinedTypeError(dataType.id, Format.Types.typeString(dataType));
                    }

                    _allocations = allocateStruct(storedType, userDefinedTypes, existingAllocations);
                    allocation = _allocations[dataType.id];
                } //having found our allocation, we can just look up its size


                return {
                    size: allocation.size,
                    allocations: _allocations
                };
            }

        default:
            //otherwise, it's a direct type
            return {
                size: {
                    bytes: Basic.Allocate.byteLength(dataType, userDefinedTypes)
                },
                allocations: existingAllocations
            };
    }
}