"use strict";

var _regeneratorRuntime = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator");

var _marked = /*#__PURE__*/ _regeneratorRuntime.mark(decodeStack),
    _marked2 = /*#__PURE__*/ _regeneratorRuntime.mark(decodeLiteral);

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});

var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
        for (var k in mod) {
            if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }

    __setModuleDefault(result, mod);

    return result;
};

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.decodeLiteral = exports.decodeStack = void 0;

var debug_1 = __importDefault(require("debug"));

var debug = debug_1.default("codec:stack:decode");

var AbiData = __importStar(require("../../abi-data"));

var Conversion = __importStar(require("../../conversion"));

var Format = __importStar(require("../../format"));

var read_1 = __importDefault(require("../../read"));

var Basic = __importStar(require("../../basic"));

var Memory = __importStar(require("../../memory"));

var Storage = __importStar(require("../../storage"));

var Evm = __importStar(require("../../evm"));

var errors_1 = require("../../errors");

function decodeStack(dataType, pointer, info) {
    var rawValue, literalPointer;
    return _regeneratorRuntime.wrap(function decodeStack$(_context) {
        while (1) {
            switch (_context.prev = _context.next) {
                case 0:
                    _context.prev = 0;
                    return _context.delegateYield(read_1.default(pointer, info.state), "t0", 2);

                case 2:
                    rawValue = _context.t0;
                    _context.next = 8;
                    break;

                case 5:
                    _context.prev = 5;
                    _context.t1 = _context["catch"](0);
                    return _context.abrupt("return", errors_1.handleDecodingError(dataType, _context.t1));

                case 8:
                    literalPointer = {
                        location: "stackliteral",
                        literal: rawValue
                    };
                    return _context.delegateYield(decodeLiteral(dataType, literalPointer, info), "t2", 10);

                case 10:
                    return _context.abrupt("return", _context.t2);

                case 11:
                case "end":
                    return _context.stop();
            }
        }
    }, _marked, null, [
        [0, 5]
    ]);
}

exports.decodeStack = decodeStack;

function decodeLiteral(dataType, pointer, info) {
    var lengthAsBN, locationOnly, address, selectorWord, selector;
    return _regeneratorRuntime.wrap(function decodeLiteral$(_context2) {
        while (1) {
            switch (_context2.prev = _context2.next) {
                case 0:
                    debug("type %O", dataType);
                    debug("pointer %o", pointer);

                    if (!Format.Types.isReferenceType(dataType)) {
                        _context2.next = 19;
                        break;
                    }

                    _context2.t0 = dataType.location;
                    _context2.next = _context2.t0 === "memory" ? 6 : _context2.t0 === "storage" ? 8 : _context2.t0 === "calldata" ? 10 : 19;
                    break;

                case 6:
                    return _context2.delegateYield(Memory.Decode.decodeMemoryReferenceByAddress(dataType, pointer, info), "t1", 7);

                case 7:
                    return _context2.abrupt("return", _context2.t1);

                case 8:
                    return _context2.delegateYield(Storage.Decode.decodeStorageReferenceByAddress(dataType, pointer, info), "t2", 9);

                case 9:
                    return _context2.abrupt("return", _context2.t2);

                case 10:
                    if (!(dataType.typeClass === "bytes" || dataType.typeClass === "string" || dataType.typeClass === "array" && dataType.kind === "dynamic")) {
                        _context2.next = 17;
                        break;
                    }

                    lengthAsBN = Conversion.toBN(pointer.literal.slice(Evm.Utils.WORD_SIZE));
                    locationOnly = pointer.literal.slice(0, Evm.Utils.WORD_SIZE);
                    return _context2.delegateYield(AbiData.Decode.decodeAbiReferenceByAddress(dataType, {
                        location: "stackliteral",
                        literal: locationOnly
                    }, info, {
                        abiPointerBase: 0,
                        lengthOverride: lengthAsBN
                    }), "t3", 14);

                case 14:
                    return _context2.abrupt("return", _context2.t3);

                case 17:
                    return _context2.delegateYield(AbiData.Decode.decodeAbiReferenceByAddress(dataType, pointer, info, {
                        abiPointerBase: 0 //let's be explicit

                    }), "t4", 18);

                case 18:
                    return _context2.abrupt("return", _context2.t4);

                case 19:
                    if (!(dataType.typeClass === "function" && dataType.visibility === "external")) {
                        _context2.next = 29;
                        break;
                    }

                    address = pointer.literal.slice(0, Evm.Utils.WORD_SIZE);
                    selectorWord = pointer.literal.slice(-Evm.Utils.WORD_SIZE);

                    if (!(!Basic.Decode.checkPaddingLeft(address, Evm.Utils.ADDRESS_SIZE) || !Basic.Decode.checkPaddingLeft(selectorWord, Evm.Utils.SELECTOR_SIZE))) {
                        _context2.next = 24;
                        break;
                    }

                    return _context2.abrupt("return", {
                        type: dataType,
                        kind: "error",
                        error: {
                            kind: "FunctionExternalStackPaddingError",
                            rawAddress: Conversion.toHexString(address),
                            rawSelector: Conversion.toHexString(selectorWord)
                        }
                    });

                case 24:
                    selector = selectorWord.slice(-Evm.Utils.SELECTOR_SIZE);
                    _context2.t5 = dataType;
                    return _context2.delegateYield(Basic.Decode.decodeExternalFunction(address, selector, info), "t6", 27);

                case 27:
                    _context2.t7 = _context2.t6;
                    return _context2.abrupt("return", {
                        type: _context2.t5,
                        kind: "value",
                        value: _context2.t7
                    });

                case 29:
                    return _context2.delegateYield(Basic.Decode.decodeBasic(dataType, pointer, info, {
                        paddingMode: "permissive"
                    }), "t8", 30);

                case 30:
                    return _context2.abrupt("return", _context2.t8);

                case 31:
                case "end":
                    return _context2.stop();
            }
        }
    }, _marked2);
}

exports.decodeLiteral = decodeLiteral;