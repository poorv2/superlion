"use strict";

var _classCallCheck = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck");

var _createClass = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass");

var _defineProperty = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty");

var _slicedToArray = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray");

var _toConsumableArray = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray");

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});

var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
        for (var k in mod) {
            if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }

    __setModuleDefault(result, mod);

    return result;
};

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.unsafeNativize = exports.unsafeNativizeVariables = exports.ResultInspector = void 0;

var debug_1 = __importDefault(require("debug"));

var debug = debug_1.default("codec:format:utils:inspect");

var util_1 = __importDefault(require("util"));

var Exception = __importStar(require("./exception")); //HACK -- inspect options are ridiculous, I swear >_>


function cleanStylize(options) {
    return Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(options).map(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            key = _ref2[0],
            value = _ref2[1];

        return key === "stylize" ? {} : _defineProperty({}, key, value);
    }))));
}
/**
 * This class is meant to be used with Node's
 * [util.inspect()](https://nodejs.org/api/util.html#util_util_inspect_object_options)
 * function.  Given a [[Format.Values.Result]] `value`, one can use
 * `new ResultInspector(value)` to create a ResultInspector for that value,
 * which can be used with util.inspect() to create a human-readable string
 * representing the value.
 *
 * @example
 * Suppose `value` is a Result.  In Node, the following would print to the
 * console a human-readable representation of `value`, with colors enabled,
 * no maximum depth, and no maximum array length, and lines (usually) no
 * longer than 80 characters:
 * ```javascript
 * console.log(
 *   util.inspect(
 *     new ResultInspector(value),
 *     {
 *       colors: true,
 *       depth: null,
 *       maxArrayLength: null,
 *       breakLength: 80
 *     }
 *   )
 * );
 * ```
 * Of course, there are many other ways to use util.inspect; see Node's
 * documentation, linked above, for more.
 */


var ResultInspector = /*#__PURE__*/ function() {
    function ResultInspector(result) {
        _classCallCheck(this, ResultInspector);

        this.result = result;
    }

    _createClass(ResultInspector, [{
        key: util_1.default.inspect.custom,
        value: function value(depth, options) {
            switch (this.result.kind) {
                case "value":
                    switch (this.result.type.typeClass) {
                        case "uint":
                        case "int":
                            return options.stylize(this.result.value.asBN.toString(), "number");

                        case "fixed":
                        case "ufixed":
                            //note: because this is just for display, we don't bother adjusting the magic values Big.NE or Big.PE;
                            //we'll trust those to their defaults
                            return options.stylize(this.result.value.asBig.toString(), "number");

                        case "bool":
                            return util_1.default.inspect(this.result.value.asBoolean, options);

                        case "bytes":
                            var hex = this.result.value.asHex;

                            switch (this.result.type.kind) {
                                case "static":
                                    return options.stylize(hex, "number");

                                case "dynamic":
                                    return options.stylize("hex'".concat(hex.slice(2), "'"), "string");
                            }

                        case "address":
                            return options.stylize(this.result.value.asAddress, "number");

                        case "string":
                            {
                                var coercedResult = this.result;

                                switch (coercedResult.value.kind) {
                                    case "valid":
                                        return util_1.default.inspect(coercedResult.value.asString, options);

                                    case "malformed":
                                        //note: this will turn malformed utf-8 into replacement characters (U+FFFD)
                                        //note we need to cut off the 0x prefix
                                        return util_1.default.inspect(Buffer.from(coercedResult.value.asHex.slice(2), "hex").toString());
                                }
                            }

                        case "array":
                            {
                                var _coercedResult = this.result;

                                if (_coercedResult.reference !== undefined) {
                                    return formatCircular(_coercedResult.reference, options);
                                }

                                return util_1.default.inspect(_coercedResult.value.map(function(element) {
                                    return new ResultInspector(element);
                                }), options);
                            }

                        case "mapping":
                            return util_1.default.inspect(new Map(this.result.value.map(function(_ref4) {
                                var key = _ref4.key,
                                    value = _ref4.value;
                                return [new ResultInspector(key), new ResultInspector(value)];
                            })), options);

                        case "struct":
                            {
                                var _coercedResult2 = this.result;

                                if (_coercedResult2.reference !== undefined) {
                                    return formatCircular(_coercedResult2.reference, options);
                                }

                                return util_1.default.inspect(Object.assign.apply(Object, [{}].concat(_toConsumableArray(_coercedResult2.value.map(function(_ref5) {
                                    var name = _ref5.name,
                                        value = _ref5.value;
                                    return _defineProperty({}, name, new ResultInspector(value));
                                })))), options);
                            }

                        case "tuple":
                            {
                                var _coercedResult3 = this.result; //if everything is named, do same as with struct.
                                //if not, just do an array.
                                //(good behavior in the mixed case is hard, unfortunately)

                                if (_coercedResult3.value.every(function(_ref7) {
                                        var name = _ref7.name;
                                        return name;
                                    })) {
                                    return util_1.default.inspect(Object.assign.apply(Object, [{}].concat(_toConsumableArray(_coercedResult3.value.map(function(_ref8) {
                                        var name = _ref8.name,
                                            value = _ref8.value;
                                        return _defineProperty({}, name, new ResultInspector(value));
                                    })))), options);
                                } else {
                                    return util_1.default.inspect(_coercedResult3.value.map(function(_ref10) {
                                        var value = _ref10.value;
                                        return new ResultInspector(value);
                                    }), options);
                                }
                            }

                        case "type":
                            {
                                switch (this.result.type.type.typeClass) {
                                    case "contract":
                                        //same as struct case but w/o circularity check
                                        return util_1.default.inspect(Object.assign.apply(Object, [{}].concat(_toConsumableArray(this.result.value.map(function(_ref11) {
                                            var name = _ref11.name,
                                                value = _ref11.value;
                                            return _defineProperty({}, name, new ResultInspector(value));
                                        })))), options);

                                    case "enum":
                                        {
                                            return enumTypeName(this.result.type.type);
                                        }
                                }
                            }

                        case "magic":
                            return util_1.default.inspect(Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(this.result.value).map(function(_ref13) {
                                var _ref14 = _slicedToArray(_ref13, 2),
                                    key = _ref14[0],
                                    value = _ref14[1];

                                return _defineProperty({}, key, new ResultInspector(value));
                            })))), options);

                        case "enum":
                            {
                                return enumFullName(this.result); //not stylized
                            }

                        case "contract":
                            {
                                return util_1.default.inspect(new ContractInfoInspector(this.result.value), options);
                            }

                        case "function":
                            switch (this.result.type.visibility) {
                                case "external":
                                    {
                                        var _coercedResult4 = this.result;
                                        var contractString = util_1.default.inspect(new ContractInfoInspector(_coercedResult4.value.contract), Object.assign(Object.assign({}, cleanStylize(options)), {
                                            colors: false
                                        }));
                                        var firstLine;

                                        switch (_coercedResult4.value.kind) {
                                            case "known":
                                                firstLine = "[Function: ".concat(_coercedResult4.value.abi.name, " of");
                                                break;

                                            case "invalid":
                                            case "unknown":
                                                firstLine = "[Function: Unknown selector ".concat(_coercedResult4.value.selector, " of");
                                                break;
                                        }

                                        var secondLine = "".concat(contractString, "]");
                                        var breakingSpace = firstLine.length + secondLine.length + 1 > options.breakLength ? "\n" : " "; //now, put it together

                                        return options.stylize(firstLine + breakingSpace + secondLine, "special");
                                    }

                                case "internal":
                                    {
                                        var _coercedResult5 = this.result;

                                        switch (_coercedResult5.value.kind) {
                                            case "function":
                                                if (_coercedResult5.value.definedIn) {
                                                    return options.stylize("[Function: ".concat(_coercedResult5.value.definedIn.typeName, ".").concat(_coercedResult5.value.name, "]"), "special");
                                                } else {
                                                    return options.stylize("[Function: ".concat(_coercedResult5.value.name, "]"), "special");
                                                }

                                            case "exception":
                                                return _coercedResult5.value.deployedProgramCounter === 0 ? options.stylize("[Function: <zero>]", "special") : options.stylize("[Function: <uninitialized>]", "special");

                                            case "unknown":
                                                var _firstLine = "[Function: decoding not supported (raw info:";

                                                var _secondLine = "deployed PC=".concat(_coercedResult5.value.deployedProgramCounter, ", constructor PC=").concat(_coercedResult5.value.constructorProgramCounter, ")]");

                                                var _breakingSpace = _firstLine.length + _secondLine.length + 1 > options.breakLength ? "\n" : " "; //now, put it together


                                                return options.stylize(_firstLine + _breakingSpace + _secondLine, "special");
                                        }
                                    }
                            }

                    }

                case "error":
                    {
                        debug("this.result: %O", this.result);
                        var errorResult = this.result; //the hell?? why couldn't it make this inference??

                        switch (errorResult.error.kind) {
                            case "UintPaddingError":
                                return "Uint has incorrect padding (expected padding: ".concat(errorResult.error.paddingType, ") (raw value ").concat(errorResult.error.raw, ")");

                            case "IntPaddingError":
                                return "Int has incorrect padding (expected padding: ".concat(errorResult.error.paddingType, ") (raw value ").concat(errorResult.error.raw, ")");

                            case "UintPaddingError":
                                return "Ufixed has (expected padding: ".concat(errorResult.error.paddingType, ") (raw value ").concat(errorResult.error.raw, ")");

                            case "FixedPaddingError":
                                return "Fixed has incorrect padding (expected padding: ".concat(errorResult.error.paddingType, ") (raw value ").concat(errorResult.error.raw, ")");

                            case "BoolOutOfRangeError":
                                return "Invalid boolean (numeric value ".concat(errorResult.error.rawAsBN.toString(), ")");

                            case "BoolPaddingError":
                                return "Boolean has incorrect padding (expected padding: ".concat(errorResult.error.paddingType, ") (raw value ").concat(errorResult.error.raw, ")");

                            case "BytesPaddingError":
                                return "Bytestring has extra trailing bytes (padding error) (raw value ".concat(errorResult.error.raw, ")");

                            case "AddressPaddingError":
                                return "Address has incorrect padding (expected padding: ".concat(errorResult.error.paddingType, ") (raw value ").concat(errorResult.error.raw, ")");

                            case "EnumOutOfRangeError":
                                return "Invalid ".concat(enumTypeName(errorResult.error.type), " (numeric value ").concat(errorResult.error.rawAsBN.toString(), ")");

                            case "EnumPaddingError":
                                return "Enum ".concat(enumTypeName(errorResult.error.type), " has incorrect padding (expected padding: ").concat(errorResult.error.paddingType, ") (raw value ").concat(errorResult.error.raw, ")");

                            case "EnumNotFoundDecodingError":
                                return "Unknown enum type ".concat(enumTypeName(errorResult.error.type), " of id ").concat(errorResult.error.type.id, " (numeric value ").concat(errorResult.error.rawAsBN.toString(), ")");

                            case "ContractPaddingError":
                                return "Contract address has incorrect padding (expected padding: ".concat(errorResult.error.paddingType, ") (raw value ").concat(errorResult.error.raw, ")");

                            case "FunctionExternalNonStackPaddingError":
                                return "External function has incorrect padding (expected padding: ".concat(errorResult.error.paddingType, ") (raw value ").concat(errorResult.error.raw, ")");

                            case "FunctionExternalStackPaddingError":
                                return "External function address or selector has extra leading bytes (padding error) (raw address ".concat(errorResult.error.rawAddress, ", raw selector ").concat(errorResult.error.rawSelector, ")");

                            case "FunctionInternalPaddingError":
                                return "Internal function has incorrect padding (expected padding: ".concat(errorResult.error.paddingType, ") (raw value ").concat(errorResult.error.raw, ")");

                            case "NoSuchInternalFunctionError":
                                return "Invalid function (Deployed PC=".concat(errorResult.error.deployedProgramCounter, ", constructor PC=").concat(errorResult.error.constructorProgramCounter, ") of contract ").concat(errorResult.error.context.typeName);

                            case "DeployedFunctionInConstructorError":
                                return "Deployed-style function (PC=".concat(errorResult.error.deployedProgramCounter, ") in constructor");

                            case "MalformedInternalFunctionError":
                                return "Malformed internal function w/constructor PC only (value: ".concat(errorResult.error.constructorProgramCounter, ")");

                            case "IndexedReferenceTypeError":
                                //for this one we'll bother with some line-wrapping
                                var _firstLine2 = "Cannot decode indexed parameter of reference type ".concat(errorResult.error.type.typeClass);

                                var _secondLine2 = "(raw value ".concat(errorResult.error.raw, ")");

                                var _breakingSpace2 = _firstLine2.length + _secondLine2.length + 1 > options.breakLength ? "\n" : " ";

                                return _firstLine2 + _breakingSpace2 + _secondLine2;

                            case "OverlongArraysAndStringsNotImplementedError":
                                return "Array or string is too long (length ".concat(errorResult.error.lengthAsBN.toString(), "); decoding is not supported");

                            case "OverlargePointersNotImplementedError":
                                return "Pointer is too large (value ".concat(errorResult.error.pointerAsBN.toString(), "); decoding is not supported");

                            case "UserDefinedTypeNotFoundError":
                            case "UnsupportedConstantError":
                            case "UnusedImmutableError":
                            case "ReadErrorStack":
                            case "ReadErrorStorage":
                            case "ReadErrorBytes":
                                return Exception.message(errorResult.error);
                                //yay, these five are already defined!
                        }
                    }
            }
        }
    }]);

    return ResultInspector;
}();

exports.ResultInspector = ResultInspector; //these get their own class to deal with a minor complication

var ContractInfoInspector = /*#__PURE__*/ function() {
    function ContractInfoInspector(value) {
        _classCallCheck(this, ContractInfoInspector);

        this.value = value;
    }

    _createClass(ContractInfoInspector, [{
        key: util_1.default.inspect.custom,
        value: function value(depth, options) {
            switch (this.value.kind) {
                case "known":
                    return options.stylize(this.value.address, "number") + " (".concat(this.value.class.typeName, ")");

                case "unknown":
                    return options.stylize(this.value.address, "number") + " of unknown class";
            }
        }
    }]);

    return ContractInfoInspector;
}();

function enumTypeName(enumType) {
    return (enumType.kind === "local" ? enumType.definingContractName + "." : "") + enumType.typeName;
} //this function will be used in the future for displaying circular
//structures


function formatCircular(loopLength, options) {
    return options.stylize("[Circular (=up ".concat(loopLength, ")]"), "special");
}

function enumFullName(value) {
    switch (value.type.kind) {
        case "local":
            return "".concat(value.type.definingContractName, ".").concat(value.type.typeName, ".").concat(value.value.name);

        case "global":
            return "".concat(value.type.typeName, ".").concat(value.value.name);
    }
}
/**
 * WARNING! Do NOT use this function in real code unless you
 * absolutely have to!  Using it in controlled tests is fine,
 * but do NOT use it in real code if you have any better option!
 * See [[unsafeNativize]] for why!
 */


function unsafeNativizeVariables(variables) {
    return Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(variables).map(function(_ref16) {
        var _ref17 = _slicedToArray(_ref16, 2),
            name = _ref17[0],
            value = _ref17[1];

        try {
            return _defineProperty({}, name, unsafeNativize(value));
        } catch (_) {
            return undefined; //I guess??
        }
    }))));
}

exports.unsafeNativizeVariables = unsafeNativizeVariables; //HACK! Avoid using!

/**
 * WARNING! Do NOT use this function in real code unless you absolutely have
 * to!  Using it in controlled tests is fine, but do NOT use it in real code if
 * you have any better option!
 *
 * This function is a giant hack.  It will throw exceptions on numbers that
 * don't fit in a Javascript number.  It loses various information.  It was
 * only ever written to support our hacked-together watch expression system,
 * and later repurposed to make testing easier.
 *
 * If you are not doing something as horrible as evaluating user-inputted
 * Javascript expressions meant to operate upon Solidity variables, then you
 * probably have a better option than using this in real code!
 *
 * (For instance, if you just want to nicely print individual values, without
 * attempting to first operate on them via Javascript expressions, we have the
 * [[ResultInspector]] class, which can be used with Node's
 * [util.inspect()](https://nodejs.org/api/util.html#util_util_inspect_object_options)
 * to do exactly that.)
 *
 * Remember, the decoder output format was made to be machine-readable.  It
 * shouldn't be too hard for you to process.  If it comes to it, copy-paste
 * this code and dehackify it for your use case, which hopefully is more
 * manageable than the one that caused us to write this.
 */

function unsafeNativize(result) {
    return unsafeNativizeWithTable(result, []);
}

exports.unsafeNativize = unsafeNativize;

function unsafeNativizeWithTable(result, seenSoFar) {
    if (result.kind === "error") {
        debug("ErrorResult: %O", result);

        switch (result.error.kind) {
            case "BoolOutOfRangeError":
                return true;

            default:
                return undefined;
        }
    } //NOTE: for simplicity, only arrays & structs will call unsafeNativizeWithTable;
    //other containers will just call unsafeNativize because they can get away with it
    //(only things that can *be* circular need unsafeNativizeWithTable, not things that
    //can merely *contain* circularities)


    switch (result.type.typeClass) {
        case "uint":
        case "int":
            return result.value.asBN.toNumber();
            //WARNING

        case "bool":
            return result.value.asBoolean;

        case "bytes":
            return result.value.asHex;

        case "address":
            return result.value.asAddress;

        case "string":
            {
                var coercedResult = result;

                switch (coercedResult.value.kind) {
                    case "valid":
                        return coercedResult.value.asString;

                    case "malformed":
                        // this will turn malformed utf-8 into replacement characters (U+FFFD) (WARNING)
                        // note we need to cut off the 0x prefix
                        return Buffer.from(coercedResult.value.asHex.slice(2), "hex").toString();
                }
            }

        case "fixed":
        case "ufixed":
            //HACK: Big doesn't have a toNumber() method, so we convert to string and then parse with Number
            //NOTE: we don't bother setting the magic variables Big.NE or Big.PE first, as the choice of
            //notation shouldn't affect the result (can you believe I have to write this? @_@)
            return Number(result.value.asBig.toString());
            //WARNING

        case "array":
            {
                var _coercedResult6 = result;

                if (_coercedResult6.reference === undefined) {
                    //we need to do some pointer stuff here, so let's first create our new
                    //object we'll be pointing to
                    //[we don't want to alter the original accidentally so let's clone a bit]
                    var output = _toConsumableArray(_coercedResult6.value); //now, we can't use a map here, or we'll screw things up!
                    //we want to *mutate* output, not replace it with a new object


                    for (var index in output) {
                        output[index] = unsafeNativizeWithTable(output[index], [output].concat(_toConsumableArray(seenSoFar)));
                    }

                    return output;
                } else {
                    return seenSoFar[_coercedResult6.reference - 1];
                }
            }

        case "mapping":
            return Object.assign.apply(Object, [{}].concat(_toConsumableArray(result.value.map(function(_ref19) {
                var key = _ref19.key,
                    value = _ref19.value;
                return _defineProperty({}, unsafeNativize(key).toString(), unsafeNativize(value));
            }))));

        case "struct":
            {
                var _coercedResult7 = result;

                if (_coercedResult7.reference === undefined) {
                    //we need to do some pointer stuff here, so let's first create our new
                    //object we'll be pointing to
                    var _output = Object.assign.apply(Object, [{}].concat(_toConsumableArray(result.value.map(function(_ref21) {
                        var name = _ref21.name,
                            value = _ref21.value;
                        return _defineProperty({}, name, value);
                    })))); //now, we can't use a map here, or we'll screw things up!
                    //we want to *mutate* output, not replace it with a new object


                    for (var name in _output) {
                        _output[name] = unsafeNativizeWithTable(_output[name], [_output].concat(_toConsumableArray(seenSoFar)));
                    }

                    return _output;
                } else {
                    return seenSoFar[_coercedResult7.reference - 1];
                }
            }

        case "type":
            switch (result.type.type.typeClass) {
                case "contract":
                    return Object.assign.apply(Object, [{}].concat(_toConsumableArray(result.value.map(function(_ref23) {
                        var name = _ref23.name,
                            value = _ref23.value;
                        return _defineProperty({}, name, unsafeNativize(value));
                    }))));

                case "enum":
                    return Object.assign.apply(Object, [{}].concat(_toConsumableArray(result.value.map(function(enumValue) {
                        return _defineProperty({}, enumValue.value.name, unsafeNativize(enumValue));
                    }))));
            }

        case "tuple":
            return result.value.map(function(_ref26) {
                var value = _ref26.value;
                return unsafeNativize(value);
            });

        case "magic":
            return Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.entries(result.value).map(function(_ref27) {
                var _ref28 = _slicedToArray(_ref27, 2),
                    key = _ref28[0],
                    value = _ref28[1];

                return _defineProperty({}, key, unsafeNativize(value));
            }))));

        case "enum":
            return enumFullName(result);

        case "contract":
            return result.value.address;
            //we no longer include additional info

        case "function":
            switch (result.type.visibility) {
                case "external":
                    {
                        var _coercedResult8 = result;

                        switch (_coercedResult8.value.kind) {
                            case "known":
                                return "".concat(_coercedResult8.value.contract.class.typeName, "(").concat(_coercedResult8.value.contract.address, ").").concat(_coercedResult8.value.abi.name);

                            case "invalid":
                                return "".concat(_coercedResult8.value.contract.class.typeName, "(").concat(_coercedResult8.value.contract.address, ").call(").concat(_coercedResult8.value.selector, "...)");

                            case "unknown":
                                return "".concat(_coercedResult8.value.contract.address, ".call(").concat(_coercedResult8.value.selector, "...)");
                        }
                    }

                case "internal":
                    {
                        var _coercedResult9 = result;

                        switch (_coercedResult9.value.kind) {
                            case "function":
                                if (_coercedResult9.value.definedIn) {
                                    return "".concat(_coercedResult9.value.definedIn.typeName, ".").concat(_coercedResult9.value.name);
                                } else {
                                    return _coercedResult9.value.name;
                                }

                            case "exception":
                                return _coercedResult9.value.deployedProgramCounter === 0 ? "<zero>" : "<uninitialized>";

                            case "unknown":
                                return "<decoding not supported>";
                        }
                    }
            }

    }
}