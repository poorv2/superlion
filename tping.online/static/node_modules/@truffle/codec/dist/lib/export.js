"use strict";

function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {};
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true,
        didErr = false,
        err;
    return {
        s: function s() {
            it = o[Symbol.iterator]();
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally {
                if (didErr) throw err;
            }
        }
    };
}

function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
    }
    return arr2;
}

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});

var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
        for (var k in mod) {
            if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }

    __setModuleDefault(result, mod);

    return result;
};

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.nativizeEventArgs = exports.nativizeReturn = exports.nativize = exports.unsafeNativize = exports.ResultInspector = void 0;

var debug_1 = __importDefault(require("debug"));

var debug = debug_1.default("codec:export");

var Conversion = __importStar(require("./conversion"));

var inspect_1 = require("./format/utils/inspect");

Object.defineProperty(exports, "ResultInspector", {
    enumerable: true,
    get: function get() {
        return inspect_1.ResultInspector;
    }
});
Object.defineProperty(exports, "unsafeNativize", {
    enumerable: true,
    get: function get() {
        return inspect_1.unsafeNativize;
    }
});
/**
 * This function is similar to
 * [[Format.Utils.Inspect.unsafeNativize|unsafeNativize]], but is intended to
 * be safe, and also allows for different output formats.  The only currently
 * supported format is "ethers", which is intended to match the way that
 * Truffle Contract currently returns values (based on the Ethers decoder).  As
 * such, it only handles ABI types, and in addition does not handle the types
 * fixed, ufixed, or function.  Note that in these cases it returns `undefined`
 * rather than throwing, as we want this function to be used in contexts where
 * it had better not throw.  It also does not handle circularities, for similar
 * reasons.
 *
 * To handle numeric types, this function takes an optional numberFormatter
 * option that tells it how to handle numbers; this function should take a
 * BigInt as input.  By default, this function will be the identity, and so
 * numbers will be represented as BigInts.
 *
 * Note that this function begins by calling abify, so out-of-range enums (that
 * aren't so out-of-range as to be padding errors) will not return `undefined`.
 * Out-of-range booleans similarly will return true rather than `undefined`.
 * However, other range errors may return `undefined`; this may technically be a
 * slight incompatibility with existing behavior, but should not be relevant
 * except in quite unusual cases.
 *
 * In order to match the behavior for tuples, tuples will be transformed into
 * arrays, but named entries will additionally be keyed by name.  Moreover,
 * indexed variables of reference type will be nativized to an undecoded hex
 * string.
 */

function nativize(result) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var numberFormatter = options.numberFormatter || function(x) {
        return x;
    };

    var format = options.format || "ethers";

    switch (format) {
        case "ethers":
            return ethersCompatibleNativize(result, numberFormatter);
    }
}

exports.nativize = nativize;

function ethersCompatibleNativize(result) {
    var numberFormatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function(x) {
        return x;
    };

    //note: the original version of this function began by calling abify,
    //but we don't do that here because abify requires a userDefinedTypes
    //parameter and we don't want that.
    //However, it only needs that to handle getting the types right.  Since
    //we don't care about that here, we instead do away with abify and handle
    //such matters ourselves (which is less convenient, yeah).
    switch (result.kind) {
        case "error":
            switch (result.error.kind) {
                case "IndexedReferenceTypeError":
                    //strictly speaking for arrays ethers will fail to decode
                    //rather than do this, but, eh
                    return result.error.raw;

                case "EnumOutOfRangeError":
                    return numberFormatter(Conversion.toBigInt(result.error.rawAsBN));

                default:
                    return undefined;
            }

        case "value":
            switch (result.type.typeClass) {
                case "uint":
                case "int":
                    var asBN = result.value.asBN;
                    return numberFormatter(Conversion.toBigInt(asBN));

                case "enum":
                    var numericAsBN = result.value.numericAsBN;
                    return numberFormatter(Conversion.toBigInt(numericAsBN));

                case "bool":
                    return result.value.asBoolean;

                case "bytes":
                    return result.value.asHex;

                case "address":
                    return result.value.asAddress;

                case "contract":
                    return result.value.address;

                case "string":
                    {
                        var coercedResult = result;

                        switch (coercedResult.value.kind) {
                            case "valid":
                                return coercedResult.value.asString;

                            case "malformed":
                                // this will turn malformed utf-8 into replacement characters (U+FFFD) (WARNING)
                                // note we need to cut off the 0x prefix
                                return Buffer.from(coercedResult.value.asHex.slice(2), "hex").toString();
                        }
                    }

                case "array":
                    return result.value.map(function(value) {
                        return ethersCompatibleNativize(value, numberFormatter);
                    });

                case "tuple":
                case "struct":
                    //in this case, we need the result to be an array, but also
                    //to have the field names (where extant) as keys
                    var nativized = [];
                    var pairs = result.value;

                    var _iterator = _createForOfIteratorHelper(pairs),
                        _step;

                    try {
                        for (_iterator.s(); !(_step = _iterator.n()).done;) {
                            var _step$value = _step.value,
                                name = _step$value.name,
                                value = _step$value.value;
                            var nativizedValue = ethersCompatibleNativize(value, numberFormatter);
                            nativized.push(nativizedValue);

                            if (name) {
                                nativized[name] = nativizedValue;
                            }
                        }
                    } catch (err) {
                        _iterator.e(err);
                    } finally {
                        _iterator.f();
                    }

                    return nativized;

                case "function":
                    switch (result.type.visibility) {
                        case "external":
                            var _coercedResult = result; //ethers per se doesn't handle this, but web3's hacked version will
                            //sometimes decode these as just a bytes24, so let's do that

                            return _coercedResult.value.contract.address.toLowerCase() + _coercedResult.value.selector.slice(2);

                        case "internal":
                            return undefined;
                    }

                case "fixed":
                case "ufixed":
                default:
                    return undefined;
            }

    }
}
/**
 * This function is similar to [[nativize]], but takes
 * a [[ReturndataDecoding]].  If there's only one returned value, it
 * will be run through compatibleNativize but otherwise unaltered;
 * otherwise the results will be put in an object.
 *
 * Note that if the ReturndataDecoding is not a [[ReturnDecoding]],
 * this will just return `undefined`.
 */


function nativizeReturn(decoding) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var numberFormatter = options.numberFormatter || function(x) {
        return x;
    };

    var format = options.format || "ethers";

    switch (format) {
        case "ethers":
            return ethersCompatibleNativizeReturn(decoding, numberFormatter);
    }
}

exports.nativizeReturn = nativizeReturn;

function ethersCompatibleNativizeReturn(decoding) {
    var numberFormatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function(x) {
        return x;
    };

    if (decoding.kind !== "return") {
        return undefined;
    }

    if (decoding.arguments.length === 1) {
        return ethersCompatibleNativize(decoding.arguments[0].value, numberFormatter);
    }

    var result = {};

    for (var i = 0; i < decoding.arguments.length; i++) {
        var _decoding$arguments$i = decoding.arguments[i],
            name = _decoding$arguments$i.name,
            value = _decoding$arguments$i.value;
        var nativized = ethersCompatibleNativize(value, numberFormatter);
        result[i] = nativized;

        if (name) {
            result[name] = nativized;
        }
    }

    return result;
}
/**
 * This function is similar to [[compatibleNativize]], but takes
 * a [[LogDecoding]], and puts the results in an object.  Note
 * that this does not return the entire event info, but just the
 * `args` for the event.
 */


function nativizeEventArgs(decoding) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var numberFormatter = options.numberFormatter || function(x) {
        return x;
    };

    var format = options.format || "ethers";

    switch (format) {
        case "ethers":
            return ethersCompatibleNativizeEventArgs(decoding, numberFormatter);
    }
}

exports.nativizeEventArgs = nativizeEventArgs;

function ethersCompatibleNativizeEventArgs(decoding) {
    var numberFormatter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function(x) {
        return x;
    };
    var result = {};

    for (var i = 0; i < decoding.arguments.length; i++) {
        var _decoding$arguments$i2 = decoding.arguments[i],
            name = _decoding$arguments$i2.name,
            value = _decoding$arguments$i2.value;
        var nativized = ethersCompatibleNativize(value, numberFormatter);
        result[i] = nativized;

        if (name) {
            result[name] = nativized;
        }
    } //note: if you have an argument named __length__, what ethers
    //actually does is... weird.  we're just going to do this instead,
    //which is simpler and probably more useful, even if it's not strictly
    //the same (I *seriously* doubt anyone was relying on the old behavior,
    //because it's, uh, not very useful)


    result.__length__ = decoding.arguments.length;
    return result;
}