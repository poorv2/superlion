"use strict";

function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {};
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true,
        didErr = false,
        err;
    return {
        s: function s() {
            it = o[Symbol.iterator]();
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally {
                if (didErr) throw err;
            }
        }
    };
}

function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
    }
    return arr2;
}

var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.simpleShimSourceMap = exports.getContractNode = exports.shimContracts = exports.shimArtifacts = exports.shimCompilation = exports.shimCompilations = void 0;

var debug_1 = __importDefault(require("debug"));

var debug = debug_1.default("codec:compilations:utils");

function shimCompilations(inputCompilations) {
    var shimmedCompilationIdPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "shimmedcompilation";
    return inputCompilations.map(function(compilation, compilationIndex) {
        return shimCompilation(compilation, "".concat(shimmedCompilationIdPrefix, "Number(").concat(compilationIndex, ")"));
    });
}

exports.shimCompilations = shimCompilations;

function shimCompilation(inputCompilation) {
    var shimmedCompilationId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "shimmedcompilation";
    return Object.assign(Object.assign({}, shimContracts(inputCompilation.contracts, {
        files: inputCompilation.sourceIndexes,
        sources: inputCompilation.sources,
        shimmedCompilationId: shimmedCompilationId,
        compiler: inputCompilation.compiler
    })), {
        compiler: inputCompilation.compiler
    });
}

exports.shimCompilation = shimCompilation;
/**
 * wrapper around shimContracts that just returns
 * the result in a one-element array (keeping the old name
 * shimArtifacts for compatibility)
 */

function shimArtifacts(artifacts, files) {
    var shimmedCompilationId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "shimmedcompilation";
    return [shimContracts(artifacts, {
        files: files,
        shimmedCompilationId: shimmedCompilationId
    })];
}

exports.shimArtifacts = shimArtifacts;
/**
 * shims a bunch of contracts ("artifacts", though not necessarily)
 * to a compilation.  usually used via one of the above functions.
 * Note: if you pass in options.sources, options.files will be ignored.
 * Note: if you pass in options.sources, sources will not have
 * compiler set unless you also pass in options.compiler; in this case
 * you should set that up separately, as in shimCompilation().
 */

function shimContracts(artifacts) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var files = options.files,
        inputSources = options.sources;
    var shimmedCompilationId = options.shimmedCompilationId || "shimmedcompilation";
    var contracts = [];
    var sources = [];
    var unreliableSourceOrder = false;

    var _iterator = _createForOfIteratorHelper(artifacts),
        _step;

    try {
        var _loop = function _loop() {
            var artifact = _step.value;
            var contractName = artifact.contractName,
                bytecode = artifact.bytecode,
                sourceMap = artifact.sourceMap,
                deployedBytecode = artifact.deployedBytecode,
                deployedSourceMap = artifact.deployedSourceMap,
                immutableReferences = artifact.immutableReferences,
                sourcePath = artifact.sourcePath,
                source = artifact.source,
                ast = artifact.ast,
                abi = artifact.abi,
                compiler = artifact.compiler,
                generatedSources = artifact.generatedSources,
                deployedGeneratedSources = artifact.deployedGeneratedSources;

            if (artifact.contract_name) {
                //just in case
                contractName = artifact.contract_name; //dunno what's up w/ the type of contract_name, but it needs coercing
            }

            debug("contractName: %s", contractName);
            var contractObject = {
                contractName: contractName,
                bytecode: bytecode,
                sourceMap: sourceMap,
                deployedBytecode: deployedBytecode,
                deployedSourceMap: deployedSourceMap,
                immutableReferences: immutableReferences,
                abi: abi,
                generatedSources: normalizeGeneratedSources(generatedSources, compiler),
                deployedGeneratedSources: normalizeGeneratedSources(deployedGeneratedSources, compiler),
                compiler: compiler
            };
            var sourceObject = {
                sourcePath: sourcePath,
                source: source,
                ast: ast,
                compiler: compiler,
                language: inferLanguage(ast, compiler)
            }; //ast needs to be coerced because schema doesn't quite match our types here...
            //if files or sources was passed, trust that to determine the source index

            if (files || inputSources) {
                //note: we never set the unreliableSourceOrder flag in this branch;
                //we just trust files/sources.  If this info is bad, then, uh, too bad.
                var _index2 = inputSources ? inputSources.findIndex(function(source) {
                    return source.sourcePath === sourcePath;
                }) : files.indexOf(sourcePath);

                if (!inputSources) {
                    //if inputSources was passed, we'll handle this separately below
                    sourceObject.id = _index2.toString(); //HACK

                    sources[_index2] = sourceObject;
                }

                contractObject.primarySourceId = _index2.toString(); //HACK
            } else {
                //if neither was passed, attempt to determine it from the ast
                var _index3;

                if (sourceObject.ast) {
                    //note: this works for both Solidity and Vyper
                    _index3 = sourceIndexForAst(sourceObject.ast); //sourceObject.ast for typing reasons
                } else if (compiler && compiler.name === "vyper") {
                    _index3 = 0; //if it's Vyper but there's no AST, we can
                    //assume that it was compiled alone and therefore has index 0
                } //if that didn't work, try the source map


                if (_index3 === undefined && (sourceMap || deployedSourceMap)) {
                    var sourceMapString = simpleShimSourceMap(deployedSourceMap || sourceMap);
                    _index3 = extractPrimarySource(sourceMapString);
                } //else leave undefined for now


                var _getIndexToAddAt = getIndexToAddAt(sourceObject, _index3, sources, unreliableSourceOrder);

                _index3 = _getIndexToAddAt.index;
                unreliableSourceOrder = _getIndexToAddAt.unreliableSourceOrder;

                if (_index3 !== null) {
                    //if we're in this case, inputSources was not passed
                    sourceObject.id = _index3.toString(); //HACK

                    sources[_index3] = sourceObject;
                    contractObject.primarySourceId = _index3.toString();
                }
            }

            contracts.push(contractObject);
        };

        for (_iterator.s(); !(_step = _iterator.n()).done;) {
            _loop();
        } //now: check for id overlap with internal sources
        //(don't bother if inputSources or files was passed)

    } catch (err) {
        _iterator.e(err);
    } finally {
        _iterator.f();
    }

    if (!inputSources && !files) {
        var _iterator2 = _createForOfIteratorHelper(contracts),
            _step2;

        try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var contract = _step2.value;
                var generatedSources = contract.generatedSources,
                    deployedGeneratedSources = contract.deployedGeneratedSources;

                for (var index in generatedSources) {
                    if (index in sources) {
                        unreliableSourceOrder = true;
                    }
                }

                for (var _index in deployedGeneratedSources) {
                    if (_index in sources) {
                        unreliableSourceOrder = true;
                    }
                }
            }
        } catch (err) {
            _iterator2.e(err);
        } finally {
            _iterator2.f();
        }
    }

    var compiler;

    if (options.compiler) {
        compiler = options.compiler;
    } else if (!unreliableSourceOrder && contracts.length > 0) {
        //if things were actually compiled together, we should just be able
        //to pick an arbitrary one
        compiler = contracts[0].compiler;
    } //if input sources was passed, set up the sources object directly :)


    if (inputSources) {
        sources = inputSources.map(function(_ref, index) {
            var sourcePath = _ref.sourcePath,
                source = _ref.contents,
                ast = _ref.ast,
                language = _ref.language;
            return {
                sourcePath: sourcePath,
                source: source,
                ast: ast,
                language: language,
                id: index.toString(),
                compiler: compiler //redundant but let's include it

            };
        });
    }

    return {
        id: shimmedCompilationId,
        unreliableSourceOrder: unreliableSourceOrder,
        sources: sources,
        contracts: contracts,
        compiler: compiler
    };
}

exports.shimContracts = shimContracts; //note: this works for Vyper too!

function sourceIndexForAst(ast) {
    if (Array.isArray(ast)) {
        //special handling for old Vyper versions
        ast = ast[0];
    }

    if (!ast) {
        return undefined;
    }

    return parseInt(ast.src.split(":")[2]); //src is given as start:length:file.
    //we want just the file.
}

function getContractNode(contract, compilation) {
    var contractName = contract.contractName,
        sourceMap = contract.sourceMap,
        deployedSourceMap = contract.deployedSourceMap,
        primarySourceId = contract.primarySourceId;
    var unreliableSourceOrder = compilation.unreliableSourceOrder,
        sources = compilation.sources;
    var sourcesToCheck; //we will attempt to locate the primary source;
    //if we can't find it, we'll just check every source in this
    //compilation.

    if (primarySourceId !== undefined) {
        sourcesToCheck = [sources.find(function(source) {
            return source && source.id === primarySourceId;
        })];
    } else if (!unreliableSourceOrder && (deployedSourceMap || sourceMap)) {
        var sourceMapString = simpleShimSourceMap(deployedSourceMap || sourceMap);
        var sourceId = extractPrimarySource(sourceMapString);
        sourcesToCheck = [sources[sourceId]];
    } else {
        //WARNING: if we end up in this case, we could get the wrong contract!
        //(but we shouldn't end up here)
        sourcesToCheck = sources;
    }

    return sourcesToCheck.reduce(function(foundNode, source) {
        if (foundNode || !source) {
            return foundNode;
        }

        if (!source.ast || source.language !== "Solidity") {
            //ignore non-Solidity ASTs for now, we don't support them yet
            return undefined;
        }

        return source.ast.nodes.find(function(node) {
            return node.nodeType === "ContractDefinition" && node.name === contractName;
        });
    }, undefined);
}

exports.getContractNode = getContractNode;
/**
 * extract the primary source from a source map
 * (i.e., the source for the first instruction, found
 * between the second and third colons)
 */

function extractPrimarySource(sourceMap) {
    if (!sourceMap) {
        //HACK?
        return 0; //in this case (e.g. a Vyper contract with an old-style
        //source map) we infer that it was compiled by itself
    }

    return parseInt(sourceMap.match(/^[^:]+:[^:]+:([^:]+):/)[1]);
}

function normalizeGeneratedSources(generatedSources, compiler) {
    if (!generatedSources) {
        return [];
    }

    if (!isGeneratedSources(generatedSources)) {
        return generatedSources; //if already normalizeed, leave alone
    }

    var sources = []; //output

    var _iterator3 = _createForOfIteratorHelper(generatedSources),
        _step3;

    try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var source = _step3.value;
            sources[source.id] = {
                id: source.id.toString(),
                sourcePath: source.name,
                source: source.contents,
                //ast needs to be coerced because schema doesn't quite match our types here...
                ast: source.ast,
                compiler: compiler,
                language: source.language
            };
        }
    } catch (err) {
        _iterator3.e(err);
    } finally {
        _iterator3.f();
    }

    return sources;
} //HACK


function isGeneratedSources(sources) {
    //note: for some reason arr.includes(undefined) returns true on sparse arrays
    //if sources.length === 0, it's ambiguous; we'll exclude it as not needing normalization
    return sources.length > 0 && !sources.includes(undefined) && (sources[0].contents !== undefined || sources[0].name !== undefined);
} //HACK, maybe?


function inferLanguage(ast, compiler) {
    if (ast) {
        if (ast.nodeType === "SourceUnit") {
            return "Solidity";
        } else if (ast.nodeType && ast.nodeType.startsWith("Yul")) {
            //Every Yul source I've seen has YulBlock as the root, but
            //I'm not sure that that's *always* the case
            return "Yul";
        } else if (Array.isArray(ast) || ast.ast_type === "Module") {
            return "Vyper";
        }
    } else if (compiler) {
        if (compiler.name === "vyper") {
            return "Vyper";
        } else if (compiler.name === "solc") {
            //if it's solc but no AST, just assume it's Solidity
            return "Solidity";
        } else {
            return undefined;
        }
    } else {
        return undefined;
    }
}

function getIndexToAddAt(sourceObject, index, sources, unreliableSourceOrder) {
    //first: is this already there? only add it if it's not.
    //(we determine this by sourcePath if present, and the actual source
    //contents if not)
    debug("sourcePath: %s", sourceObject.sourcePath);
    debug("given index: %d", index);
    debug("sources: %o", sources.map(function(source) {
        return source.sourcePath;
    }));

    if (sources.every(function(existingSource) {
            return existingSource.sourcePath !== sourceObject.sourcePath || !sourceObject.sourcePath && !existingSource.sourcePath && existingSource.source !== sourceObject.source;
        })) {
        if (unreliableSourceOrder || index === undefined || index in sources) {
            //if we can't add it at the correct spot, set the
            //unreliable source order flag
            debug("collision!");
            unreliableSourceOrder = true;
        } //otherwise, just leave things alone


        if (unreliableSourceOrder) {
            //in case of unreliable source order, we'll ignore what indices
            //things are *supposed* to have and just append things to the end
            index = sources.length;
        }

        return {
            index: index,
            unreliableSourceOrder: unreliableSourceOrder
        };
    } else {
        //return index: null indicates don't add this because it's
        //already present
        debug("already present, not adding");
        return {
            index: null,
            unreliableSourceOrder: unreliableSourceOrder
        };
    }
}
/**
 * convert Vyper source maps to solidity ones
 * (note we won't bother handling the case where the compressed
 * version doesn't exist; that will have to wait for a later version)
 */


function simpleShimSourceMap(sourceMap) {
    if (sourceMap === undefined) {
        return undefined; //undefined case
    } else if (typeof sourceMap === "object") {
        return sourceMap.pc_pos_map_compressed; //Vyper object case
    } else {
        try {
            return JSON.parse(sourceMap).pc_pos_map_compressed; //Vyper JSON case
        } catch (_) {
            return sourceMap; //Solidity case
        }
    }
}

exports.simpleShimSourceMap = simpleShimSourceMap;