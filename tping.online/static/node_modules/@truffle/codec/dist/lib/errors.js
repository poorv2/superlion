"use strict";

var _classCallCheck = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck");

var _possibleConstructorReturn = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf");

var _inherits = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits");

var _wrapNativeSuper = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper");

var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
            return m[k];
        }
    });
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});

var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null)
        for (var k in mod) {
            if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }

    __setModuleDefault(result, mod);

    return result;
};

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.handleDecodingError = exports.StopDecodingError = exports.DecodingError = void 0;

var Format = __importStar(require("./format")); //For when we need to throw an error, here's a wrapper class that extends Error.
//Apologies about the confusing name, but I wanted something that would make
//sense should it not be caught and thus accidentally exposed to the outside.

/**
 * @hidden
 */


var DecodingError = /*#__PURE__*/ function(_Error) {
    _inherits(DecodingError, _Error);

    function DecodingError(error) {
        var _this;

        _classCallCheck(this, DecodingError);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(DecodingError).call(this, Format.Utils.Exception.message(error)));
        _this.error = error;
        _this.name = "DecodingError";
        return _this;
    }

    return DecodingError;
}(_wrapNativeSuper(Error));

exports.DecodingError = DecodingError; //used to stop decoding; like DecodingError, but used in contexts
//where I don't expect it to be caught
//NOTE: currently we don't actually check the type of a thrown error,
//we just rely on context.  still, I think it makes sense to be a separate
//type.

/**
 * @hidden
 */

var StopDecodingError = /*#__PURE__*/ function(_Error2) {
    _inherits(StopDecodingError, _Error2);

    //when decoding in full mode, we allow an ABI-mode retry.  (if we were already in
    //ABI mode, we give up.)
    function StopDecodingError(error, allowRetry) {
        var _this2;

        _classCallCheck(this, StopDecodingError);

        var message = "Stopping decoding: ".concat(error.kind); //sorry about the bare-bones message,
        //but again, users shouldn't actually see this, so I think this should suffice for now

        _this2 = _possibleConstructorReturn(this, _getPrototypeOf(StopDecodingError).call(this, message));
        _this2.error = error;
        _this2.allowRetry = Boolean(allowRetry);
        return _this2;
    }

    return StopDecodingError;
}(_wrapNativeSuper(Error));

exports.StopDecodingError = StopDecodingError;
/**
 * @hidden
 */

function handleDecodingError(dataType, error) {
    var strict = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (error instanceof DecodingError) {
        //expected error
        if (strict) {
            //strict mode -- stop decoding on errors
            throw new StopDecodingError(error.error);
        } else {
            //nonstrict mode -- return an error result
            return {
                //I don't know why TS's inference is failing here and needs the coercion
                type: dataType,
                kind: "error",
                error: error.error
            };
        }
    } else {
        //if it's *not* an expected error, we better not swallow it -- rethrow!
        throw error;
    }
}

exports.handleDecodingError = handleDecodingError;