var _classCallCheck = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck");

var _createClass = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass");

var ANY = Symbol('SemVer ANY'); // hoisted class for cyclic dependency

var Comparator = /*#__PURE__*/ function() {
    "use strict";

    _createClass(Comparator, null, [{
        key: "ANY",
        get: function get() {
            return ANY;
        }
    }]);

    function Comparator(comp, options) {
        _classCallCheck(this, Comparator);

        options = parseOptions(options);

        if (comp instanceof Comparator) {
            if (comp.loose === !!options.loose) {
                return comp;
            } else {
                comp = comp.value;
            }
        }

        debug('comparator', comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);

        if (this.semver === ANY) {
            this.value = '';
        } else {
            this.value = this.operator + this.semver.version;
        }

        debug('comp', this);
    }

    _createClass(Comparator, [{
        key: "parse",
        value: function parse(comp) {
            var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
            var m = comp.match(r);

            if (!m) {
                throw new TypeError("Invalid comparator: ".concat(comp));
            }

            this.operator = m[1] !== undefined ? m[1] : '';

            if (this.operator === '=') {
                this.operator = '';
            } // if it literally is just '>' or '' then allow anything.


            if (!m[2]) {
                this.semver = ANY;
            } else {
                this.semver = new SemVer(m[2], this.options.loose);
            }
        }
    }, {
        key: "toString",
        value: function toString() {
            return this.value;
        }
    }, {
        key: "test",
        value: function test(version) {
            debug('Comparator.test', version, this.options.loose);

            if (this.semver === ANY || version === ANY) {
                return true;
            }

            if (typeof version === 'string') {
                try {
                    version = new SemVer(version, this.options);
                } catch (er) {
                    return false;
                }
            }

            return cmp(version, this.operator, this.semver, this.options);
        }
    }, {
        key: "intersects",
        value: function intersects(comp, options) {
            if (!(comp instanceof Comparator)) {
                throw new TypeError('a Comparator is required');
            }

            if (!options || typeof options !== 'object') {
                options = {
                    loose: !!options,
                    includePrerelease: false
                };
            }

            if (this.operator === '') {
                if (this.value === '') {
                    return true;
                }

                return new Range(comp.value, options).test(this.value);
            } else if (comp.operator === '') {
                if (comp.value === '') {
                    return true;
                }

                return new Range(this.value, options).test(comp.semver);
            }

            var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
            var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
            var sameSemVer = this.semver.version === comp.semver.version;
            var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
            var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
            var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');
            return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
        }
    }]);

    return Comparator;
}();

module.exports = Comparator;

var parseOptions = require('../internal/parse-options');

var _require = require('../internal/re'),
    re = _require.re,
    t = _require.t;

var cmp = require('../functions/cmp');

var debug = require('../internal/debug');

var SemVer = require('./semver');

var Range = require('./range');