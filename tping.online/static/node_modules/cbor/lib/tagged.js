'use strict';

var _classCallCheck = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck");

var _createClass = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass");

var bignumber = require('bignumber.js').BigNumber;

var utils = require('./utils');

var url = require('url');

var MINUS_ONE = new bignumber(-1);
var TWO = new bignumber(2);
/**
 * A CBOR tagged item, where the tag does not have semantics specified at the
 * moment, or those semantics threw an error during parsing. Typically this will
 * be an extension point you're not yet expecting.
 */

var Tagged = /*#__PURE__*/ function() {
    /**
     * Creates an instance of Tagged.
     *
     * @param {number} tag - the number of the tag
     * @param {any} value - the value inside the tag
     * @param {Error} [err] - the error that was thrown parsing the tag, or null
     */
    function Tagged(tag, value, err) {
        _classCallCheck(this, Tagged);

        this.tag = tag;
        this.value = value;
        this.err = err;

        if (typeof this.tag !== 'number') {
            throw new Error('Invalid tag type (' + typeof this.tag + ')');
        }

        if (this.tag < 0 || (this.tag | 0) !== this.tag) {
            throw new Error('Tag must be a positive integer: ' + this.tag);
        }
    }
    /**
     * Convert to a String
     *
     * @returns {string} string of the form '1(2)'
     */


    _createClass(Tagged, [{
        key: "toString",
        value: function toString() {
            return "".concat(this.tag, "(").concat(JSON.stringify(this.value), ")");
        }
        /**
         * Push the simple value onto the CBOR stream
         *
         * @param {Object} gen The generator to push onto
         */

    }, {
        key: "encodeCBOR",
        value: function encodeCBOR(gen) {
            gen._pushTag(this.tag);

            return gen.pushAny(this.value);
        }
        /**
         * If we have a converter for this type, do the conversion.  Some converters
         * are built-in.  Additional ones can be passed in.  If you want to remove
         * a built-in converter, pass a converter in whose value is 'null' instead
         * of a function.
         *
         * @param {Object} converters - keys in the object are a tag number, the value
         *   is a function that takes the decoded CBOR and returns a JavaScript value
         *   of the appropriate type.  Throw an exception in the function on errors.
         * @returns {any} - the converted item
         */

    }, {
        key: "convert",
        value: function convert(converters) {
            var f = converters != null ? converters[this.tag] : void 0;

            if (typeof f !== 'function') {
                f = Tagged['_tag_' + this.tag];

                if (typeof f !== 'function') {
                    return this;
                }
            }

            try {
                return f.call(Tagged, this.value);
            } catch (error) {
                this.err = error;
                return this;
            }
        }
    }], [{
        key: "_tag_0",
        value: function _tag_0(v) {
            return new Date(v);
        }
    }, {
        key: "_tag_1",
        value: function _tag_1(v) {
            return new Date(v * 1000);
        }
    }, {
        key: "_tag_2",
        value: function _tag_2(v) {
            return utils.bufferToBignumber(v);
        }
    }, {
        key: "_tag_3",
        value: function _tag_3(v) {
            return MINUS_ONE.minus(utils.bufferToBignumber(v));
        }
    }, {
        key: "_tag_4",
        value: function _tag_4(v) {
            return bignumber(v[1]).shiftedBy(v[0]);
        }
    }, {
        key: "_tag_5",
        value: function _tag_5(v) {
            return TWO.pow(v[0]).times(v[1]);
        }
    }, {
        key: "_tag_32",
        value: function _tag_32(v) {
            return url.parse(v);
        }
    }, {
        key: "_tag_35",
        value: function _tag_35(v) {
            return new RegExp(v);
        }
    }]);

    return Tagged;
}();

module.exports = Tagged;