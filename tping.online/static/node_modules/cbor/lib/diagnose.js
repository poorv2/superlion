'use strict';

var _classCallCheck = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck");

var _createClass = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass");

var _possibleConstructorReturn = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf");

var _inherits = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits");

var _assertThisInitialized = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized");

var stream = require('stream');

var util = require('util');

var Decoder = require('./decoder');

var Simple = require('./simple');

var utils = require('./utils');

var constants = require('./constants');

var bignumber = require('bignumber.js').BigNumber;

var NoFilter = require('nofilter');

var MT = constants.MT;
var SYMS = constants.SYMS;
/**
 * Output the diagnostic format from a stream of CBOR bytes.
 *
 * @extends {stream.Transform}
 */

var Diagnose = /*#__PURE__*/ function(_stream$Transform) {
    _inherits(Diagnose, _stream$Transform);

    /**
     * Creates an instance of Diagnose.
     *
     * @param {Object} [options={}] - options for creation
     * @param {string} [options.separator='\n'] - output between detected objects
     * @param {boolean} [options.stream_errors=false] - put error info into the
     *   output stream
     * @param {number} [options.max_depth=-1] - -1 for "until you run out of
     *   memory".  Set this to a finite positive number for un-trusted inputs.
     *   Most standard inputs won't nest more than 100 or so levels; I've tested
     *   into the millions before running out of memory.
     */
    function Diagnose(options) {
        var _this;

        _classCallCheck(this, Diagnose);

        var opts = Object.assign({
            separator: '\n',
            stream_errors: false
        }, options, {
            readableObjectMode: false,
            writableObjectMode: false
        });
        var separator = opts.separator;
        delete opts.separator;
        var stream_errors = opts.stream_errors;
        delete opts.stream_errors;
        _this = _possibleConstructorReturn(this, _getPrototypeOf(Diagnose).call(this, opts));
        _this.float_bytes = -1;
        _this.separator = separator;
        _this.stream_errors = stream_errors;
        _this.parser = new Decoder(opts);

        _this.parser.on('more-bytes', _this._on_more.bind(_assertThisInitialized(_assertThisInitialized(_this))));

        _this.parser.on('value', _this._on_value.bind(_assertThisInitialized(_assertThisInitialized(_this))));

        _this.parser.on('start', _this._on_start.bind(_assertThisInitialized(_assertThisInitialized(_this))));

        _this.parser.on('stop', _this._on_stop.bind(_assertThisInitialized(_assertThisInitialized(_this))));

        _this.parser.on('data', _this._on_data.bind(_assertThisInitialized(_assertThisInitialized(_this))));

        _this.parser.on('error', _this._on_error.bind(_assertThisInitialized(_assertThisInitialized(_this))));

        return _this;
    }

    _createClass(Diagnose, [{
        key: "_transform",
        value: function _transform(fresh, encoding, cb) {
            return this.parser.write(fresh, encoding, cb);
        }
    }, {
        key: "_flush",
        value: function _flush(cb) {
            var _this2 = this;

            return this.parser._flush(function(er) {
                if (_this2.stream_errors) {
                    if (er) {
                        _this2._on_error(er);
                    }

                    return cb();
                } else {
                    return cb(er);
                }
            });
        }
        /**
         * Convenience function to return a string in diagnostic format.
         *
         * @param {(Buffer|string)} input - the CBOR bytes to format
         * @param {string} [encoding='hex'] - the encoding of input, ignored if
         *   input is Buffer
         * @param {function(Error, string): undefined} cb - callback
         * @returns {Promise} if callback not specified
         */

    }, {
        key: "_on_error",
        value: function _on_error(er) {
            if (this.stream_errors) {
                return this.push(er.toString());
            } else {
                return this.emit('error', er);
            }
        }
    }, {
        key: "_on_more",
        value: function _on_more(mt, len, parent_mt, pos) {
            if (mt === MT.SIMPLE_FLOAT) {
                return this.float_bytes = {
                    2: 1,
                    4: 2,
                    8: 3
                }[len];
            }
        }
    }, {
        key: "_fore",
        value: function _fore(parent_mt, pos) {
            switch (parent_mt) {
                case MT.BYTE_STRING:
                case MT.UTF8_STRING:
                case MT.ARRAY:
                    if (pos > 0) {
                        return this.push(', ');
                    }

                    break;

                case MT.MAP:
                    if (pos > 0) {
                        if (pos % 2) {
                            return this.push(': ');
                        } else {
                            return this.push(', ');
                        }
                    }

            }
        }
    }, {
        key: "_on_value",
        value: function _on_value(val, parent_mt, pos) {
            var _this3 = this;

            if (val === SYMS.BREAK) {
                return;
            }

            this._fore(parent_mt, pos);

            return this.push(function() {
                switch (false) {
                    case val !== SYMS.NULL:
                        return 'null';

                    case val !== SYMS.UNDEFINED:
                        return 'undefined';

                    case typeof val !== 'string':
                        return JSON.stringify(val);

                    case !(_this3.float_bytes > 0):
                        var fb = _this3.float_bytes;
                        _this3.float_bytes = -1;
                        return util.inspect(val) + '_' + fb;

                    case !Buffer.isBuffer(val):
                        return 'h\'' + val.toString('hex') + '\'';

                    case !(val instanceof bignumber):
                        return val.toString();

                    default:
                        return util.inspect(val);
                }
            }());
        }
    }, {
        key: "_on_start",
        value: function _on_start(mt, tag, parent_mt, pos) {
            this._fore(parent_mt, pos);

            switch (mt) {
                case MT.TAG:
                    this.push("".concat(tag, "("));
                    break;

                case MT.ARRAY:
                    this.push('[');
                    break;

                case MT.MAP:
                    this.push('{');
                    break;

                case MT.BYTE_STRING:
                case MT.UTF8_STRING:
                    this.push('(');
                    break;
            }

            if (tag === SYMS.STREAM) {
                return this.push('_ ');
            }
        }
    }, {
        key: "_on_stop",
        value: function _on_stop(mt) {
            switch (mt) {
                case MT.TAG:
                    return this.push(')');

                case MT.ARRAY:
                    return this.push(']');

                case MT.MAP:
                    return this.push('}');

                case MT.BYTE_STRING:
                case MT.UTF8_STRING:
                    return this.push(')');
            }
        }
    }, {
        key: "_on_data",
        value: function _on_data() {
            return this.push(this.separator);
        }
    }], [{
        key: "diagnose",
        value: function diagnose(input, encoding, cb) {
            if (input == null) {
                throw new Error('input required');
            }

            var opts = {};
            var encod = 'hex';

            switch (typeof encoding) {
                case 'function':
                    cb = encoding;
                    encod = utils.guessEncoding(input);
                    break;

                case 'object':
                    opts = utils.extend({}, encoding);
                    encod = opts.encoding != null ? opts.encoding : utils.guessEncoding(input);
                    delete opts.encoding;
                    break;

                default:
                    encod = encoding != null ? encoding : 'hex';
            }

            var bs = new NoFilter();
            var d = new Diagnose(opts);
            var p = null;

            if (typeof cb === 'function') {
                d.on('end', function() {
                    return cb(null, bs.toString('utf8'));
                });
                d.on('error', cb);
            } else {
                p = new Promise(function(resolve, reject) {
                    d.on('end', function() {
                        return resolve(bs.toString('utf8'));
                    });
                    return d.on('error', reject);
                });
            }

            d.pipe(bs);
            d.end(input, encod);
            return p;
        }
    }]);

    return Diagnose;
}(stream.Transform);

module.exports = Diagnose;