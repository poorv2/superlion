'use strict';

var _regeneratorRuntime = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator");

var _classCallCheck = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck");

var _createClass = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass");

var _possibleConstructorReturn = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf");

var _inherits = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits");

var stream = require('stream');

var BinaryParseStream = require('../vendor/binary-parse-stream');

var Tagged = require('./tagged');

var Simple = require('./simple');

var utils = require('./utils');

var bignumber = require('bignumber.js').BigNumber;

var NoFilter = require('nofilter');

var constants = require('./constants'); // Do not fix this if you want to support node v4


var MT = constants.MT;
var NUMBYTES = constants.NUMBYTES;
var SIMPLE = constants.SIMPLE;
var SYMS = constants.SYMS;
var BI = utils.bigIntize(constants.BI);
var BN = constants.BN;
var COUNT = Symbol('count');
var PENDING_KEY = Symbol('pending_key');
var MAJOR = Symbol('major type');
var ERROR = Symbol('error');
var NOT_FOUND = Symbol('not found');

function parentArray(parent, typ, count) {
    var a = [];
    a[COUNT] = count;
    a[SYMS.PARENT] = parent;
    a[MAJOR] = typ;
    return a;
}

function parentBufferStream(parent, typ) {
    var b = new NoFilter();
    b[COUNT] = -1;
    b[SYMS.PARENT] = parent;
    b[MAJOR] = typ;
    return b;
}
/**
 * @param {Buffer} v
 * @private
 */


function _tag_2(v) {
    return utils.bufferToBigInt(v);
}
/**
 * @param {BigInt} v
 * @private
 */


function _tag_3(v) {
    // avoid syntax error on old runtimes
    return BI.MINUS_ONE - utils.bufferToBigInt(v);
}
/**
 * Decode a stream of CBOR bytes by transforming them into equivalent
 * JavaScript data.  Because of the limitations of Node object streams,
 * special symbols are emitted instead of NULL or UNDEFINED.  Fix those
 * up by calling {@link Decoder.nullcheck}.
 *
 * @extends {BinaryParseStream}
 */


var Decoder = /*#__PURE__*/ function(_BinaryParseStream) {
    _inherits(Decoder, _BinaryParseStream);

    /**
     * Create a parsing stream.
     *
     * @param {object} [options={}]
     * @param {number} [options.max_depth=-1] - the maximum depth to parse.
     *   Use -1 for "until you run out of memory".  Set this to a finite
     *   positive number for un-trusted inputs.  Most standard inputs won't nest
     *   more than 100 or so levels; I've tested into the millions before
     *   running out of memory.
     * @param {object} [options.tags] - mapping from tag number to function(v),
     *   where v is the decoded value that comes after the tag, and where the
     *   function returns the correctly-created value for that tag.
     * @param {boolean} [options.bigint=false] generate JavaScript BigInt's
     *   instead of BigNumbers, when possible.  TODO: when BigInt's are
     *   more prevalent, change this to default to the value of cbor.hasBigInt.
     */
    function Decoder(options) {
        var _this;

        _classCallCheck(this, Decoder);

        options = options || {};
        var tags = options.tags;
        delete options.tags;
        var max_depth = options.max_depth != null ? options.max_depth : -1;
        delete options.max_depth;
        var bigI = utils.hasBigInt ? !!options.bigint : false;
        delete options.bigint;
        _this = _possibleConstructorReturn(this, _getPrototypeOf(Decoder).call(this, options));
        _this.running = true;
        _this.max_depth = max_depth;
        _this.tags = tags;

        if (bigI) {
            if (_this.tags == null) {
                _this.tags = {};
            }

            if (_this.tags[2] == null) {
                _this.tags[2] = _tag_2;
            }

            if (_this.tags[3] == null) {
                _this.tags[3] = _tag_3;
            }
        }

        return _this;
    }
    /**
     * Check the given value for a symbol encoding a NULL or UNDEFINED value in
     * the CBOR stream.
     *
     * @static
     * @param {any} val - the value to check
     * @returns {any} the corrected value
     *
     * @example
     * myDecoder.on('data', function(val) {
     *   val = Decoder.nullcheck(val);
     *   ...
     * });
     */


    _createClass(Decoder, [{
        key: "close",

        /**
         * Stop processing
         */
        value: function close() {
            this.running = false;
            this.__fresh = true;
        }
    }, {
        key: "_parse",
        value: /*#__PURE__*/ _regeneratorRuntime.mark(function _parse() {
            var parent, depth, val, octet, mt, ai, parent_major, parent_length, numbytes, buf, hasParent, again, pm, allstrings, i, len, _i, _len, _i2, _len2, t, old;

            return _regeneratorRuntime.wrap(function _parse$(_context) {
                while (1) {
                    switch (_context.prev = _context.next) {
                        case 0:
                            parent = null;
                            depth = 0;
                            val = null;

                        case 3:
                            if (!true) {
                                _context.next = 151;
                                break;
                            }

                            if (!(this.max_depth >= 0 && depth > this.max_depth)) {
                                _context.next = 6;
                                break;
                            }

                            throw new Error('Maximum depth ' + this.max_depth + ' exceeded');

                        case 6:
                            _context.next = 8;
                            return 1;

                        case 8:
                            octet = _context.sent[0];

                            if (this.running) {
                                _context.next = 11;
                                break;
                            }

                            throw new Error('Unexpected data: 0x' + octet.toString(16));

                        case 11:
                            mt = octet >> 5;
                            ai = octet & 0x1f;
                            parent_major = parent != null ? parent[MAJOR] : undefined;
                            parent_length = parent != null ? parent.length : undefined;
                            _context.t0 = ai;
                            _context.next = _context.t0 === NUMBYTES.ONE ? 18 : _context.t0 === NUMBYTES.TWO ? 23 : _context.t0 === NUMBYTES.FOUR ? 23 : _context.t0 === NUMBYTES.EIGHT ? 23 : _context.t0 === 28 ? 30 : _context.t0 === 29 ? 30 : _context.t0 === 30 ? 30 : _context.t0 === NUMBYTES.INDEFINITE ? 32 : 38;
                            break;

                        case 18:
                            this.emit('more-bytes', mt, 1, parent_major, parent_length);
                            _context.next = 21;
                            return 1;

                        case 21:
                            val = _context.sent[0];
                            return _context.abrupt("break", 39);

                        case 23:
                            numbytes = 1 << ai - 24;
                            this.emit('more-bytes', mt, numbytes, parent_major, parent_length);
                            _context.next = 27;
                            return numbytes;

                        case 27:
                            buf = _context.sent;
                            val = mt === MT.SIMPLE_FLOAT ? buf : utils.parseCBORint(ai, buf);
                            return _context.abrupt("break", 39);

                        case 30:
                            this.running = false;
                            throw new Error('Additional info not implemented: ' + ai);

                        case 32:
                            _context.t1 = mt;
                            _context.next = _context.t1 === MT.POS_INT ? 35 : _context.t1 === MT.NEG_INT ? 35 : _context.t1 === MT.TAG ? 35 : 36;
                            break;

                        case 35:
                            throw new Error("Invalid indefinite encoding for MT ".concat(mt));

                        case 36:
                            val = -1;
                            return _context.abrupt("break", 39);

                        case 38:
                            val = ai;

                        case 39:
                            _context.t2 = mt;
                            _context.next = _context.t2 === MT.POS_INT ? 42 : _context.t2 === MT.NEG_INT ? 43 : _context.t2 === MT.BYTE_STRING ? 45 : _context.t2 === MT.UTF8_STRING ? 45 : _context.t2 === MT.ARRAY ? 61 : _context.t2 === MT.MAP ? 61 : _context.t2 === MT.TAG ? 75 : _context.t2 === MT.SIMPLE_FLOAT ? 80 : 88;
                            break;

                        case 42:
                            return _context.abrupt("break", 88);

                        case 43:
                            if (val === Number.MAX_SAFE_INTEGER) {
                                val = BN.NEG_MAX;
                            } else if (val instanceof bignumber) {
                                val = BN.MINUS_ONE.minus(val);
                            } else {
                                val = -1 - val;
                            }

                            return _context.abrupt("break", 88);

                        case 45:
                            _context.t3 = val;
                            _context.next = _context.t3 === 0 ? 48 : _context.t3 === -1 ? 51 : 55;
                            break;

                        case 48:
                            this.emit('start-string', mt, val, parent_major, parent_length);
                            val = mt === MT.BYTE_STRING ? Buffer.allocUnsafe(0) : '';
                            return _context.abrupt("break", 60);

                        case 51:
                            this.emit('start', mt, SYMS.STREAM, parent_major, parent_length);
                            parent = parentBufferStream(parent, mt);
                            depth++;
                            return _context.abrupt("continue", 3);

                        case 55:
                            this.emit('start-string', mt, val, parent_major, parent_length);
                            _context.next = 58;
                            return val;

                        case 58:
                            val = _context.sent;

                            if (mt === MT.UTF8_STRING) {
                                val = utils.utf8(val);
                            }

                        case 60:
                            return _context.abrupt("break", 88);

                        case 61:
                            _context.t4 = val;
                            _context.next = _context.t4 === 0 ? 64 : _context.t4 === -1 ? 66 : 70;
                            break;

                        case 64:
                            val = mt === MT.MAP ? {} : [];
                            return _context.abrupt("break", 74);

                        case 66:
                            this.emit('start', mt, SYMS.STREAM, parent_major, parent_length);
                            parent = parentArray(parent, mt, -1);
                            depth++;
                            return _context.abrupt("continue", 3);

                        case 70:
                            this.emit('start', mt, val, parent_major, parent_length);
                            parent = parentArray(parent, mt, val * (mt - 3));
                            depth++;
                            return _context.abrupt("continue", 3);

                        case 74:
                            return _context.abrupt("break", 88);

                        case 75:
                            this.emit('start', mt, val, parent_major, parent_length);
                            parent = parentArray(parent, mt, 1);
                            parent.push(val);
                            depth++;
                            return _context.abrupt("continue", 3);

                        case 80:
                            if (!(typeof val === 'number')) {
                                _context.next = 87;
                                break;
                            }

                            if (!(ai === NUMBYTES.ONE && val < 32)) {
                                _context.next = 83;
                                break;
                            }

                            throw new Error("Invalid two-byte encoding of simple value ".concat(val));

                        case 83:
                            hasParent = parent != null;
                            val = Simple.decode(val, hasParent, hasParent && parent[COUNT] < 0);
                            _context.next = 88;
                            break;

                        case 87:
                            val = utils.parseCBORfloat(val);

                        case 88:
                            this.emit('value', val, parent_major, parent_length, ai);
                            again = false;

                        case 90:
                            if (!(parent != null)) {
                                _context.next = 147;
                                break;
                            }

                            _context.t5 = false;
                            _context.next = _context.t5 === (val !== SYMS.BREAK) ? 94 : _context.t5 === !Array.isArray(parent) ? 96 : _context.t5 === !(parent instanceof NoFilter) ? 98 : 103;
                            break;

                        case 94:
                            parent[COUNT] = 1;
                            return _context.abrupt("break", 103);

                        case 96:
                            parent.push(val);
                            return _context.abrupt("break", 103);

                        case 98:
                            pm = parent[MAJOR];

                            if (!(pm != null && pm !== mt)) {
                                _context.next = 102;
                                break;
                            }

                            this.running = false;
                            throw new Error('Invalid major type in indefinite encoding');

                        case 102:
                            parent.write(val);

                        case 103:
                            if (!(--parent[COUNT] !== 0)) {
                                _context.next = 106;
                                break;
                            }

                            again = true;
                            return _context.abrupt("break", 147);

                        case 106:
                            --depth;
                            delete parent[COUNT];

                            if (!Array.isArray(parent)) {
                                _context.next = 132;
                                break;
                            }

                            _context.t6 = parent[MAJOR];
                            _context.next = _context.t6 === MT.ARRAY ? 112 : _context.t6 === MT.MAP ? 114 : _context.t6 === MT.TAG ? 127 : 130;
                            break;

                        case 112:
                            val = parent;
                            return _context.abrupt("break", 130);

                        case 114:
                            allstrings = true;

                            if (!(parent.length % 2 !== 0)) {
                                _context.next = 117;
                                break;
                            }

                            throw new Error('Invalid map length: ' + parent.length);

                        case 117:
                            i = 0, len = parent.length;

                        case 118:
                            if (!(i < len)) {
                                _context.next = 125;
                                break;
                            }

                            if (!(typeof parent[i] !== 'string')) {
                                _context.next = 122;
                                break;
                            }

                            allstrings = false;
                            return _context.abrupt("break", 125);

                        case 122:
                            i += 2;
                            _context.next = 118;
                            break;

                        case 125:
                            if (allstrings) {
                                val = {};

                                for (_i = 0, _len = parent.length; _i < _len; _i += 2) {
                                    val[parent[_i]] = parent[_i + 1];
                                }
                            } else {
                                val = new Map();

                                for (_i2 = 0, _len2 = parent.length; _i2 < _len2; _i2 += 2) {
                                    val.set(parent[_i2], parent[_i2 + 1]);
                                }
                            }

                            return _context.abrupt("break", 130);

                        case 127:
                            t = new Tagged(parent[0], parent[1]);
                            val = t.convert(this.tags);
                            return _context.abrupt("break", 130);

                        case 130:
                            _context.next = 140;
                            break;

                        case 132:
                            if (!(parent instanceof NoFilter)) {
                                _context.next = 140;
                                break;
                            }

                            _context.t7 = parent[MAJOR];
                            _context.next = _context.t7 === MT.BYTE_STRING ? 136 : _context.t7 === MT.UTF8_STRING ? 138 : 140;
                            break;

                        case 136:
                            val = parent.slice();
                            return _context.abrupt("break", 140);

                        case 138:
                            val = parent.toString('utf-8');
                            return _context.abrupt("break", 140);

                        case 140:
                            this.emit('stop', parent[MAJOR]);
                            old = parent;
                            parent = parent[SYMS.PARENT];
                            delete old[SYMS.PARENT];
                            delete old[MAJOR];
                            _context.next = 90;
                            break;

                        case 147:
                            if (again) {
                                _context.next = 149;
                                break;
                            }

                            return _context.abrupt("return", val);

                        case 149:
                            _context.next = 3;
                            break;

                        case 151:
                        case "end":
                            return _context.stop();
                    }
                }
            }, _parse, this);
        })
    }], [{
        key: "nullcheck",
        value: function nullcheck(val) {
            switch (val) {
                case SYMS.NULL:
                    return null;

                case SYMS.UNDEFINED:
                    return undefined;

                case NOT_FOUND:
                    throw new Error('Value not found');

                default:
                    return val;
            }
        }
        /**
         * @typedef DecodeOptions
         * @property {string} [encoding='hex'] - The encoding of the input.
         *   Ignored if input is a Buffer.
         */

        /**
         * Decode the first CBOR item in the input, synchronously.  This will throw an
         * exception if the input is not valid CBOR.
         *
         * @static
         * @param {string|Buffer|stream.Readable} input
         * @param {DecodeOptions|string} [options] Options
         * @returns {any} - the decoded value
         */

    }, {
        key: "decodeFirstSync",
        value: function decodeFirstSync(input, options) {
            options = options || {
                encoding: 'hex'
            };
            var opts = {};
            var encod;

            switch (typeof options) {
                case 'string':
                    encod = options;
                    break;

                case 'object':
                    opts = utils.extend({}, options);
                    encod = opts.encoding;
                    delete opts.encoding;
                    break;
            }

            var c = new Decoder(opts);
            var s = input instanceof stream.Readable ? input : new NoFilter(input, encod != null ? encod : utils.guessEncoding(input)); // for/of doesn't work when you need to call next() with a value
            // generator created by parser will be "done" after each CBOR entity
            // parser will yield numbers of bytes that it wants

            var parser = c._parse();

            var state = parser.next();

            while (!state.done) {
                var b = s.read(state.value);

                if (b == null || b.length !== state.value) {
                    throw new Error('Insufficient data');
                }

                state = parser.next(b);
            }

            var val = Decoder.nullcheck(state.value);

            if (s.length > 0) {
                var nextByte = s.read(1);
                s.unshift(nextByte);
                var er = new Error('Unexpected data: 0x' + nextByte[0].toString(16));
                er.value = val;
                throw er;
            }

            return val;
        }
        /**
         * Decode all of the CBOR items in the input into an array.  This will throw
         * an exception if the input is not valid CBOR; a zero-length input will
         * return an empty array.
         *
         * @static
         * @param {string|Buffer|stream.Readable} input
         * @param {DecodeOptions|string} [options] Options or encoding string
         * @returns {Array} - Array of all found items
         */

    }, {
        key: "decodeAllSync",
        value: function decodeAllSync(input, options) {
            options = options || {
                encoding: 'hex'
            };
            var opts = {};
            var encod;

            switch (typeof options) {
                case 'string':
                    encod = options;
                    break;

                case 'object':
                    opts = utils.extend({}, options);
                    encod = opts.encoding;
                    delete opts.encoding;
            }

            var c = new Decoder(opts);
            var s = input instanceof stream.Readable ? input : new NoFilter(input, encod != null ? encod : utils.guessEncoding(input));
            var res = [];

            while (s.length > 0) {
                var parser = c._parse();

                var state = parser.next();

                while (!state.done) {
                    var b = s.read(state.value);

                    if (b == null || b.length !== state.value) {
                        throw new Error('Insufficient data');
                    }

                    state = parser.next(b);
                }

                res.push(Decoder.nullcheck(state.value));
            }

            return res;
        }
        /**
         * @callback decodeCallback
         * @param {Error} [error] - if one was generated
         * @param {any} [value] - the decoded value
         */

        /**
         * Decode the first CBOR item in the input.  This will error if there are more
         * bytes left over at the end, and optionally if there were no valid CBOR
         * bytes in the input.  Emits the {Decoder.NOT_FOUND} Symbol in the callback
         * if no data was found and the `required` option is false.
         *
         * @static
         * @param {string|Buffer} input - the input to parse
         * @param {DecodeOptions|decodeCallback|string} [options] - options
         * @param {decodeCallback} [cb] callback
         * @returns {Promise<any>} returned even if callback is specified
         */

    }, {
        key: "decodeFirst",
        value: function decodeFirst(input, options, cb) {
            var opts = {};
            var required = false;
            var encod = 'hex';

            switch (typeof options) {
                case 'function':
                    cb = options;
                    encod = utils.guessEncoding(input);
                    break;

                case 'string':
                    encod = options;
                    break;

                case 'object':
                    opts = utils.extend({}, options);
                    encod = opts.encoding != null ? opts.encoding : utils.guessEncoding(input);
                    delete opts.encoding;
                    required = opts.required != null ? opts.required : false;
                    delete opts.required;
            }

            var c = new Decoder(opts);
            var v = NOT_FOUND;
            var p = new Promise(function(resolve, reject) {
                c.on('data', function(val) {
                    v = Decoder.nullcheck(val);
                    c.close();
                });
                c.once('error', function(er) {
                    if (v !== NOT_FOUND) {
                        er.value = v;
                    }

                    v = ERROR;
                    c.close();
                    return reject(er);
                });
                c.once('end', function() {
                    switch (v) {
                        case NOT_FOUND:
                            if (required) {
                                return reject(new Error('No CBOR found'));
                            } else {
                                return resolve(v);
                            }

                        case ERROR:
                            return void 0;

                        default:
                            return resolve(v);
                    }
                });
            });

            if (typeof cb === 'function') {
                p.then(function(v) {
                    return cb(null, v);
                }, cb);
            }

            c.end(input, encod);
            return p;
        }
        /**
         * @callback decodeAllCallback
         * @param {Error} error - if one was generated
         * @param {Array} value - all of the decoded values, wrapped in an Array
         */

        /**
         * Decode all of the CBOR items in the input.  This will error if there are
         * more bytes left over at the end.
         *
         * @static
         * @param {(string|Buffer)} input - the input to parse
         * @param {(string|Object)} options - Decoding options.
         *   If string, the input encoding.
         * @param {decodeAllCallback} cb callback
         * @returns {Promise<Array>} even if callback is specified
         */

    }, {
        key: "decodeAll",
        value: function decodeAll(input, options, cb) {
            var opts = {};
            var encod = 'hex';

            switch (typeof options) {
                case 'function':
                    cb = options;
                    encod = utils.guessEncoding(input);
                    break;

                case 'string':
                    encod = options;
                    break;

                case 'object':
                    opts = utils.extend({}, options);
                    encod = opts.encoding != null ? opts.encoding : utils.guessEncoding(input);
                    delete opts.encoding;
            }

            var c = new Decoder(opts);
            var vals = [];
            c.on('data', function(val) {
                return vals.push(Decoder.nullcheck(val));
            });
            var p = new Promise(function(resolve, reject) {
                c.on('error', reject);
                c.on('end', function() {
                    return resolve(vals);
                });
            });

            if (typeof cb === 'function') {
                p.then(function(v) {
                    return cb(null, v);
                }, cb);
            }

            c.end(input, encod);
            return p;
        }
    }]);

    return Decoder;
}(BinaryParseStream);

Decoder.NOT_FOUND = NOT_FOUND;
module.exports = Decoder;