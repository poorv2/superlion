var _regeneratorRuntime = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator");

var _asyncToGenerator = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator");

var _classCallCheck = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck");

var _createClass = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass");

var _possibleConstructorReturn = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf");

var _inherits = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits");

var EthQuery = require('eth-query');

var pify = require('pify');

var BaseFilterWithHistory = require('./base-filter-history');

var _require = require('./hexUtils'),
    bnToHex = _require.bnToHex,
    hexToInt = _require.hexToInt,
    incrementHexInt = _require.incrementHexInt,
    minBlockRef = _require.minBlockRef,
    blockRefIsNumber = _require.blockRefIsNumber;

var LogFilter = /*#__PURE__*/ function(_BaseFilterWithHistor) {
    "use strict";

    _inherits(LogFilter, _BaseFilterWithHistor);

    function LogFilter(_ref) {
        var _this;

        var provider = _ref.provider,
            params = _ref.params;

        _classCallCheck(this, LogFilter);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(LogFilter).call(this));
        _this.type = 'log';
        _this.ethQuery = new EthQuery(provider);
        _this.params = Object.assign({
            fromBlock: 'latest',
            toBlock: 'latest',
            address: undefined,
            topics: []
        }, params); // normalize address parameter

        if (_this.params.address) {
            // ensure array
            if (!Array.isArray(_this.params.address)) {
                _this.params.address = [_this.params.address];
            } // ensure lowercase


            _this.params.address = _this.params.address.map(function(address) {
                return address.toLowerCase();
            });
        }

        return _this;
    }

    _createClass(LogFilter, [{
        key: "initialize",
        value: function() {
            var _initialize = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee(_ref2) {
                var currentBlock, fromBlock, toBlock, params, newLogs;
                return _regeneratorRuntime.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                currentBlock = _ref2.currentBlock;
                                // resolve params.fromBlock
                                fromBlock = this.params.fromBlock;
                                if (['latest', 'pending'].includes(fromBlock)) fromBlock = currentBlock;
                                if ('earliest' === fromBlock) fromBlock = '0x0';
                                this.params.fromBlock = fromBlock; // set toBlock for initial lookup

                                toBlock = minBlockRef(this.params.toBlock, currentBlock);
                                params = Object.assign({}, this.params, {
                                    toBlock: toBlock
                                }); // fetch logs and add to results

                                _context.next = 9;
                                return this._fetchLogs(params);

                            case 9:
                                newLogs = _context.sent;
                                this.addInitialResults(newLogs);

                            case 11:
                            case "end":
                                return _context.stop();
                        }
                    }
                }, _callee, this);
            }));

            function initialize(_x) {
                return _initialize.apply(this, arguments);
            }

            return initialize;
        }()
    }, {
        key: "update",
        value: function() {
            var _update = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee2(_ref3) {
                var _this2 = this;

                var oldBlock, newBlock, toBlock, fromBlock, params, newLogs, matchingLogs;
                return _regeneratorRuntime.wrap(function _callee2$(_context2) {
                    while (1) {
                        switch (_context2.prev = _context2.next) {
                            case 0:
                                oldBlock = _ref3.oldBlock, newBlock = _ref3.newBlock;
                                // configure params for this update
                                toBlock = newBlock;

                                // oldBlock is empty on first sync
                                if (oldBlock) {
                                    fromBlock = incrementHexInt(oldBlock);
                                } else {
                                    fromBlock = newBlock;
                                } // fetch logs


                                params = Object.assign({}, this.params, {
                                    fromBlock: fromBlock,
                                    toBlock: toBlock
                                });
                                _context2.next = 6;
                                return this._fetchLogs(params);

                            case 6:
                                newLogs = _context2.sent;
                                matchingLogs = newLogs.filter(function(log) {
                                    return _this2.matchLog(log);
                                }); // add to results

                                this.addResults(matchingLogs);

                            case 9:
                            case "end":
                                return _context2.stop();
                        }
                    }
                }, _callee2, this);
            }));

            function update(_x2) {
                return _update.apply(this, arguments);
            }

            return update;
        }()
    }, {
        key: "_fetchLogs",
        value: function() {
            var _fetchLogs2 = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee3(params) {
                var _this3 = this;

                var newLogs;
                return _regeneratorRuntime.wrap(function _callee3$(_context3) {
                    while (1) {
                        switch (_context3.prev = _context3.next) {
                            case 0:
                                _context3.next = 2;
                                return pify(function(cb) {
                                    return _this3.ethQuery.getLogs(params, cb);
                                })();

                            case 2:
                                newLogs = _context3.sent;
                                return _context3.abrupt("return", newLogs);

                            case 4:
                            case "end":
                                return _context3.stop();
                        }
                    }
                }, _callee3);
            }));

            function _fetchLogs(_x3) {
                return _fetchLogs2.apply(this, arguments);
            }

            return _fetchLogs;
        }()
    }, {
        key: "matchLog",
        value: function matchLog(log) {
            // check if block number in bounds:
            if (hexToInt(this.params.fromBlock) >= hexToInt(log.blockNumber)) return false;
            if (blockRefIsNumber(this.params.toBlock) && hexToInt(this.params.toBlock) <= hexToInt(log.blockNumber)) return false; // address is correct:

            var normalizedLogAddress = log.address && log.address.toLowerCase();
            if (this.params.address && normalizedLogAddress && !this.params.address.includes(normalizedLogAddress)) return false; // topics match:
            // topics are position-dependant
            // topics can be nested to represent `or` [[a || b], c]
            // topics can be null, representing a wild card for that position

            var topicsMatch = this.params.topics.every(function(topicPattern, index) {
                // pattern is longer than actual topics
                var logTopic = log.topics[index];
                if (!logTopic) return false;
                logTopic = logTopic.toLowerCase(); // normalize subTopics

                var subtopicsToMatch = Array.isArray(topicPattern) ? topicPattern : [topicPattern]; // check for wild card

                var subtopicsIncludeWildcard = subtopicsToMatch.includes(null);
                if (subtopicsIncludeWildcard) return true;
                subtopicsToMatch = subtopicsToMatch.map(function(topic) {
                    return topic.toLowerCase();
                }); // check each possible matching topic

                var topicDoesMatch = subtopicsToMatch.includes(logTopic);
                return topicDoesMatch;
            });
            return topicsMatch;
        }
    }]);

    return LogFilter;
}(BaseFilterWithHistory);

module.exports = LogFilter;