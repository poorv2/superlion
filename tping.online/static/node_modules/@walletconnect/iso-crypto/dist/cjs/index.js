"use strict";

var _regeneratorRuntime = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator");

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.decrypt = exports.encrypt = exports.verifyHmac = exports.generateKey = void 0;

var tslib_1 = require("tslib");

var isoCrypto = tslib_1.__importStar(require("@pedrouid/iso-crypto"));

var encUtils = tslib_1.__importStar(require("enc-utils"));

var utils_1 = require("@walletconnect/utils");

function generateKey(length) {
    return tslib_1.__awaiter(this, void 0, void 0, /*#__PURE__*/ _regeneratorRuntime.mark(function _callee() {
        var _length, bytes, result;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        _length = (length || 256) / 8;
                        bytes = isoCrypto.randomBytes(_length);
                        result = utils_1.convertBufferToArrayBuffer(encUtils.arrayToBuffer(bytes));
                        return _context.abrupt("return", result);

                    case 4:
                    case "end":
                        return _context.stop();
                }
            }
        }, _callee);
    }));
}

exports.generateKey = generateKey;

function verifyHmac(payload, key) {
    return tslib_1.__awaiter(this, void 0, void 0, /*#__PURE__*/ _regeneratorRuntime.mark(function _callee2() {
        var cipherText, iv, hmac, hmacHex, unsigned, chmac, chmacHex;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
                switch (_context2.prev = _context2.next) {
                    case 0:
                        cipherText = encUtils.hexToArray(payload.data);
                        iv = encUtils.hexToArray(payload.iv);
                        hmac = encUtils.hexToArray(payload.hmac);
                        hmacHex = encUtils.arrayToHex(hmac, false);
                        unsigned = encUtils.concatArrays(cipherText, iv);
                        _context2.next = 7;
                        return isoCrypto.hmacSha256Sign(key, unsigned);

                    case 7:
                        chmac = _context2.sent;
                        chmacHex = encUtils.arrayToHex(chmac, false);

                        if (!(encUtils.removeHexPrefix(hmacHex) === encUtils.removeHexPrefix(chmacHex))) {
                            _context2.next = 11;
                            break;
                        }

                        return _context2.abrupt("return", true);

                    case 11:
                        return _context2.abrupt("return", false);

                    case 12:
                    case "end":
                        return _context2.stop();
                }
            }
        }, _callee2);
    }));
}

exports.verifyHmac = verifyHmac;

function encrypt(data, key, providedIv) {
    return tslib_1.__awaiter(this, void 0, void 0, /*#__PURE__*/ _regeneratorRuntime.mark(function _callee3() {
        var _key, ivArrayBuffer, iv, ivHex, contentString, content, cipherText, cipherTextHex, unsigned, hmac, hmacHex;

        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
                switch (_context3.prev = _context3.next) {
                    case 0:
                        _key = encUtils.bufferToArray(utils_1.convertArrayBufferToBuffer(key));
                        _context3.t0 = providedIv;

                        if (_context3.t0) {
                            _context3.next = 6;
                            break;
                        }

                        _context3.next = 5;
                        return generateKey(128);

                    case 5:
                        _context3.t0 = _context3.sent;

                    case 6:
                        ivArrayBuffer = _context3.t0;
                        iv = encUtils.bufferToArray(utils_1.convertArrayBufferToBuffer(ivArrayBuffer));
                        ivHex = encUtils.arrayToHex(iv, false);
                        contentString = JSON.stringify(data);
                        content = encUtils.utf8ToArray(contentString);
                        _context3.next = 13;
                        return isoCrypto.aesCbcEncrypt(iv, _key, content);

                    case 13:
                        cipherText = _context3.sent;
                        cipherTextHex = encUtils.arrayToHex(cipherText, false);
                        unsigned = encUtils.concatArrays(cipherText, iv);
                        _context3.next = 18;
                        return isoCrypto.hmacSha256Sign(_key, unsigned);

                    case 18:
                        hmac = _context3.sent;
                        hmacHex = encUtils.arrayToHex(hmac, false);
                        return _context3.abrupt("return", {
                            data: cipherTextHex,
                            hmac: hmacHex,
                            iv: ivHex
                        });

                    case 21:
                    case "end":
                        return _context3.stop();
                }
            }
        }, _callee3);
    }));
}

exports.encrypt = encrypt;

function decrypt(payload, key) {
    return tslib_1.__awaiter(this, void 0, void 0, /*#__PURE__*/ _regeneratorRuntime.mark(function _callee4() {
        var _key, verified, cipherText, iv, buffer, utf8, data;

        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) {
                switch (_context4.prev = _context4.next) {
                    case 0:
                        _key = encUtils.bufferToArray(utils_1.convertArrayBufferToBuffer(key));

                        if (_key) {
                            _context4.next = 3;
                            break;
                        }

                        throw new Error("Missing key: required for decryption");

                    case 3:
                        _context4.next = 5;
                        return verifyHmac(payload, _key);

                    case 5:
                        verified = _context4.sent;

                        if (verified) {
                            _context4.next = 8;
                            break;
                        }

                        return _context4.abrupt("return", null);

                    case 8:
                        cipherText = encUtils.hexToArray(payload.data);
                        iv = encUtils.hexToArray(payload.iv);
                        _context4.next = 12;
                        return isoCrypto.aesCbcDecrypt(iv, _key, cipherText);

                    case 12:
                        buffer = _context4.sent;
                        utf8 = encUtils.arrayToUtf8(buffer);
                        _context4.prev = 14;
                        data = JSON.parse(utf8);
                        _context4.next = 21;
                        break;

                    case 18:
                        _context4.prev = 18;
                        _context4.t0 = _context4["catch"](14);
                        return _context4.abrupt("return", null);

                    case 21:
                        return _context4.abrupt("return", data);

                    case 22:
                    case "end":
                        return _context4.stop();
                }
            }
        }, _callee4, null, [
            [14, 18]
        ]);
    }));
}

exports.decrypt = decrypt;