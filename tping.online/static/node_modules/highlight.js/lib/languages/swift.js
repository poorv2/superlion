var _toConsumableArray = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray");

function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {};
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true,
        didErr = false,
        err;
    return {
        s: function s() {
            it = o[Symbol.iterator]();
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally {
                if (didErr) throw err;
            }
        }
    };
}

function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
    }
    return arr2;
}

/**
 * @param {string} value
 * @returns {RegExp}
 * */

/**
 * @param {RegExp | string } re
 * @returns {string}
 */
function source(re) {
    if (!re) return null;
    if (typeof re === "string") return re;
    return re.source;
}
/**
 * @param {RegExp | string } re
 * @returns {string}
 */


function lookahead(re) {
    return concat('(?=', re, ')');
}
/**
 * @param {...(RegExp | string) } args
 * @returns {string}
 */


function concat() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
    }

    var joined = args.map(function(x) {
        return source(x);
    }).join("");
    return joined;
}
/**
 * Any of the passed expresssions may match
 *
 * Creates a huge this | this | that | that match
 * @param {(RegExp | string)[] } args
 * @returns {string}
 */


function either() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
    }

    var joined = '(' + args.map(function(x) {
        return source(x);
    }).join("|") + ")";
    return joined;
}

var keywordWrapper = function keywordWrapper(keyword) {
    return concat(/\b/, keyword, /\w$/.test(keyword) ? /\b/ : /\B/);
}; // Keywords that require a leading dot.


var dotKeywords = ['Protocol', // contextual
    'Type' // contextual
].map(keywordWrapper); // Keywords that may have a leading dot.

var optionalDotKeywords = ['init', 'self'].map(keywordWrapper); // should register as keyword, not type

var keywordTypes = ['Any', 'Self']; // Regular keywords and literals.

var keywords = [ // strings below will be fed into the regular `keywords` engine while regex
    // will result in additional modes being created to scan for those keywords to
    // avoid conflicts with other rules
    'associatedtype', 'async', 'await', /as\?/, // operator
    /as!/, // operator
    'as', // operator
    'break', 'case', 'catch', 'class', 'continue', 'convenience', // contextual
    'default', 'defer', 'deinit', 'didSet', // contextual
    'do', 'dynamic', // contextual
    'else', 'enum', 'extension', 'fallthrough', /fileprivate\(set\)/, 'fileprivate', 'final', // contextual
    'for', 'func', 'get', // contextual
    'guard', 'if', 'import', 'indirect', // contextual
    'infix', // contextual
    /init\?/, /init!/, 'inout', /internal\(set\)/, 'internal', 'in', 'is', // operator
    'lazy', // contextual
    'let', 'mutating', // contextual
    'nonmutating', // contextual
    /open\(set\)/, // contextual
    'open', // contextual
    'operator', 'optional', // contextual
    'override', // contextual
    'postfix', // contextual
    'precedencegroup', 'prefix', // contextual
    /private\(set\)/, 'private', 'protocol', /public\(set\)/, 'public', 'repeat', 'required', // contextual
    'rethrows', 'return', 'set', // contextual
    'some', // contextual
    'static', 'struct', 'subscript', 'super', 'switch', 'throws', 'throw', /try\?/, // operator
    /try!/, // operator
    'try', // operator
    'typealias', /unowned\(safe\)/, // contextual
    /unowned\(unsafe\)/, // contextual
    'unowned', // contextual
    'var', 'weak', // contextual
    'where', 'while', 'willSet' // contextual
]; // NOTE: Contextual keywords are reserved only in specific contexts.
// Ideally, these should be matched using modes to avoid false positives.
// Literals.

var literals = ['false', 'nil', 'true']; // Keywords used in precedence groups.

var precedencegroupKeywords = ['assignment', 'associativity', 'higherThan', 'left', 'lowerThan', 'none', 'right']; // Keywords that start with a number sign (#).
// #available is handled separately.

var numberSignKeywords = ['#colorLiteral', '#column', '#dsohandle', '#else', '#elseif', '#endif', '#error', '#file', '#fileID', '#fileLiteral', '#filePath', '#function', '#if', '#imageLiteral', '#keyPath', '#line', '#selector', '#sourceLocation', '#warn_unqualified_access', '#warning']; // Global functions in the Standard Library.

var builtIns = ['abs', 'all', 'any', 'assert', 'assertionFailure', 'debugPrint', 'dump', 'fatalError', 'getVaList', 'isKnownUniquelyReferenced', 'max', 'min', 'numericCast', 'pointwiseMax', 'pointwiseMin', 'precondition', 'preconditionFailure', 'print', 'readLine', 'repeatElement', 'sequence', 'stride', 'swap', 'swift_unboxFromSwiftValueWithType', 'transcode', 'type', 'unsafeBitCast', 'unsafeDowncast', 'withExtendedLifetime', 'withUnsafeMutablePointer', 'withUnsafePointer', 'withVaList', 'withoutActuallyEscaping', 'zip']; // Valid first characters for operators.

var operatorHead = either(/[/=\-+!*%<>&|^~?]/, /[\u00A1-\u00A7]/, /[\u00A9\u00AB]/, /[\u00AC\u00AE]/, /[\u00B0\u00B1]/, /[\u00B6\u00BB\u00BF\u00D7\u00F7]/, /[\u2016-\u2017]/, /[\u2020-\u2027]/, /[\u2030-\u203E]/, /[\u2041-\u2053]/, /[\u2055-\u205E]/, /[\u2190-\u23FF]/, /[\u2500-\u2775]/, /[\u2794-\u2BFF]/, /[\u2E00-\u2E7F]/, /[\u3001-\u3003]/, /[\u3008-\u3020]/, /[\u3030]/); // Valid characters for operators.

var operatorCharacter = either(operatorHead, /[\u0300-\u036F]/, /[\u1DC0-\u1DFF]/, /[\u20D0-\u20FF]/, /[\uFE00-\uFE0F]/, /[\uFE20-\uFE2F]/ // TODO: The following characters are also allowed, but the regex isn't supported yet.
    // /[\u{E0100}-\u{E01EF}]/u
); // Valid operator.

var operator = concat(operatorHead, operatorCharacter, '*'); // Valid first characters for identifiers.

var identifierHead = either(/[a-zA-Z_]/, /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/, /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/, /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/, /[\u1E00-\u1FFF]/, /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/, /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/, /[\u2C00-\u2DFF\u2E80-\u2FFF]/, /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/, /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/, /[\uFE47-\uFEFE\uFF00-\uFFFD]/ // Should be /[\uFE47-\uFFFD]/, but we have to exclude FEFF.
    // The following characters are also allowed, but the regexes aren't supported yet.
    // /[\u{10000}-\u{1FFFD}\u{20000-\u{2FFFD}\u{30000}-\u{3FFFD}\u{40000}-\u{4FFFD}]/u,
    // /[\u{50000}-\u{5FFFD}\u{60000-\u{6FFFD}\u{70000}-\u{7FFFD}\u{80000}-\u{8FFFD}]/u,
    // /[\u{90000}-\u{9FFFD}\u{A0000-\u{AFFFD}\u{B0000}-\u{BFFFD}\u{C0000}-\u{CFFFD}]/u,
    // /[\u{D0000}-\u{DFFFD}\u{E0000-\u{EFFFD}]/u
); // Valid characters for identifiers.

var identifierCharacter = either(identifierHead, /\d/, /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/); // Valid identifier.

var identifier = concat(identifierHead, identifierCharacter, '*'); // Valid type identifier.

var typeIdentifier = concat(/[A-Z]/, identifierCharacter, '*'); // Built-in attributes, which are highlighted as keywords.
// @available is handled separately.

var keywordAttributes = ['autoclosure', concat(/convention\(/, either('swift', 'block', 'c'), /\)/), 'discardableResult', 'dynamicCallable', 'dynamicMemberLookup', 'escaping', 'frozen', 'GKInspectable', 'IBAction', 'IBDesignable', 'IBInspectable', 'IBOutlet', 'IBSegueAction', 'inlinable', 'main', 'nonobjc', 'NSApplicationMain', 'NSCopying', 'NSManaged', concat(/objc\(/, identifier, /\)/), 'objc', 'objcMembers', 'propertyWrapper', 'requires_stored_property_inits', 'testable', 'UIApplicationMain', 'unknown', 'usableFromInline']; // Contextual keywords used in @available and #available.

var availabilityKeywords = ['iOS', 'iOSApplicationExtension', 'macOS', 'macOSApplicationExtension', 'macCatalyst', 'macCatalystApplicationExtension', 'watchOS', 'watchOSApplicationExtension', 'tvOS', 'tvOSApplicationExtension', 'swift'];
/*
Language: Swift
Description: Swift is a general-purpose programming language built using a modern approach to safety, performance, and software design patterns.
Author: Steven Van Impe <steven.vanimpe@icloud.com>
Contributors: Chris Eidhof <chris@eidhof.nl>, Nate Cook <natecook@gmail.com>, Alexander Lichter <manniL@gmx.net>, Richard Gibson <gibson042@github>
Website: https://swift.org
Category: common, system
*/

/** @type LanguageFn */

function swift(hljs) {
    var WHITESPACE = {
        match: /\s+/,
        relevance: 0
    }; // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID411

    var BLOCK_COMMENT = hljs.COMMENT('/\\*', '\\*/', {
        contains: ['self']
    });
    var COMMENTS = [hljs.C_LINE_COMMENT_MODE, BLOCK_COMMENT]; // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID413
    // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html

    var DOT_KEYWORD = {
        className: 'keyword',
        begin: concat(/\./, lookahead(either.apply(void 0, _toConsumableArray(dotKeywords).concat(_toConsumableArray(optionalDotKeywords))))),
        end: either.apply(void 0, _toConsumableArray(dotKeywords).concat(_toConsumableArray(optionalDotKeywords))),
        excludeBegin: true
    };
    var KEYWORD_GUARD = {
        // Consume .keyword to prevent highlighting properties and methods as keywords.
        match: concat(/\./, either.apply(void 0, keywords)),
        relevance: 0
    };
    var PLAIN_KEYWORDS = keywords.filter(function(kw) {
        return typeof kw === 'string';
    }).concat(["_|0"]); // seems common, so 0 relevance

    var REGEX_KEYWORDS = keywords.filter(function(kw) {
            return typeof kw !== 'string';
        }) // find regex
        .concat(keywordTypes).map(keywordWrapper);
    var KEYWORD = {
        variants: [{
            className: 'keyword',
            match: either.apply(void 0, _toConsumableArray(REGEX_KEYWORDS).concat(_toConsumableArray(optionalDotKeywords)))
        }]
    }; // find all the regular keywords

    var KEYWORDS = {
        $pattern: either(/\b\w+/, // regular keywords
            /#\w+/ // number keywords
        ),
        keyword: PLAIN_KEYWORDS.concat(numberSignKeywords),
        literal: literals
    };
    var KEYWORD_MODES = [DOT_KEYWORD, KEYWORD_GUARD, KEYWORD]; // https://github.com/apple/swift/tree/main/stdlib/public/core

    var BUILT_IN_GUARD = {
        // Consume .built_in to prevent highlighting properties and methods.
        match: concat(/\./, either.apply(void 0, builtIns)),
        relevance: 0
    };
    var BUILT_IN = {
        className: 'built_in',
        match: concat(/\b/, either.apply(void 0, builtIns), /(?=\()/)
    };
    var BUILT_INS = [BUILT_IN_GUARD, BUILT_IN]; // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID418

    var OPERATOR_GUARD = {
        // Prevent -> from being highlighting as an operator.
        match: /->/,
        relevance: 0
    };
    var OPERATOR = {
        className: 'operator',
        relevance: 0,
        variants: [{
            match: operator
        }, {
            // dot-operator: only operators that start with a dot are allowed to use dots as
            // characters (..., ...<, .*, etc). So there rule here is: a dot followed by one or more
            // characters that may also include dots.
            match: "\\.(\\.|".concat(operatorCharacter, ")+")
        }]
    };
    var OPERATORS = [OPERATOR_GUARD, OPERATOR]; // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#grammar_numeric-literal
    // TODO: Update for leading `-` after lookbehind is supported everywhere

    var decimalDigits = '([0-9]_*)+';
    var hexDigits = '([0-9a-fA-F]_*)+';
    var NUMBER = {
        className: 'number',
        relevance: 0,
        variants: [ // decimal floating-point-literal (subsumes decimal-literal)
            {
                match: "\\b(".concat(decimalDigits, ")(\\.(").concat(decimalDigits, "))?") + "([eE][+-]?(".concat(decimalDigits, "))?\\b")
            }, // hexadecimal floating-point-literal (subsumes hexadecimal-literal)
            {
                match: "\\b0x(".concat(hexDigits, ")(\\.(").concat(hexDigits, "))?") + "([pP][+-]?(".concat(decimalDigits, "))?\\b")
            }, // octal-literal
            {
                match: /\b0o([0-7]_*)+\b/
            }, // binary-literal
            {
                match: /\b0b([01]_*)+\b/
            }
        ]
    }; // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#grammar_string-literal

    var ESCAPED_CHARACTER = function ESCAPED_CHARACTER() {
        var rawDelimiter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        return {
            className: 'subst',
            variants: [{
                match: concat(/\\/, rawDelimiter, /[0\\tnr"']/)
            }, {
                match: concat(/\\/, rawDelimiter, /u\{[0-9a-fA-F]{1,8}\}/)
            }]
        };
    };

    var ESCAPED_NEWLINE = function ESCAPED_NEWLINE() {
        var rawDelimiter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        return {
            className: 'subst',
            match: concat(/\\/, rawDelimiter, /[\t ]*(?:[\r\n]|\r\n)/)
        };
    };

    var INTERPOLATION = function INTERPOLATION() {
        var rawDelimiter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        return {
            className: 'subst',
            label: "interpol",
            begin: concat(/\\/, rawDelimiter, /\(/),
            end: /\)/
        };
    };

    var MULTILINE_STRING = function MULTILINE_STRING() {
        var rawDelimiter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        return {
            begin: concat(rawDelimiter, /"""/),
            end: concat(/"""/, rawDelimiter),
            contains: [ESCAPED_CHARACTER(rawDelimiter), ESCAPED_NEWLINE(rawDelimiter), INTERPOLATION(rawDelimiter)]
        };
    };

    var SINGLE_LINE_STRING = function SINGLE_LINE_STRING() {
        var rawDelimiter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        return {
            begin: concat(rawDelimiter, /"/),
            end: concat(/"/, rawDelimiter),
            contains: [ESCAPED_CHARACTER(rawDelimiter), INTERPOLATION(rawDelimiter)]
        };
    };

    var STRING = {
        className: 'string',
        variants: [MULTILINE_STRING(), MULTILINE_STRING("#"), MULTILINE_STRING("##"), MULTILINE_STRING("###"), SINGLE_LINE_STRING(), SINGLE_LINE_STRING("#"), SINGLE_LINE_STRING("##"), SINGLE_LINE_STRING("###")]
    }; // https://docs.swift.org/swift-book/ReferenceManual/LexicalStructure.html#ID412

    var QUOTED_IDENTIFIER = {
        match: concat(/`/, identifier, /`/)
    };
    var IMPLICIT_PARAMETER = {
        className: 'variable',
        match: /\$\d+/
    };
    var PROPERTY_WRAPPER_PROJECTION = {
        className: 'variable',
        match: "\\$".concat(identifierCharacter, "+")
    };
    var IDENTIFIERS = [QUOTED_IDENTIFIER, IMPLICIT_PARAMETER, PROPERTY_WRAPPER_PROJECTION]; // https://docs.swift.org/swift-book/ReferenceManual/Attributes.html

    var AVAILABLE_ATTRIBUTE = {
        match: /(@|#)available/,
        className: "keyword",
        starts: {
            contains: [{
                begin: /\(/,
                end: /\)/,
                keywords: availabilityKeywords,
                contains: [].concat(OPERATORS, [NUMBER, STRING])
            }]
        }
    };
    var KEYWORD_ATTRIBUTE = {
        className: 'keyword',
        match: concat(/@/, either.apply(void 0, keywordAttributes))
    };
    var USER_DEFINED_ATTRIBUTE = {
        className: 'meta',
        match: concat(/@/, identifier)
    };
    var ATTRIBUTES = [AVAILABLE_ATTRIBUTE, KEYWORD_ATTRIBUTE, USER_DEFINED_ATTRIBUTE]; // https://docs.swift.org/swift-book/ReferenceManual/Types.html

    var TYPE = {
        match: lookahead(/\b[A-Z]/),
        relevance: 0,
        contains: [{
            // Common Apple frameworks, for relevance boost
            className: 'type',
            match: concat(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, identifierCharacter, '+')
        }, {
            // Type identifier
            className: 'type',
            match: typeIdentifier,
            relevance: 0
        }, {
            // Optional type
            match: /[?!]+/,
            relevance: 0
        }, {
            // Variadic parameter
            match: /\.\.\./,
            relevance: 0
        }, {
            // Protocol composition
            match: concat(/\s+&\s+/, lookahead(typeIdentifier)),
            relevance: 0
        }]
    };
    var GENERIC_ARGUMENTS = {
        begin: /</,
        end: />/,
        keywords: KEYWORDS,
        contains: [].concat(COMMENTS, KEYWORD_MODES, ATTRIBUTES, [OPERATOR_GUARD, TYPE])
    };
    TYPE.contains.push(GENERIC_ARGUMENTS); // https://docs.swift.org/swift-book/ReferenceManual/Expressions.html#ID552
    // Prevents element names from being highlighted as keywords.

    var TUPLE_ELEMENT_NAME = {
        match: concat(identifier, /\s*:/),
        keywords: "_|0",
        relevance: 0
    }; // Matches tuples as well as the parameter list of a function type.

    var TUPLE = {
        begin: /\(/,
        end: /\)/,
        relevance: 0,
        keywords: KEYWORDS,
        contains: ['self', TUPLE_ELEMENT_NAME].concat(COMMENTS, KEYWORD_MODES, BUILT_INS, OPERATORS, [NUMBER, STRING], IDENTIFIERS, ATTRIBUTES, [TYPE])
    }; // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID362
    // Matches both the keyword func and the function title.
    // Grouping these lets us differentiate between the operator function <
    // and the start of the generic parameter clause (also <).

    var FUNC_PLUS_TITLE = {
        beginKeywords: 'func',
        contains: [{
            className: 'title',
            match: either(QUOTED_IDENTIFIER.match, identifier, operator),
            // Required to make sure the opening < of the generic parameter clause
            // isn't parsed as a second title.
            endsParent: true,
            relevance: 0
        }, WHITESPACE]
    };
    var GENERIC_PARAMETERS = {
        begin: /</,
        end: />/,
        contains: [].concat(COMMENTS, [TYPE])
    };
    var FUNCTION_PARAMETER_NAME = {
        begin: either(lookahead(concat(identifier, /\s*:/)), lookahead(concat(identifier, /\s+/, identifier, /\s*:/))),
        end: /:/,
        relevance: 0,
        contains: [{
            className: 'keyword',
            match: /\b_\b/
        }, {
            className: 'params',
            match: identifier
        }]
    };
    var FUNCTION_PARAMETERS = {
        begin: /\(/,
        end: /\)/,
        keywords: KEYWORDS,
        contains: [FUNCTION_PARAMETER_NAME].concat(COMMENTS, KEYWORD_MODES, OPERATORS, [NUMBER, STRING], ATTRIBUTES, [TYPE, TUPLE]),
        endsParent: true,
        illegal: /["']/
    };
    var FUNCTION = {
        className: 'function',
        match: lookahead(/\bfunc\b/),
        contains: [FUNC_PLUS_TITLE, GENERIC_PARAMETERS, FUNCTION_PARAMETERS, WHITESPACE],
        illegal: [/\[/, /%/]
    }; // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID375
    // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID379

    var INIT_SUBSCRIPT = {
        className: 'function',
        match: /\b(subscript|init[?!]?)\s*(?=[<(])/,
        keywords: {
            keyword: "subscript init init? init!",
            $pattern: /\w+[?!]?/
        },
        contains: [GENERIC_PARAMETERS, FUNCTION_PARAMETERS, WHITESPACE],
        illegal: /\[|%/
    }; // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID380

    var OPERATOR_DECLARATION = {
        beginKeywords: 'operator',
        end: hljs.MATCH_NOTHING_RE,
        contains: [{
            className: 'title',
            match: operator,
            endsParent: true,
            relevance: 0
        }]
    }; // https://docs.swift.org/swift-book/ReferenceManual/Declarations.html#ID550

    var PRECEDENCEGROUP = {
        beginKeywords: 'precedencegroup',
        end: hljs.MATCH_NOTHING_RE,
        contains: [{
            className: 'title',
            match: typeIdentifier,
            relevance: 0
        }, {
            begin: /{/,
            end: /}/,
            relevance: 0,
            endsParent: true,
            keywords: [].concat(precedencegroupKeywords, literals),
            contains: [TYPE]
        }]
    }; // Add supported submodes to string interpolation.

    var _iterator = _createForOfIteratorHelper(STRING.variants),
        _step;

    try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var variant = _step.value;
            var interpolation = variant.contains.find(function(mode) {
                return mode.label === "interpol";
            }); // TODO: Interpolation can contain any expression, so there's room for improvement here.

            interpolation.keywords = KEYWORDS;
            var submodes = [].concat(KEYWORD_MODES, BUILT_INS, OPERATORS, [NUMBER, STRING], IDENTIFIERS);
            interpolation.contains = [].concat(_toConsumableArray(submodes), [{
                begin: /\(/,
                end: /\)/,
                contains: ['self'].concat(_toConsumableArray(submodes))
            }]);
        }
    } catch (err) {
        _iterator.e(err);
    } finally {
        _iterator.f();
    }

    return {
        name: 'Swift',
        keywords: KEYWORDS,
        contains: [].concat(COMMENTS, [FUNCTION, INIT_SUBSCRIPT, {
            className: 'class',
            beginKeywords: 'struct protocol class extension enum',
            end: '\\{',
            excludeEnd: true,
            keywords: KEYWORDS,
            contains: [hljs.inherit(hljs.TITLE_MODE, {
                begin: /[A-Za-z$_][\u00C0-\u02B80-9A-Za-z$_]*/
            })].concat(KEYWORD_MODES)
        }, OPERATOR_DECLARATION, PRECEDENCEGROUP, {
            beginKeywords: 'import',
            end: /$/,
            contains: [].concat(COMMENTS),
            relevance: 0
        }], KEYWORD_MODES, BUILT_INS, OPERATORS, [NUMBER, STRING], IDENTIFIERS, ATTRIBUTES, [TYPE, TUPLE])
    };
}

module.exports = swift;