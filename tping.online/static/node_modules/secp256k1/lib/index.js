function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {};
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true,
        didErr = false,
        err;
    return {
        s: function s() {
            it = o[Symbol.iterator]();
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally {
                if (didErr) throw err;
            }
        }
    };
}

function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
    }
    return arr2;
}

var errors = {
    IMPOSSIBLE_CASE: 'Impossible case. Please create issue.',
    TWEAK_ADD: 'The tweak was out of range or the resulted private key is invalid',
    TWEAK_MUL: 'The tweak was out of range or equal to zero',
    CONTEXT_RANDOMIZE_UNKNOW: 'Unknow error on context randomization',
    SECKEY_INVALID: 'Private Key is invalid',
    PUBKEY_PARSE: 'Public Key could not be parsed',
    PUBKEY_SERIALIZE: 'Public Key serialization error',
    PUBKEY_COMBINE: 'The sum of the public keys is not valid',
    SIG_PARSE: 'Signature could not be parsed',
    SIGN: 'The nonce generation function failed, or the private key was invalid',
    RECOVER: 'Public key could not be recover',
    ECDH: 'Scalar was invalid (zero or overflow)'
};

function assert(cond, msg) {
    if (!cond) throw new Error(msg);
}

function isUint8Array(name, value, length) {
    assert(value instanceof Uint8Array, "Expected ".concat(name, " to be an Uint8Array"));

    if (length !== undefined) {
        if (Array.isArray(length)) {
            var numbers = length.join(', ');
            var msg = "Expected ".concat(name, " to be an Uint8Array with length [").concat(numbers, "]");
            assert(length.includes(value.length), msg);
        } else {
            var _msg = "Expected ".concat(name, " to be an Uint8Array with length ").concat(length);

            assert(value.length === length, _msg);
        }
    }
}

function isCompressed(value) {
    assert(toTypeString(value) === 'Boolean', 'Expected compressed to be a Boolean');
}

function getAssertedOutput() {
    var output = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function(len) {
        return new Uint8Array(len);
    };
    var length = arguments.length > 1 ? arguments[1] : undefined;
    if (typeof output === 'function') output = output(length);
    isUint8Array('output', output, length);
    return output;
}

function toTypeString(value) {
    return Object.prototype.toString.call(value).slice(8, -1);
}

module.exports = function(secp256k1) {
    return {
        contextRandomize: function contextRandomize(seed) {
            assert(seed === null || seed instanceof Uint8Array, 'Expected seed to be an Uint8Array or null');
            if (seed !== null) isUint8Array('seed', seed, 32);

            switch (secp256k1.contextRandomize(seed)) {
                case 1:
                    throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW);
            }
        },
        privateKeyVerify: function privateKeyVerify(seckey) {
            isUint8Array('private key', seckey, 32);
            return secp256k1.privateKeyVerify(seckey) === 0;
        },
        privateKeyNegate: function privateKeyNegate(seckey) {
            isUint8Array('private key', seckey, 32);

            switch (secp256k1.privateKeyNegate(seckey)) {
                case 0:
                    return seckey;

                case 1:
                    throw new Error(errors.IMPOSSIBLE_CASE);
            }
        },
        privateKeyTweakAdd: function privateKeyTweakAdd(seckey, tweak) {
            isUint8Array('private key', seckey, 32);
            isUint8Array('tweak', tweak, 32);

            switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {
                case 0:
                    return seckey;

                case 1:
                    throw new Error(errors.TWEAK_ADD);
            }
        },
        privateKeyTweakMul: function privateKeyTweakMul(seckey, tweak) {
            isUint8Array('private key', seckey, 32);
            isUint8Array('tweak', tweak, 32);

            switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {
                case 0:
                    return seckey;

                case 1:
                    throw new Error(errors.TWEAK_MUL);
            }
        },
        publicKeyVerify: function publicKeyVerify(pubkey) {
            isUint8Array('public key', pubkey, [33, 65]);
            return secp256k1.publicKeyVerify(pubkey) === 0;
        },
        publicKeyCreate: function publicKeyCreate(seckey) {
            var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            var output = arguments.length > 2 ? arguments[2] : undefined;
            isUint8Array('private key', seckey, 32);
            isCompressed(compressed);
            output = getAssertedOutput(output, compressed ? 33 : 65);

            switch (secp256k1.publicKeyCreate(output, seckey)) {
                case 0:
                    return output;

                case 1:
                    throw new Error(errors.SECKEY_INVALID);

                case 2:
                    throw new Error(errors.PUBKEY_SERIALIZE);
            }
        },
        publicKeyConvert: function publicKeyConvert(pubkey) {
            var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            var output = arguments.length > 2 ? arguments[2] : undefined;
            isUint8Array('public key', pubkey, [33, 65]);
            isCompressed(compressed);
            output = getAssertedOutput(output, compressed ? 33 : 65);

            switch (secp256k1.publicKeyConvert(output, pubkey)) {
                case 0:
                    return output;

                case 1:
                    throw new Error(errors.PUBKEY_PARSE);

                case 2:
                    throw new Error(errors.PUBKEY_SERIALIZE);
            }
        },
        publicKeyNegate: function publicKeyNegate(pubkey) {
            var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            var output = arguments.length > 2 ? arguments[2] : undefined;
            isUint8Array('public key', pubkey, [33, 65]);
            isCompressed(compressed);
            output = getAssertedOutput(output, compressed ? 33 : 65);

            switch (secp256k1.publicKeyNegate(output, pubkey)) {
                case 0:
                    return output;

                case 1:
                    throw new Error(errors.PUBKEY_PARSE);

                case 2:
                    throw new Error(errors.IMPOSSIBLE_CASE);

                case 3:
                    throw new Error(errors.PUBKEY_SERIALIZE);
            }
        },
        publicKeyCombine: function publicKeyCombine(pubkeys) {
            var compressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            var output = arguments.length > 2 ? arguments[2] : undefined;
            assert(Array.isArray(pubkeys), 'Expected public keys to be an Array');
            assert(pubkeys.length > 0, 'Expected public keys array will have more than zero items');

            var _iterator = _createForOfIteratorHelper(pubkeys),
                _step;

            try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    var pubkey = _step.value;
                    isUint8Array('public key', pubkey, [33, 65]);
                }
            } catch (err) {
                _iterator.e(err);
            } finally {
                _iterator.f();
            }

            isCompressed(compressed);
            output = getAssertedOutput(output, compressed ? 33 : 65);

            switch (secp256k1.publicKeyCombine(output, pubkeys)) {
                case 0:
                    return output;

                case 1:
                    throw new Error(errors.PUBKEY_PARSE);

                case 2:
                    throw new Error(errors.PUBKEY_COMBINE);

                case 3:
                    throw new Error(errors.PUBKEY_SERIALIZE);
            }
        },
        publicKeyTweakAdd: function publicKeyTweakAdd(pubkey, tweak) {
            var compressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
            var output = arguments.length > 3 ? arguments[3] : undefined;
            isUint8Array('public key', pubkey, [33, 65]);
            isUint8Array('tweak', tweak, 32);
            isCompressed(compressed);
            output = getAssertedOutput(output, compressed ? 33 : 65);

            switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {
                case 0:
                    return output;

                case 1:
                    throw new Error(errors.PUBKEY_PARSE);

                case 2:
                    throw new Error(errors.TWEAK_ADD);
            }
        },
        publicKeyTweakMul: function publicKeyTweakMul(pubkey, tweak) {
            var compressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
            var output = arguments.length > 3 ? arguments[3] : undefined;
            isUint8Array('public key', pubkey, [33, 65]);
            isUint8Array('tweak', tweak, 32);
            isCompressed(compressed);
            output = getAssertedOutput(output, compressed ? 33 : 65);

            switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {
                case 0:
                    return output;

                case 1:
                    throw new Error(errors.PUBKEY_PARSE);

                case 2:
                    throw new Error(errors.TWEAK_MUL);
            }
        },
        signatureNormalize: function signatureNormalize(sig) {
            isUint8Array('signature', sig, 64);

            switch (secp256k1.signatureNormalize(sig)) {
                case 0:
                    return sig;

                case 1:
                    throw new Error(errors.SIG_PARSE);
            }
        },
        signatureExport: function signatureExport(sig, output) {
            isUint8Array('signature', sig, 64);
            output = getAssertedOutput(output, 72);
            var obj = {
                output: output,
                outputlen: 72
            };

            switch (secp256k1.signatureExport(obj, sig)) {
                case 0:
                    return output.slice(0, obj.outputlen);

                case 1:
                    throw new Error(errors.SIG_PARSE);

                case 2:
                    throw new Error(errors.IMPOSSIBLE_CASE);
            }
        },
        signatureImport: function signatureImport(sig, output) {
            isUint8Array('signature', sig);
            output = getAssertedOutput(output, 64);

            switch (secp256k1.signatureImport(output, sig)) {
                case 0:
                    return output;

                case 1:
                    throw new Error(errors.SIG_PARSE);

                case 2:
                    throw new Error(errors.IMPOSSIBLE_CASE);
            }
        },
        ecdsaSign: function ecdsaSign(msg32, seckey) {
            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            var output = arguments.length > 3 ? arguments[3] : undefined;
            isUint8Array('message', msg32, 32);
            isUint8Array('private key', seckey, 32);
            assert(toTypeString(options) === 'Object', 'Expected options to be an Object');
            if (options.data !== undefined) isUint8Array('options.data', options.data);
            if (options.noncefn !== undefined) assert(toTypeString(options.noncefn) === 'Function', 'Expected options.noncefn to be a Function');
            output = getAssertedOutput(output, 64);
            var obj = {
                signature: output,
                recid: null
            };

            switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {
                case 0:
                    return obj;

                case 1:
                    throw new Error(errors.SIGN);

                case 2:
                    throw new Error(errors.IMPOSSIBLE_CASE);
            }
        },
        ecdsaVerify: function ecdsaVerify(sig, msg32, pubkey) {
            isUint8Array('signature', sig, 64);
            isUint8Array('message', msg32, 32);
            isUint8Array('public key', pubkey, [33, 65]);

            switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {
                case 0:
                    return true;

                case 3:
                    return false;

                case 1:
                    throw new Error(errors.SIG_PARSE);

                case 2:
                    throw new Error(errors.PUBKEY_PARSE);
            }
        },
        ecdsaRecover: function ecdsaRecover(sig, recid, msg32) {
            var compressed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
            var output = arguments.length > 4 ? arguments[4] : undefined;
            isUint8Array('signature', sig, 64);
            assert(toTypeString(recid) === 'Number' && recid >= 0 && recid <= 3, 'Expected recovery id to be a Number within interval [0, 3]');
            isUint8Array('message', msg32, 32);
            isCompressed(compressed);
            output = getAssertedOutput(output, compressed ? 33 : 65);

            switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {
                case 0:
                    return output;

                case 1:
                    throw new Error(errors.SIG_PARSE);

                case 2:
                    throw new Error(errors.RECOVER);

                case 3:
                    throw new Error(errors.IMPOSSIBLE_CASE);
            }
        },
        ecdh: function ecdh(pubkey, seckey) {
            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            var output = arguments.length > 3 ? arguments[3] : undefined;
            isUint8Array('public key', pubkey, [33, 65]);
            isUint8Array('private key', seckey, 32);
            assert(toTypeString(options) === 'Object', 'Expected options to be an Object');
            if (options.data !== undefined) isUint8Array('options.data', options.data);

            if (options.hashfn !== undefined) {
                assert(toTypeString(options.hashfn) === 'Function', 'Expected options.hashfn to be a Function');
                if (options.xbuf !== undefined) isUint8Array('options.xbuf', options.xbuf, 32);
                if (options.ybuf !== undefined) isUint8Array('options.ybuf', options.ybuf, 32);
                isUint8Array('output', output);
            } else {
                output = getAssertedOutput(output, 32);
            }

            switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {
                case 0:
                    return output;

                case 1:
                    throw new Error(errors.PUBKEY_PARSE);

                case 2:
                    throw new Error(errors.ECDH);
            }
        }
    };
};