var _regeneratorRuntime = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator");

var _asyncToGenerator = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator");

var _require = require('./setup'),
    web3 = _require.web3;

var _require2 = require('chai'),
    expect = _require2.expect;

var colors = require('ansi-colors');

var semver = require('semver');

var checkedProviders = new WeakSet();

function expectException(_x, _x2) {
    return _expectException.apply(this, arguments);
}

function _expectException() {
    _expectException = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee2(promise, expectedError) {
        var actualError;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
                switch (_context2.prev = _context2.next) {
                    case 0:
                        _context2.prev = 0;
                        _context2.next = 3;
                        return promise;

                    case 3:
                        _context2.next = 9;
                        break;

                    case 5:
                        _context2.prev = 5;
                        _context2.t0 = _context2["catch"](0);

                        if (_context2.t0.message.indexOf(expectedError) === -1) {
                            // When the exception was a revert, the resulting string will include only
                            // the revert reason, otherwise it will be the type of exception (e.g. 'invalid opcode')
                            actualError = _context2.t0.message.replace(/Returned error: VM Exception while processing transaction: (revert )?/, '');
                            expect(actualError).to.equal(expectedError, 'Wrong kind of exception received');
                        }

                        return _context2.abrupt("return");

                    case 9:
                        expect.fail('Expected an exception but none was received');

                    case 10:
                    case "end":
                        return _context2.stop();
                }
            }
        }, _callee2, null, [
            [0, 5]
        ]);
    }));
    return _expectException.apply(this, arguments);
}

function checkRevertReasonSupport(_x3) {
    return _checkRevertReasonSupport.apply(this, arguments);
}

function _checkRevertReasonSupport() {
    _checkRevertReasonSupport = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee3(provider) {
        var nodeInfo, ganacheVersion, hardhatVersion, warn;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
                switch (_context3.prev = _context3.next) {
                    case 0:
                        if (checkedProviders.has(provider)) {
                            _context3.next = 14;
                            break;
                        }

                        _context3.next = 3;
                        return web3.eth.getNodeInfo();

                    case 3:
                        nodeInfo = _context3.sent;
                        ganacheVersion = /TestRPC\/v([\w.-]+)\/ethereum-js/.exec(nodeInfo);
                        hardhatVersion = /HardhatNetwork\/([\w.-]+)\/ethereumjs-vm/.exec(nodeInfo);

                        warn = function warn(msg) {
                            console.log("".concat(colors.white.bgBlack('@openzeppelin/test-helpers'), " ").concat(colors.black.bgYellow('WARN'), " expectRevert: ").concat(msg));
                        };

                        if (!(ganacheVersion === null && hardhatVersion === null)) {
                            _context3.next = 11;
                            break;
                        }

                        warn("Assertions may yield false negatives!\n\nRevert reason checks are only known to work on Ganache >=2.2.0 and Hardhat, and the current node is ".concat(nodeInfo, ".\n\nIf your node does support revert reasons, please let us know: https://github.com/OpenZeppelin/openzeppelin-test-helpers/issues/new"));
                        _context3.next = 13;
                        break;

                    case 11:
                        if (!(ganacheVersion !== null && !semver.gte(ganacheVersion[1], '2.2.0'))) {
                            _context3.next = 13;
                            break;
                        }

                        throw new Error("The current version of Ganache (v".concat(ganacheVersion[1], ") doesn't return revert reasons.\n\nUpgrade to v2.2.0 or newer, or use expectRevert.unspecified to skip the revert reason check."));

                    case 13:
                        checkedProviders.add(provider);

                    case 14:
                    case "end":
                        return _context3.stop();
                }
            }
        }, _callee3);
    }));
    return _checkRevertReasonSupport.apply(this, arguments);
}

var expectRevert = /*#__PURE__*/ function() {
    var _ref = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee(promise, expectedError) {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        promise.catch(function() {}); // Avoids uncaught promise rejections in case an input validation causes us to return early

                        if (expectedError) {
                            _context.next = 3;
                            break;
                        }

                        throw Error('No revert reason specified: call expectRevert with the reason string, or use expectRevert.unspecified \
if your \'require\' statement doesn\'t have one.');

                    case 3:
                        _context.next = 5;
                        return checkRevertReasonSupport(web3.currentProvider);

                    case 5:
                        _context.next = 7;
                        return expectException(promise, expectedError);

                    case 7:
                    case "end":
                        return _context.stop();
                }
            }
        }, _callee);
    }));

    return function expectRevert(_x4, _x5) {
        return _ref.apply(this, arguments);
    };
}();

expectRevert.assertion = function(promise) {
    return expectException(promise, 'invalid opcode');
};

expectRevert.outOfGas = function(promise) {
    return expectException(promise, 'out of gas');
};

expectRevert.unspecified = function(promise) {
    return expectException(promise, 'revert');
};

module.exports = expectRevert;