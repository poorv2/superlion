var _regeneratorRuntime = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator");

var _asyncToGenerator = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator");

var _slicedToArray = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray");

var _require = require('./setup'),
    web3 = _require.web3,
    BN = _require.BN;

var _require2 = require('chai'),
    expect = _require2.expect;

var flatten = require('lodash.flatten');

var _require3 = require('util'),
    deprecate = _require3.deprecate;

function expectEvent(receipt, eventName) {
    var eventArgs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    // truffle contract receipts have a 'logs' object, with an array of objects
    // with 'event' and 'args' properties, containing the event name and actual
    // values.
    // web3 contract receipts instead have an 'events' object, with properties
    // named after emitted events, each containing an object with 'returnValues'
    // holding the event data, or an array of these if multiple were emitted.
    // The simplest way to handle both of these receipts is to convert the web3
    // event format into the truffle one.
    if (isWeb3Receipt(receipt)) {
        var logs = flatten(Object.keys(receipt.events).map(function(name) {
            if (Array.isArray(receipt.events[name])) {
                return receipt.events[name].map(function(event) {
                    return {
                        event: name,
                        args: event.returnValues
                    };
                });
            } else {
                return {
                    event: name,
                    args: receipt.events[name].returnValues
                };
            }
        }));
        return inLogs(logs, eventName, eventArgs);
    } else if (isTruffleReceipt(receipt)) {
        return inLogs(receipt.logs, eventName, eventArgs);
    } else {
        throw new Error('Unknown transaction receipt object');
    }
}

function notExpectEvent(receipt, eventName) {
    if (isWeb3Receipt(receipt)) {
        // We don't need arguments for the assertion, so let's just map it to the expected format.
        var logsWithoutArgs = Object.keys(receipt.events).map(function(name) {
            return {
                event: name
            };
        });
        notInLogs(logsWithoutArgs, eventName);
    } else if (isTruffleReceipt(receipt)) {
        notInLogs(receipt.logs, eventName);
    } else {
        throw new Error('Unknown transaction receipt object');
    }
}

function inLogs(logs, eventName) {
    var eventArgs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var events = logs.filter(function(e) {
        return e.event === eventName;
    });
    expect(events.length > 0).to.equal(true, "No '".concat(eventName, "' events found"));
    var exception = [];
    var event = events.find(function(e) {
        for (var _i = 0, _Object$entries = Object.entries(eventArgs); _i < _Object$entries.length; _i++) {
            var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
                k = _Object$entries$_i[0],
                v = _Object$entries$_i[1];

            try {
                contains(e.args, k, v);
            } catch (error) {
                exception.push(error);
                return false;
            }
        }

        return true;
    });

    if (event === undefined) {
        throw exception[0];
    }

    return event;
}

function notInLogs(logs, eventName) {
    // eslint-disable-next-line no-unused-expressions
    expect(logs.find(function(e) {
        return e.event === eventName;
    }), "Event ".concat(eventName, " was found")).to.be.undefined;
}

function inConstruction(_x, _x2) {
    return _inConstruction.apply(this, arguments);
}

function _inConstruction() {
    _inConstruction = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee(contract, eventName) {
        var eventArgs,
            _args = arguments;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        eventArgs = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};

                        if (isTruffleContract(contract)) {
                            _context.next = 3;
                            break;
                        }

                        throw new Error('expectEvent.inConstruction is only supported for truffle-contract objects');

                    case 3:
                        return _context.abrupt("return", inTransaction(contract.transactionHash, contract.constructor, eventName, eventArgs));

                    case 4:
                    case "end":
                        return _context.stop();
                }
            }
        }, _callee);
    }));
    return _inConstruction.apply(this, arguments);
}

function notInConstruction(_x3, _x4) {
    return _notInConstruction.apply(this, arguments);
}

function _notInConstruction() {
    _notInConstruction = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee2(contract, eventName) {
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
                switch (_context2.prev = _context2.next) {
                    case 0:
                        if (isTruffleContract(contract)) {
                            _context2.next = 2;
                            break;
                        }

                        throw new Error('expectEvent.inConstruction is only supported for truffle-contract objects');

                    case 2:
                        return _context2.abrupt("return", notInTransaction(contract.transactionHash, contract.constructor, eventName));

                    case 3:
                    case "end":
                        return _context2.stop();
                }
            }
        }, _callee2);
    }));
    return _notInConstruction.apply(this, arguments);
}

function inTransaction(_x5, _x6, _x7) {
    return _inTransaction.apply(this, arguments);
}

function _inTransaction() {
    _inTransaction = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee3(txHash, emitter, eventName) {
        var eventArgs,
            receipt,
            logs,
            _args3 = arguments;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
                switch (_context3.prev = _context3.next) {
                    case 0:
                        eventArgs = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : {};
                        _context3.next = 3;
                        return web3.eth.getTransactionReceipt(txHash);

                    case 3:
                        receipt = _context3.sent;
                        logs = decodeLogs(receipt.logs, emitter, eventName);
                        return _context3.abrupt("return", inLogs(logs, eventName, eventArgs));

                    case 6:
                    case "end":
                        return _context3.stop();
                }
            }
        }, _callee3);
    }));
    return _inTransaction.apply(this, arguments);
}

function notInTransaction(_x8, _x9, _x10) {
    return _notInTransaction.apply(this, arguments);
} // This decodes longs for a single event type, and returns a decoded object in
// the same form truffle-contract uses on its receipts


function _notInTransaction() {
    _notInTransaction = _asyncToGenerator( /*#__PURE__*/ _regeneratorRuntime.mark(function _callee4(txHash, emitter, eventName) {
        var receipt, logs;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
            while (1) {
                switch (_context4.prev = _context4.next) {
                    case 0:
                        _context4.next = 2;
                        return web3.eth.getTransactionReceipt(txHash);

                    case 2:
                        receipt = _context4.sent;
                        logs = decodeLogs(receipt.logs, emitter, eventName);
                        notInLogs(logs, eventName);

                    case 5:
                    case "end":
                        return _context4.stop();
                }
            }
        }, _callee4);
    }));
    return _notInTransaction.apply(this, arguments);
}

function decodeLogs(logs, emitter, eventName) {
    var abi;
    var address;

    if (isWeb3Contract(emitter)) {
        abi = emitter.options.jsonInterface;
        address = emitter.options.address;
    } else if (isTruffleContract(emitter)) {
        abi = emitter.abi;

        try {
            address = emitter.address;
        } catch (e) {
            address = null;
        }
    } else {
        throw new Error('Unknown contract object');
    }

    var eventABI = abi.filter(function(x) {
        return x.type === 'event' && x.name === eventName;
    });

    if (eventABI.length === 0) {
        throw new Error("No ABI entry for event '".concat(eventName, "'"));
    } else if (eventABI.length > 1) {
        throw new Error("Multiple ABI entries for event '".concat(eventName, "', only uniquely named events are supported"));
    }

    eventABI = eventABI[0]; // The first topic will equal the hash of the event signature

    var eventSignature = "".concat(eventName, "(").concat(eventABI.inputs.map(function(input) {
        return input.type;
    }).join(','), ")");
    var eventTopic = web3.utils.sha3(eventSignature); // Only decode events of type 'EventName'

    return logs.filter(function(log) {
        return log.topics.length > 0 && log.topics[0] === eventTopic && (!address || log.address === address);
    }).map(function(log) {
        return web3.eth.abi.decodeLog(eventABI.inputs, log.data, log.topics.slice(1));
    }).map(function(decoded) {
        return {
            event: eventName,
            args: decoded
        };
    });
}

function contains(args, key, value) {
    expect(key in args).to.equal(true, "Event argument '".concat(key, "' not found"));

    if (value === null) {
        expect(args[key]).to.equal(null, "expected event argument '".concat(key, "' to be null but got ").concat(args[key]));
    } else if (isBN(args[key]) || isBN(value)) {
        var actual = isBN(args[key]) ? args[key].toString() : args[key];
        var expected = isBN(value) ? value.toString() : value;
        expect(args[key]).to.be.bignumber.equal(value, "expected event argument '".concat(key, "' to have value ").concat(expected, " but got ").concat(actual));
    } else {
        expect(args[key]).to.be.deep.equal(value, "expected event argument '".concat(key, "' to have value ").concat(value, " but got ").concat(args[key]));
    }
}

function isBN(object) {
    return BN.isBN(object) || object instanceof BN;
}

function isWeb3Receipt(receipt) {
    return 'events' in receipt && typeof receipt.events === 'object';
}

function isTruffleReceipt(receipt) {
    return 'logs' in receipt && typeof receipt.logs === 'object';
}

function isWeb3Contract(contract) {
    return 'options' in contract && typeof contract.options === 'object';
}

function isTruffleContract(contract) {
    return 'abi' in contract && typeof contract.abi === 'object';
}

expectEvent.inLogs = deprecate(inLogs, 'expectEvent.inLogs() is deprecated. Use expectEvent() instead.');
expectEvent.inConstruction = inConstruction;
expectEvent.inTransaction = inTransaction;
expectEvent.notEmitted = notExpectEvent;
expectEvent.notEmitted.inConstruction = notInConstruction;
expectEvent.notEmitted.inTransaction = notInTransaction;
expectEvent.not = {};
expectEvent.not.inConstruction = deprecate(notInConstruction, 'expectEvent.not is deprecated. Use expectEvent.notEmitted instead.');
expectEvent.not.inTransaction = deprecate(notInTransaction, 'expectEvent.not is deprecated. Use expectEvent.notEmitted instead.');
module.exports = expectEvent;