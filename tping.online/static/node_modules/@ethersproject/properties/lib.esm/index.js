"use strict";

import _classCallCheck from "/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck";
import _regeneratorRuntime from "/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator";

var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }

    return new(P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }

        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }

        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }

        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

import {
    Logger
} from "@ethersproject/logger";
import {
    version
} from "./_version";
var logger = new Logger(version);
export function defineReadOnly(object, name, value) {
    Object.defineProperty(object, name, {
        enumerable: true,
        value: value,
        writable: false
    });
} // Crawl up the constructor chain to find a static method

export function getStatic(ctor, key) {
    for (var i = 0; i < 32; i++) {
        if (ctor[key]) {
            return ctor[key];
        }

        if (!ctor.prototype || typeof ctor.prototype !== "object") {
            break;
        }

        ctor = Object.getPrototypeOf(ctor.prototype).constructor;
    }

    return null;
}
export function resolveProperties(object) {
    return __awaiter(this, void 0, void 0, /*#__PURE__*/ _regeneratorRuntime.mark(function _callee() {
        var promises, results;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        promises = Object.keys(object).map(function(key) {
                            var value = object[key];
                            return Promise.resolve(value).then(function(v) {
                                return {
                                    key: key,
                                    value: v
                                };
                            });
                        });
                        _context.next = 3;
                        return Promise.all(promises);

                    case 3:
                        results = _context.sent;
                        return _context.abrupt("return", results.reduce(function(accum, result) {
                            accum[result.key] = result.value;
                            return accum;
                        }, {}));

                    case 5:
                    case "end":
                        return _context.stop();
                }
            }
        }, _callee);
    }));
}
export function checkProperties(object, properties) {
    if (!object || typeof object !== "object") {
        logger.throwArgumentError("invalid object", "object", object);
    }

    Object.keys(object).forEach(function(key) {
        if (!properties[key]) {
            logger.throwArgumentError("invalid object key - " + key, "transaction:" + key, object);
        }
    });
}
export function shallowCopy(object) {
    var result = {};

    for (var key in object) {
        result[key] = object[key];
    }

    return result;
}
var opaque = {
    bigint: true,
    boolean: true,
    "function": true,
    number: true,
    string: true
};

function _isFrozen(object) {
    // Opaque objects are not mutable, so safe to copy by assignment
    if (object === undefined || object === null || opaque[typeof object]) {
        return true;
    }

    if (Array.isArray(object) || typeof object === "object") {
        if (!Object.isFrozen(object)) {
            return false;
        }

        var keys = Object.keys(object);

        for (var i = 0; i < keys.length; i++) {
            if (!_isFrozen(object[keys[i]])) {
                return false;
            }
        }

        return true;
    }

    return logger.throwArgumentError("Cannot deepCopy ".concat(typeof object), "object", object);
} // Returns a new copy of object, such that no properties may be replaced.
// New properties may be added only to objects.


function _deepCopy(object) {
    if (_isFrozen(object)) {
        return object;
    } // Arrays are mutable, so we need to create a copy


    if (Array.isArray(object)) {
        return Object.freeze(object.map(function(item) {
            return deepCopy(item);
        }));
    }

    if (typeof object === "object") {
        var result = {};

        for (var key in object) {
            var value = object[key];

            if (value === undefined) {
                continue;
            }

            defineReadOnly(result, key, deepCopy(value));
        }

        return result;
    }

    return logger.throwArgumentError("Cannot deepCopy ".concat(typeof object), "object", object);
}

export function deepCopy(object) {
    return _deepCopy(object);
}
export var Description = function Description(info) {
    _classCallCheck(this, Description);

    for (var key in info) {
        this[key] = deepCopy(info[key]);
    }
};