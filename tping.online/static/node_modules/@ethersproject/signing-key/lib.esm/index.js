"use strict";

import _classCallCheck from "/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass";
import {
    EC
} from "./elliptic";
import {
    arrayify,
    hexlify,
    hexZeroPad,
    splitSignature
} from "@ethersproject/bytes";
import {
    defineReadOnly
} from "@ethersproject/properties";
import {
    Logger
} from "@ethersproject/logger";
import {
    version
} from "./_version";
var logger = new Logger(version);
var _curve = null;

function getCurve() {
    if (!_curve) {
        _curve = new EC("secp256k1");
    }

    return _curve;
}

export var SigningKey = /*#__PURE__*/ function() {
    function SigningKey(privateKey) {
        _classCallCheck(this, SigningKey);

        defineReadOnly(this, "curve", "secp256k1");
        defineReadOnly(this, "privateKey", hexlify(privateKey));
        var keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));
        defineReadOnly(this, "publicKey", "0x" + keyPair.getPublic(false, "hex"));
        defineReadOnly(this, "compressedPublicKey", "0x" + keyPair.getPublic(true, "hex"));
        defineReadOnly(this, "_isSigningKey", true);
    }

    _createClass(SigningKey, [{
        key: "_addPoint",
        value: function _addPoint(other) {
            var p0 = getCurve().keyFromPublic(arrayify(this.publicKey));
            var p1 = getCurve().keyFromPublic(arrayify(other));
            return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
        }
    }, {
        key: "signDigest",
        value: function signDigest(digest) {
            var keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));
            var digestBytes = arrayify(digest);

            if (digestBytes.length !== 32) {
                logger.throwArgumentError("bad digest length", "digest", digest);
            }

            var signature = keyPair.sign(digestBytes, {
                canonical: true
            });
            return splitSignature({
                recoveryParam: signature.recoveryParam,
                r: hexZeroPad("0x" + signature.r.toString(16), 32),
                s: hexZeroPad("0x" + signature.s.toString(16), 32)
            });
        }
    }, {
        key: "computeSharedSecret",
        value: function computeSharedSecret(otherKey) {
            var keyPair = getCurve().keyFromPrivate(arrayify(this.privateKey));
            var otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));
            return hexZeroPad("0x" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);
        }
    }], [{
        key: "isSigningKey",
        value: function isSigningKey(value) {
            return !!(value && value._isSigningKey);
        }
    }]);

    return SigningKey;
}();
export function recoverPublicKey(digest, signature) {
    var sig = splitSignature(signature);
    var rs = {
        r: arrayify(sig.r),
        s: arrayify(sig.s)
    };
    return "0x" + getCurve().recoverPubKey(arrayify(digest), rs, sig.recoveryParam).encode("hex", false);
}
export function computePublicKey(key, compressed) {
    var bytes = arrayify(key);

    if (bytes.length === 32) {
        var signingKey = new SigningKey(bytes);

        if (compressed) {
            return "0x" + getCurve().keyFromPrivate(bytes).getPublic(true, "hex");
        }

        return signingKey.publicKey;
    } else if (bytes.length === 33) {
        if (compressed) {
            return hexlify(bytes);
        }

        return "0x" + getCurve().keyFromPublic(bytes).getPublic(false, "hex");
    } else if (bytes.length === 65) {
        if (!compressed) {
            return hexlify(bytes);
        }

        return "0x" + getCurve().keyFromPublic(bytes).getPublic(true, "hex");
    }

    return logger.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}