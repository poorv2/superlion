"use strict";

import _possibleConstructorReturn from "/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf";
import _inherits from "/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits";
import _classCallCheck from "/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass";
import {
    BigNumber
} from "@ethersproject/bignumber";
import {
    defineReadOnly
} from "@ethersproject/properties";
import {
    Logger
} from "@ethersproject/logger";
import {
    version
} from "./_version";
var logger = new Logger(version);;
var _constructorGuard = {};
var ModifiersBytes = {
    calldata: true,
    memory: true,
    storage: true
};
var ModifiersNest = {
    calldata: true,
    memory: true
};

function checkModifier(type, name) {
    if (type === "bytes" || type === "string") {
        if (ModifiersBytes[name]) {
            return true;
        }
    } else if (type === "address") {
        if (name === "payable") {
            return true;
        }
    } else if (type.indexOf("[") >= 0 || type === "tuple") {
        if (ModifiersNest[name]) {
            return true;
        }
    }

    if (ModifiersBytes[name] || name === "payable") {
        logger.throwArgumentError("invalid modifier", "name", name);
    }

    return false;
} // @TODO: Make sure that children of an indexed tuple are marked with a null indexed


function parseParamType(param, allowIndexed) {
    var originalParam = param;

    function throwError(i) {
        logger.throwArgumentError("unexpected character at position ".concat(i), "param", param);
    }

    param = param.replace(/\s/g, " ");

    function newNode(parent) {
        var node = {
            type: "",
            name: "",
            parent: parent,
            state: {
                allowType: true
            }
        };

        if (allowIndexed) {
            node.indexed = false;
        }

        return node;
    }

    var parent = {
        type: "",
        name: "",
        state: {
            allowType: true
        }
    };
    var node = parent;

    for (var i = 0; i < param.length; i++) {
        var c = param[i];

        switch (c) {
            case "(":
                if (node.state.allowType && node.type === "") {
                    node.type = "tuple";
                } else if (!node.state.allowParams) {
                    throwError(i);
                }

                node.state.allowType = false;
                node.type = verifyType(node.type);
                node.components = [newNode(node)];
                node = node.components[0];
                break;

            case ")":
                delete node.state;

                if (node.name === "indexed") {
                    if (!allowIndexed) {
                        throwError(i);
                    }

                    node.indexed = true;
                    node.name = "";
                }

                if (checkModifier(node.type, node.name)) {
                    node.name = "";
                }

                node.type = verifyType(node.type);
                var child = node;
                node = node.parent;

                if (!node) {
                    throwError(i);
                }

                delete child.parent;
                node.state.allowParams = false;
                node.state.allowName = true;
                node.state.allowArray = true;
                break;

            case ",":
                delete node.state;

                if (node.name === "indexed") {
                    if (!allowIndexed) {
                        throwError(i);
                    }

                    node.indexed = true;
                    node.name = "";
                }

                if (checkModifier(node.type, node.name)) {
                    node.name = "";
                }

                node.type = verifyType(node.type);
                var sibling = newNode(node.parent); //{ type: "", name: "", parent: node.parent, state: { allowType: true } };

                node.parent.components.push(sibling);
                delete node.parent;
                node = sibling;
                break;
                // Hit a space...

            case " ":
                // If reading type, the type is done and may read a param or name
                if (node.state.allowType) {
                    if (node.type !== "") {
                        node.type = verifyType(node.type);
                        delete node.state.allowType;
                        node.state.allowName = true;
                        node.state.allowParams = true;
                    }
                } // If reading name, the name is done


                if (node.state.allowName) {
                    if (node.name !== "") {
                        if (node.name === "indexed") {
                            if (!allowIndexed) {
                                throwError(i);
                            }

                            if (node.indexed) {
                                throwError(i);
                            }

                            node.indexed = true;
                            node.name = "";
                        } else if (checkModifier(node.type, node.name)) {
                            node.name = "";
                        } else {
                            node.state.allowName = false;
                        }
                    }
                }

                break;

            case "[":
                if (!node.state.allowArray) {
                    throwError(i);
                }

                node.type += c;
                node.state.allowArray = false;
                node.state.allowName = false;
                node.state.readArray = true;
                break;

            case "]":
                if (!node.state.readArray) {
                    throwError(i);
                }

                node.type += c;
                node.state.readArray = false;
                node.state.allowArray = true;
                node.state.allowName = true;
                break;

            default:
                if (node.state.allowType) {
                    node.type += c;
                    node.state.allowParams = true;
                    node.state.allowArray = true;
                } else if (node.state.allowName) {
                    node.name += c;
                    delete node.state.allowArray;
                } else if (node.state.readArray) {
                    node.type += c;
                } else {
                    throwError(i);
                }

        }
    }

    if (node.parent) {
        logger.throwArgumentError("unexpected eof", "param", param);
    }

    delete parent.state;

    if (node.name === "indexed") {
        if (!allowIndexed) {
            throwError(originalParam.length - 7);
        }

        if (node.indexed) {
            throwError(originalParam.length - 7);
        }

        node.indexed = true;
        node.name = "";
    } else if (checkModifier(node.type, node.name)) {
        node.name = "";
    }

    parent.type = verifyType(parent.type);
    return parent;
}

function populate(object, params) {
    for (var key in params) {
        defineReadOnly(object, key, params[key]);
    }
}

export var FormatTypes = Object.freeze({
    // Bare formatting, as is needed for computing a sighash of an event or function
    sighash: "sighash",
    // Human-Readable with Minimal spacing and without names (compact human-readable)
    minimal: "minimal",
    // Human-Readble with nice spacing, including all names
    full: "full",
    // JSON-format a la Solidity
    json: "json"
});
var paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
export var ParamType = /*#__PURE__*/ function() {
    function ParamType(constructorGuard, params) {
        _classCallCheck(this, ParamType);

        if (constructorGuard !== _constructorGuard) {
            logger.throwError("use fromString", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new ParamType()"
            });
        }

        populate(this, params);
        var match = this.type.match(paramTypeArray);

        if (match) {
            populate(this, {
                arrayLength: parseInt(match[2] || "-1"),
                arrayChildren: ParamType.fromObject({
                    type: match[1],
                    components: this.components
                }),
                baseType: "array"
            });
        } else {
            populate(this, {
                arrayLength: null,
                arrayChildren: null,
                baseType: this.components != null ? "tuple" : this.type
            });
        }

        this._isParamType = true;
        Object.freeze(this);
    } // Format the parameter fragment
    //   - sighash: "(uint256,address)"
    //   - minimal: "tuple(uint256,address) indexed"
    //   - full:    "tuple(uint256 foo, addres bar) indexed baz"


    _createClass(ParamType, [{
        key: "format",
        value: function format(_format) {
            if (!_format) {
                _format = FormatTypes.sighash;
            }

            if (!FormatTypes[_format]) {
                logger.throwArgumentError("invalid format type", "format", _format);
            }

            if (_format === FormatTypes.json) {
                var _result = {
                    type: this.baseType === "tuple" ? "tuple" : this.type,
                    name: this.name || undefined
                };

                if (typeof this.indexed === "boolean") {
                    _result.indexed = this.indexed;
                }

                if (this.components) {
                    _result.components = this.components.map(function(comp) {
                        return JSON.parse(comp.format(_format));
                    });
                }

                return JSON.stringify(_result);
            }

            var result = ""; // Array

            if (this.baseType === "array") {
                result += this.arrayChildren.format(_format);
                result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
            } else {
                if (this.baseType === "tuple") {
                    if (_format !== FormatTypes.sighash) {
                        result += this.type;
                    }

                    result += "(" + this.components.map(function(comp) {
                        return comp.format(_format);
                    }).join(_format === FormatTypes.full ? ", " : ",") + ")";
                } else {
                    result += this.type;
                }
            }

            if (_format !== FormatTypes.sighash) {
                if (this.indexed === true) {
                    result += " indexed";
                }

                if (_format === FormatTypes.full && this.name) {
                    result += " " + this.name;
                }
            }

            return result;
        }
    }], [{
        key: "from",
        value: function from(value, allowIndexed) {
            if (typeof value === "string") {
                return ParamType.fromString(value, allowIndexed);
            }

            return ParamType.fromObject(value);
        }
    }, {
        key: "fromObject",
        value: function fromObject(value) {
            if (ParamType.isParamType(value)) {
                return value;
            }

            return new ParamType(_constructorGuard, {
                name: value.name || null,
                type: verifyType(value.type),
                indexed: value.indexed == null ? null : !!value.indexed,
                components: value.components ? value.components.map(ParamType.fromObject) : null
            });
        }
    }, {
        key: "fromString",
        value: function fromString(value, allowIndexed) {
            function ParamTypify(node) {
                return ParamType.fromObject({
                    name: node.name,
                    type: node.type,
                    indexed: node.indexed,
                    components: node.components
                });
            }

            return ParamTypify(parseParamType(value, !!allowIndexed));
        }
    }, {
        key: "isParamType",
        value: function isParamType(value) {
            return !!(value != null && value._isParamType);
        }
    }]);

    return ParamType;
}();;

function parseParams(value, allowIndex) {
    return splitNesting(value).map(function(param) {
        return ParamType.fromString(param, allowIndex);
    });
}

export var Fragment = /*#__PURE__*/ function() {
    function Fragment(constructorGuard, params) {
        _classCallCheck(this, Fragment);

        if (constructorGuard !== _constructorGuard) {
            logger.throwError("use a static from method", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "new Fragment()"
            });
        }

        populate(this, params);
        this._isFragment = true;
        Object.freeze(this);
    }

    _createClass(Fragment, null, [{
        key: "from",
        value: function from(value) {
            if (Fragment.isFragment(value)) {
                return value;
            }

            if (typeof value === "string") {
                return Fragment.fromString(value);
            }

            return Fragment.fromObject(value);
        }
    }, {
        key: "fromObject",
        value: function fromObject(value) {
            if (Fragment.isFragment(value)) {
                return value;
            }

            switch (value.type) {
                case "function":
                    return FunctionFragment.fromObject(value);

                case "event":
                    return EventFragment.fromObject(value);

                case "constructor":
                    return ConstructorFragment.fromObject(value);

                case "fallback":
                case "receive":
                    // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?
                    return null;
            }

            return logger.throwArgumentError("invalid fragment object", "value", value);
        }
    }, {
        key: "fromString",
        value: function fromString(value) {
            // Make sure the "returns" is surrounded by a space and all whitespace is exactly one space
            value = value.replace(/\s/g, " ");
            value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
            value = value.trim();

            if (value.split(" ")[0] === "event") {
                return EventFragment.fromString(value.substring(5).trim());
            } else if (value.split(" ")[0] === "function") {
                return FunctionFragment.fromString(value.substring(8).trim());
            } else if (value.split("(")[0].trim() === "constructor") {
                return ConstructorFragment.fromString(value.trim());
            }

            return logger.throwArgumentError("unsupported fragment", "value", value);
        }
    }, {
        key: "isFragment",
        value: function isFragment(value) {
            return !!(value && value._isFragment);
        }
    }]);

    return Fragment;
}();
export var EventFragment = /*#__PURE__*/ function(_Fragment) {
    _inherits(EventFragment, _Fragment);

    function EventFragment() {
        _classCallCheck(this, EventFragment);

        return _possibleConstructorReturn(this, _getPrototypeOf(EventFragment).apply(this, arguments));
    }

    _createClass(EventFragment, [{
        key: "format",
        value: function format(_format2) {
            if (!_format2) {
                _format2 = FormatTypes.sighash;
            }

            if (!FormatTypes[_format2]) {
                logger.throwArgumentError("invalid format type", "format", _format2);
            }

            if (_format2 === FormatTypes.json) {
                return JSON.stringify({
                    type: "event",
                    anonymous: this.anonymous,
                    name: this.name,
                    inputs: this.inputs.map(function(input) {
                        return JSON.parse(input.format(_format2));
                    })
                });
            }

            var result = "";

            if (_format2 !== FormatTypes.sighash) {
                result += "event ";
            }

            result += this.name + "(" + this.inputs.map(function(input) {
                return input.format(_format2);
            }).join(_format2 === FormatTypes.full ? ", " : ",") + ") ";

            if (_format2 !== FormatTypes.sighash) {
                if (this.anonymous) {
                    result += "anonymous ";
                }
            }

            return result.trim();
        }
    }], [{
        key: "from",
        value: function from(value) {
            if (typeof value === "string") {
                return EventFragment.fromString(value);
            }

            return EventFragment.fromObject(value);
        }
    }, {
        key: "fromObject",
        value: function fromObject(value) {
            if (EventFragment.isEventFragment(value)) {
                return value;
            }

            if (value.type !== "event") {
                logger.throwArgumentError("invalid event object", "value", value);
            }

            var params = {
                name: verifyIdentifier(value.name),
                anonymous: value.anonymous,
                inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
                type: "event"
            };
            return new EventFragment(_constructorGuard, params);
        }
    }, {
        key: "fromString",
        value: function fromString(value) {
            var match = value.match(regexParen);

            if (!match) {
                logger.throwArgumentError("invalid event string", "value", value);
            }

            var anonymous = false;
            match[3].split(" ").forEach(function(modifier) {
                switch (modifier.trim()) {
                    case "anonymous":
                        anonymous = true;
                        break;

                    case "":
                        break;

                    default:
                        logger.warn("unknown modifier: " + modifier);
                }
            });
            return EventFragment.fromObject({
                name: match[1].trim(),
                anonymous: anonymous,
                inputs: parseParams(match[2], true),
                type: "event"
            });
        }
    }, {
        key: "isEventFragment",
        value: function isEventFragment(value) {
            return value && value._isFragment && value.type === "event";
        }
    }]);

    return EventFragment;
}(Fragment);

function parseGas(value, params) {
    params.gas = null;
    var comps = value.split("@");

    if (comps.length !== 1) {
        if (comps.length > 2) {
            logger.throwArgumentError("invalid human-readable ABI signature", "value", value);
        }

        if (!comps[1].match(/^[0-9]+$/)) {
            logger.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
        }

        params.gas = BigNumber.from(comps[1]);
        return comps[0];
    }

    return value;
}

function parseModifiers(value, params) {
    params.constant = false;
    params.payable = false;
    params.stateMutability = "nonpayable";
    value.split(" ").forEach(function(modifier) {
        switch (modifier.trim()) {
            case "constant":
                params.constant = true;
                break;

            case "payable":
                params.payable = true;
                params.stateMutability = "payable";
                break;

            case "nonpayable":
                params.payable = false;
                params.stateMutability = "nonpayable";
                break;

            case "pure":
                params.constant = true;
                params.stateMutability = "pure";
                break;

            case "view":
                params.constant = true;
                params.stateMutability = "view";
                break;

            case "external":
            case "public":
            case "":
                break;

            default:
                console.log("unknown modifier: " + modifier);
        }
    });
}

function verifyState(value) {
    var result = {
        constant: false,
        payable: true,
        stateMutability: "payable"
    };

    if (value.stateMutability != null) {
        result.stateMutability = value.stateMutability; // Set (and check things are consistent) the constant property

        result.constant = result.stateMutability === "view" || result.stateMutability === "pure";

        if (value.constant != null) {
            if (!!value.constant !== result.constant) {
                logger.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
            }
        } // Set (and check things are consistent) the payable property


        result.payable = result.stateMutability === "payable";

        if (value.payable != null) {
            if (!!value.payable !== result.payable) {
                logger.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
            }
        }
    } else if (value.payable != null) {
        result.payable = !!value.payable; // If payable we can assume non-constant; otherwise we can't assume

        if (value.constant == null && !result.payable && value.type !== "constructor") {
            logger.throwArgumentError("unable to determine stateMutability", "value", value);
        }

        result.constant = !!value.constant;

        if (result.constant) {
            result.stateMutability = "view";
        } else {
            result.stateMutability = result.payable ? "payable" : "nonpayable";
        }

        if (result.payable && result.constant) {
            logger.throwArgumentError("cannot have constant payable function", "value", value);
        }
    } else if (value.constant != null) {
        result.constant = !!value.constant;
        result.payable = !result.constant;
        result.stateMutability = result.constant ? "view" : "payable";
    } else if (value.type !== "constructor") {
        logger.throwArgumentError("unable to determine stateMutability", "value", value);
    }

    return result;
}

export var ConstructorFragment = /*#__PURE__*/ function(_Fragment2) {
    _inherits(ConstructorFragment, _Fragment2);

    function ConstructorFragment() {
        _classCallCheck(this, ConstructorFragment);

        return _possibleConstructorReturn(this, _getPrototypeOf(ConstructorFragment).apply(this, arguments));
    }

    _createClass(ConstructorFragment, [{
        key: "format",
        value: function format(_format3) {
            if (!_format3) {
                _format3 = FormatTypes.sighash;
            }

            if (!FormatTypes[_format3]) {
                logger.throwArgumentError("invalid format type", "format", _format3);
            }

            if (_format3 === FormatTypes.json) {
                return JSON.stringify({
                    type: "constructor",
                    stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : undefined,
                    payble: this.payable,
                    gas: this.gas ? this.gas.toNumber() : undefined,
                    inputs: this.inputs.map(function(input) {
                        return JSON.parse(input.format(_format3));
                    })
                });
            }

            if (_format3 === FormatTypes.sighash) {
                logger.throwError("cannot format a constructor for sighash", Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "format(sighash)"
                });
            }

            var result = "constructor(" + this.inputs.map(function(input) {
                return input.format(_format3);
            }).join(_format3 === FormatTypes.full ? ", " : ",") + ") ";

            if (this.stateMutability && this.stateMutability !== "nonpayable") {
                result += this.stateMutability + " ";
            }

            return result.trim();
        }
    }], [{
        key: "from",
        value: function from(value) {
            if (typeof value === "string") {
                return ConstructorFragment.fromString(value);
            }

            return ConstructorFragment.fromObject(value);
        }
    }, {
        key: "fromObject",
        value: function fromObject(value) {
            if (ConstructorFragment.isConstructorFragment(value)) {
                return value;
            }

            if (value.type !== "constructor") {
                logger.throwArgumentError("invalid constructor object", "value", value);
            }

            var state = verifyState(value);

            if (state.constant) {
                logger.throwArgumentError("constructor cannot be constant", "value", value);
            }

            var params = {
                name: null,
                type: value.type,
                inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
                payable: state.payable,
                stateMutability: state.stateMutability,
                gas: value.gas ? BigNumber.from(value.gas) : null
            };
            return new ConstructorFragment(_constructorGuard, params);
        }
    }, {
        key: "fromString",
        value: function fromString(value) {
            var params = {
                type: "constructor"
            };
            value = parseGas(value, params);
            var parens = value.match(regexParen);

            if (!parens || parens[1].trim() !== "constructor") {
                logger.throwArgumentError("invalid constructor string", "value", value);
            }

            params.inputs = parseParams(parens[2].trim(), false);
            parseModifiers(parens[3].trim(), params);
            return ConstructorFragment.fromObject(params);
        }
    }, {
        key: "isConstructorFragment",
        value: function isConstructorFragment(value) {
            return value && value._isFragment && value.type === "constructor";
        }
    }]);

    return ConstructorFragment;
}(Fragment);
export var FunctionFragment = /*#__PURE__*/ function(_ConstructorFragment) {
    _inherits(FunctionFragment, _ConstructorFragment);

    function FunctionFragment() {
        _classCallCheck(this, FunctionFragment);

        return _possibleConstructorReturn(this, _getPrototypeOf(FunctionFragment).apply(this, arguments));
    }

    _createClass(FunctionFragment, [{
        key: "format",
        value: function format(_format4) {
            if (!_format4) {
                _format4 = FormatTypes.sighash;
            }

            if (!FormatTypes[_format4]) {
                logger.throwArgumentError("invalid format type", "format", _format4);
            }

            if (_format4 === FormatTypes.json) {
                return JSON.stringify({
                    type: "function",
                    name: this.name,
                    constant: this.constant,
                    stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : undefined,
                    payble: this.payable,
                    gas: this.gas ? this.gas.toNumber() : undefined,
                    inputs: this.inputs.map(function(input) {
                        return JSON.parse(input.format(_format4));
                    }),
                    ouputs: this.outputs.map(function(output) {
                        return JSON.parse(output.format(_format4));
                    })
                });
            }

            var result = "";

            if (_format4 !== FormatTypes.sighash) {
                result += "function ";
            }

            result += this.name + "(" + this.inputs.map(function(input) {
                return input.format(_format4);
            }).join(_format4 === FormatTypes.full ? ", " : ",") + ") ";

            if (_format4 !== FormatTypes.sighash) {
                if (this.stateMutability) {
                    if (this.stateMutability !== "nonpayable") {
                        result += this.stateMutability + " ";
                    }
                } else if (this.constant) {
                    result += "view ";
                }

                if (this.outputs && this.outputs.length) {
                    result += "returns (" + this.outputs.map(function(output) {
                        return output.format(_format4);
                    }).join(", ") + ") ";
                }

                if (this.gas != null) {
                    result += "@" + this.gas.toString() + " ";
                }
            }

            return result.trim();
        }
    }], [{
        key: "from",
        value: function from(value) {
            if (typeof value === "string") {
                return FunctionFragment.fromString(value);
            }

            return FunctionFragment.fromObject(value);
        }
    }, {
        key: "fromObject",
        value: function fromObject(value) {
            if (FunctionFragment.isFunctionFragment(value)) {
                return value;
            }

            if (value.type !== "function") {
                logger.throwArgumentError("invalid function object", "value", value);
            }

            var state = verifyState(value);
            var params = {
                type: value.type,
                name: verifyIdentifier(value.name),
                constant: state.constant,
                inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
                outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],
                payable: state.payable,
                stateMutability: state.stateMutability,
                gas: value.gas ? BigNumber.from(value.gas) : null
            };
            return new FunctionFragment(_constructorGuard, params);
        }
    }, {
        key: "fromString",
        value: function fromString(value) {
            var params = {
                type: "function"
            };
            value = parseGas(value, params);
            var comps = value.split(" returns ");

            if (comps.length > 2) {
                logger.throwArgumentError("invalid function string", "value", value);
            }

            var parens = comps[0].match(regexParen);

            if (!parens) {
                logger.throwArgumentError("invalid function signature", "value", value);
            }

            params.name = parens[1].trim();

            if (params.name) {
                verifyIdentifier(params.name);
            }

            params.inputs = parseParams(parens[2], false);
            parseModifiers(parens[3].trim(), params); // We have outputs

            if (comps.length > 1) {
                var returns = comps[1].match(regexParen);

                if (returns[1].trim() != "" || returns[3].trim() != "") {
                    logger.throwArgumentError("unexpected tokens", "value", value);
                }

                params.outputs = parseParams(returns[2], false);
            } else {
                params.outputs = [];
            }

            return FunctionFragment.fromObject(params);
        }
    }, {
        key: "isFunctionFragment",
        value: function isFunctionFragment(value) {
            return value && value._isFragment && value.type === "function";
        }
    }]);

    return FunctionFragment;
}(ConstructorFragment); //export class ErrorFragment extends Fragment {
//}
//export class StructFragment extends Fragment {
//}

function verifyType(type) {
    // These need to be transformed to their full description
    if (type.match(/^uint($|[^1-9])/)) {
        type = "uint256" + type.substring(4);
    } else if (type.match(/^int($|[^1-9])/)) {
        type = "int256" + type.substring(3);
    } // @TODO: more verification


    return type;
}

var regexIdentifier = new RegExp("^[A-Za-z_][A-Za-z0-9_]*$");

function verifyIdentifier(value) {
    if (!value || !value.match(regexIdentifier)) {
        logger.throwArgumentError("invalid identifier \"".concat(value, "\""), "value", value);
    }

    return value;
}

var regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");

function splitNesting(value) {
    value = value.trim();
    var result = [];
    var accum = "";
    var depth = 0;

    for (var offset = 0; offset < value.length; offset++) {
        var c = value[offset];

        if (c === "," && depth === 0) {
            result.push(accum);
            accum = "";
        } else {
            accum += c;

            if (c === "(") {
                depth++;
            } else if (c === ")") {
                depth--;

                if (depth === -1) {
                    logger.throwArgumentError("unbalanced parenthesis", "value", value);
                }
            }
        }
    }

    if (accum) {
        result.push(accum);
    }

    return result;
}