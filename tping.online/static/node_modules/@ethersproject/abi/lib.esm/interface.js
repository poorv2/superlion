"use strict";

import _createClass from "/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass";
import _classCallCheck from "/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck";
import _possibleConstructorReturn from "/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf";
import _inherits from "/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits";
import {
    getAddress as _getAddress
} from "@ethersproject/address";
import {
    BigNumber
} from "@ethersproject/bignumber";
import {
    arrayify,
    concat,
    hexDataSlice,
    hexlify,
    hexZeroPad,
    isHexString
} from "@ethersproject/bytes";
import {
    id
} from "@ethersproject/hash";
import {
    keccak256
} from "@ethersproject/keccak256";
import {
    defineReadOnly,
    Description,
    getStatic
} from "@ethersproject/properties";
import {
    defaultAbiCoder
} from "./abi-coder";
import {
    checkResultErrors
} from "./coders/abstract-coder";
import {
    ConstructorFragment,
    EventFragment,
    FormatTypes,
    Fragment,
    FunctionFragment,
    ParamType
} from "./fragments";
import {
    Logger
} from "@ethersproject/logger";
import {
    version
} from "./_version";
var logger = new Logger(version);
export {
    checkResultErrors
};
export var LogDescription = /*#__PURE__*/ function(_Description) {
    _inherits(LogDescription, _Description);

    function LogDescription() {
        _classCallCheck(this, LogDescription);

        return _possibleConstructorReturn(this, _getPrototypeOf(LogDescription).apply(this, arguments));
    }

    return LogDescription;
}(Description);
export var TransactionDescription = /*#__PURE__*/ function(_Description2) {
    _inherits(TransactionDescription, _Description2);

    function TransactionDescription() {
        _classCallCheck(this, TransactionDescription);

        return _possibleConstructorReturn(this, _getPrototypeOf(TransactionDescription).apply(this, arguments));
    }

    return TransactionDescription;
}(Description);
export var Indexed = /*#__PURE__*/ function(_Description3) {
    _inherits(Indexed, _Description3);

    function Indexed() {
        _classCallCheck(this, Indexed);

        return _possibleConstructorReturn(this, _getPrototypeOf(Indexed).apply(this, arguments));
    }

    _createClass(Indexed, null, [{
        key: "isIndexed",
        value: function isIndexed(value) {
            return !!(value && value._isIndexed);
        }
    }]);

    return Indexed;
}(Description);

function wrapAccessError(property, error) {
    var wrap = new Error("deferred error during ABI decoding triggered accessing ".concat(property));
    wrap.error = error;
    return wrap;
}
/*
function checkNames(fragment: Fragment, type: "input" | "output", params: Array<ParamType>): void {
    params.reduce((accum, param) => {
        if (param.name) {
            if (accum[param.name]) {
                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format("full") }`, "fragment", fragment);
            }
            accum[param.name] = true;
        }
        return accum;
    }, <{ [ name: string ]: boolean }>{ });
}
*/


export var Interface = /*#__PURE__*/ function() {
    function Interface(fragments) {
        var _this = this;

        _classCallCheck(this, Interface);

        logger.checkNew(this instanceof Interface ? this.constructor : void 0, Interface);
        var abi = [];

        if (typeof fragments === "string") {
            abi = JSON.parse(fragments);
        } else {
            abi = fragments;
        }

        defineReadOnly(this, "fragments", abi.map(function(fragment) {
            return Fragment.from(fragment);
        }).filter(function(fragment) {
            return fragment != null;
        }));
        defineReadOnly(this, "_abiCoder", getStatic(this instanceof Interface ? this.constructor : void 0, "getAbiCoder")());
        defineReadOnly(this, "functions", {});
        defineReadOnly(this, "errors", {});
        defineReadOnly(this, "events", {});
        defineReadOnly(this, "structs", {}); // Add all fragments by their signature

        this.fragments.forEach(function(fragment) {
            var bucket = null;

            switch (fragment.type) {
                case "constructor":
                    if (_this.deploy) {
                        logger.warn("duplicate definition - constructor");
                        return;
                    } //checkNames(fragment, "input", fragment.inputs);


                    defineReadOnly(_this, "deploy", fragment);
                    return;

                case "function":
                    //checkNames(fragment, "input", fragment.inputs);
                    //checkNames(fragment, "output", (<FunctionFragment>fragment).outputs);
                    bucket = _this.functions;
                    break;

                case "event":
                    //checkNames(fragment, "input", fragment.inputs);
                    bucket = _this.events;
                    break;

                default:
                    return;
            }

            var signature = fragment.format();

            if (bucket[signature]) {
                logger.warn("duplicate definition - " + signature);
                return;
            }

            bucket[signature] = fragment;
        }); // If we do not have a constructor add a default

        if (!this.deploy) {
            defineReadOnly(this, "deploy", ConstructorFragment.from({
                payable: false,
                type: "constructor"
            }));
        }

        defineReadOnly(this, "_isInterface", true);
    }

    _createClass(Interface, [{
        key: "format",
        value: function format(_format) {
            if (!_format) {
                _format = FormatTypes.full;
            }

            if (_format === FormatTypes.sighash) {
                logger.throwArgumentError("interface does not support formatting sighash", "format", _format);
            }

            var abi = this.fragments.map(function(fragment) {
                return fragment.format(_format);
            }); // We need to re-bundle the JSON fragments a bit

            if (_format === FormatTypes.json) {
                return JSON.stringify(abi.map(function(j) {
                    return JSON.parse(j);
                }));
            }

            return abi;
        } // Sub-classes can override these to handle other blockchains

    }, {
        key: "getFunction",
        // Find a function definition by any means necessary (unless it is ambiguous)
        value: function getFunction(nameOrSignatureOrSighash) {
            if (isHexString(nameOrSignatureOrSighash)) {
                for (var name in this.functions) {
                    if (nameOrSignatureOrSighash === this.getSighash(name)) {
                        return this.functions[name];
                    }
                }

                logger.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
            } // It is a bare name, look up the function (will return null if ambiguous)


            if (nameOrSignatureOrSighash.indexOf("(") === -1) {
                var _name = nameOrSignatureOrSighash.trim();

                var matching = Object.keys(this.functions).filter(function(f) {
                    return f.split("("
                        /* fix:) */
                    )[0] === _name;
                });

                if (matching.length === 0) {
                    logger.throwArgumentError("no matching function", "name", _name);
                } else if (matching.length > 1) {
                    logger.throwArgumentError("multiple matching functions", "name", _name);
                }

                return this.functions[matching[0]];
            } // Normlize the signature and lookup the function


            var result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];

            if (!result) {
                logger.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
            }

            return result;
        } // Find an event definition by any means necessary (unless it is ambiguous)

    }, {
        key: "getEvent",
        value: function getEvent(nameOrSignatureOrTopic) {
            if (isHexString(nameOrSignatureOrTopic)) {
                var topichash = nameOrSignatureOrTopic.toLowerCase();

                for (var name in this.events) {
                    if (topichash === this.getEventTopic(name)) {
                        return this.events[name];
                    }
                }

                logger.throwArgumentError("no matching event", "topichash", topichash);
            } // It is a bare name, look up the function (will return null if ambiguous)


            if (nameOrSignatureOrTopic.indexOf("(") === -1) {
                var _name2 = nameOrSignatureOrTopic.trim();

                var matching = Object.keys(this.events).filter(function(f) {
                    return f.split("("
                        /* fix:) */
                    )[0] === _name2;
                });

                if (matching.length === 0) {
                    logger.throwArgumentError("no matching event", "name", _name2);
                } else if (matching.length > 1) {
                    logger.throwArgumentError("multiple matching events", "name", _name2);
                }

                return this.events[matching[0]];
            } // Normlize the signature and lookup the function


            var result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];

            if (!result) {
                logger.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
            }

            return result;
        } // Get the sighash (the bytes4 selector) used by Solidity to identify a function

    }, {
        key: "getSighash",
        value: function getSighash(functionFragment) {
            if (typeof functionFragment === "string") {
                functionFragment = this.getFunction(functionFragment);
            }

            return getStatic(this.constructor, "getSighash")(functionFragment);
        } // Get the topic (the bytes32 hash) used by Solidity to identify an event

    }, {
        key: "getEventTopic",
        value: function getEventTopic(eventFragment) {
            if (typeof eventFragment === "string") {
                eventFragment = this.getEvent(eventFragment);
            }

            return getStatic(this.constructor, "getEventTopic")(eventFragment);
        }
    }, {
        key: "_decodeParams",
        value: function _decodeParams(params, data) {
            return this._abiCoder.decode(params, data);
        }
    }, {
        key: "_encodeParams",
        value: function _encodeParams(params, values) {
            return this._abiCoder.encode(params, values);
        }
    }, {
        key: "encodeDeploy",
        value: function encodeDeploy(values) {
            return this._encodeParams(this.deploy.inputs, values || []);
        } // Decode the data for a function call (e.g. tx.data)

    }, {
        key: "decodeFunctionData",
        value: function decodeFunctionData(functionFragment, data) {
            if (typeof functionFragment === "string") {
                functionFragment = this.getFunction(functionFragment);
            }

            var bytes = arrayify(data);

            if (hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {
                logger.throwArgumentError("data signature does not match function ".concat(functionFragment.name, "."), "data", hexlify(bytes));
            }

            return this._decodeParams(functionFragment.inputs, bytes.slice(4));
        } // Encode the data for a function call (e.g. tx.data)

    }, {
        key: "encodeFunctionData",
        value: function encodeFunctionData(functionFragment, values) {
            if (typeof functionFragment === "string") {
                functionFragment = this.getFunction(functionFragment);
            }

            return hexlify(concat([this.getSighash(functionFragment), this._encodeParams(functionFragment.inputs, values || [])]));
        } // Decode the result from a function call (e.g. from eth_call)

    }, {
        key: "decodeFunctionResult",
        value: function decodeFunctionResult(functionFragment, data) {
            if (typeof functionFragment === "string") {
                functionFragment = this.getFunction(functionFragment);
            }

            var bytes = arrayify(data);
            var reason = null;
            var errorSignature = null;

            switch (bytes.length % this._abiCoder._getWordSize()) {
                case 0:
                    try {
                        return this._abiCoder.decode(functionFragment.outputs, bytes);
                    } catch (error) {}

                    break;

                case 4:
                    if (hexlify(bytes.slice(0, 4)) === "0x08c379a0") {
                        errorSignature = "Error(string)";
                        reason = this._abiCoder.decode(["string"], bytes.slice(4))[0];
                    }

                    break;
            }

            return logger.throwError("call revert exception", Logger.errors.CALL_EXCEPTION, {
                method: functionFragment.format(),
                errorSignature: errorSignature,
                errorArgs: [reason],
                reason: reason
            });
        } // Encode the result for a function call (e.g. for eth_call)

    }, {
        key: "encodeFunctionResult",
        value: function encodeFunctionResult(functionFragment, values) {
            if (typeof functionFragment === "string") {
                functionFragment = this.getFunction(functionFragment);
            }

            return hexlify(this._abiCoder.encode(functionFragment.outputs, values || []));
        } // Create the filter for the event with search criteria (e.g. for eth_filterLog)

    }, {
        key: "encodeFilterTopics",
        value: function encodeFilterTopics(eventFragment, values) {
            var _this2 = this;

            if (typeof eventFragment === "string") {
                eventFragment = this.getEvent(eventFragment);
            }

            if (values.length > eventFragment.inputs.length) {
                logger.throwError("too many arguments for " + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {
                    argument: "values",
                    value: values
                });
            }

            var topics = [];

            if (!eventFragment.anonymous) {
                topics.push(this.getEventTopic(eventFragment));
            }

            var encodeTopic = function encodeTopic(param, value) {
                if (param.type === "string") {
                    return id(value);
                } else if (param.type === "bytes") {
                    return keccak256(hexlify(value));
                } // Check addresses are valid


                if (param.type === "address") {
                    _this2._abiCoder.encode(["address"], [value]);
                }

                return hexZeroPad(hexlify(value), 32);
            };

            values.forEach(function(value, index) {
                var param = eventFragment.inputs[index];

                if (!param.indexed) {
                    if (value != null) {
                        logger.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
                    }

                    return;
                }

                if (value == null) {
                    topics.push(null);
                } else if (param.baseType === "array" || param.baseType === "tuple") {
                    logger.throwArgumentError("filtering with tuples or arrays not supported", "contract." + param.name, value);
                } else if (Array.isArray(value)) {
                    topics.push(value.map(function(value) {
                        return encodeTopic(param, value);
                    }));
                } else {
                    topics.push(encodeTopic(param, value));
                }
            }); // Trim off trailing nulls

            while (topics.length && topics[topics.length - 1] === null) {
                topics.pop();
            }

            return topics;
        }
    }, {
        key: "encodeEventLog",
        value: function encodeEventLog(eventFragment, values) {
            var _this3 = this;

            if (typeof eventFragment === "string") {
                eventFragment = this.getEvent(eventFragment);
            }

            var topics = [];
            var dataTypes = [];
            var dataValues = [];

            if (!eventFragment.anonymous) {
                topics.push(this.getEventTopic(eventFragment));
            }

            if (values.length !== eventFragment.inputs.length) {
                logger.throwArgumentError("event arguments/values mismatch", "values", values);
            }

            eventFragment.inputs.forEach(function(param, index) {
                var value = values[index];

                if (param.indexed) {
                    if (param.type === "string") {
                        topics.push(id(value));
                    } else if (param.type === "bytes") {
                        topics.push(keccak256(value));
                    } else if (param.baseType === "tuple" || param.baseType === "array") {
                        // @TOOD
                        throw new Error("not implemented");
                    } else {
                        topics.push(_this3._abiCoder.encode([param.type], [value]));
                    }
                } else {
                    dataTypes.push(param);
                    dataValues.push(value);
                }
            });
            return {
                data: this._abiCoder.encode(dataTypes, dataValues),
                topics: topics
            };
        } // Decode a filter for the event and the search criteria

    }, {
        key: "decodeEventLog",
        value: function decodeEventLog(eventFragment, data, topics) {
            if (typeof eventFragment === "string") {
                eventFragment = this.getEvent(eventFragment);
            }

            if (topics != null && !eventFragment.anonymous) {
                var topicHash = this.getEventTopic(eventFragment);

                if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
                    logger.throwError("fragment/topic mismatch", Logger.errors.INVALID_ARGUMENT, {
                        argument: "topics[0]",
                        expected: topicHash,
                        value: topics[0]
                    });
                }

                topics = topics.slice(1);
            }

            var indexed = [];
            var nonIndexed = [];
            var dynamic = [];
            eventFragment.inputs.forEach(function(param, index) {
                if (param.indexed) {
                    if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
                        indexed.push(ParamType.fromObject({
                            type: "bytes32",
                            name: param.name
                        }));
                        dynamic.push(true);
                    } else {
                        indexed.push(param);
                        dynamic.push(false);
                    }
                } else {
                    nonIndexed.push(param);
                    dynamic.push(false);
                }
            });
            var resultIndexed = topics != null ? this._abiCoder.decode(indexed, concat(topics)) : null;

            var resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);

            var result = [];
            var nonIndexedIndex = 0,
                indexedIndex = 0;
            eventFragment.inputs.forEach(function(param, index) {
                if (param.indexed) {
                    if (resultIndexed == null) {
                        result[index] = new Indexed({
                            _isIndexed: true,
                            hash: null
                        });
                    } else if (dynamic[index]) {
                        result[index] = new Indexed({
                            _isIndexed: true,
                            hash: resultIndexed[indexedIndex++]
                        });
                    } else {
                        try {
                            result[index] = resultIndexed[indexedIndex++];
                        } catch (error) {
                            result[index] = error;
                        }
                    }
                } else {
                    try {
                        result[index] = resultNonIndexed[nonIndexedIndex++];
                    } catch (error) {
                        result[index] = error;
                    }
                } // Add the keyword argument if named and safe


                if (param.name && result[param.name] == null) {
                    var value = result[index]; // Make error named values throw on access

                    if (value instanceof Error) {
                        Object.defineProperty(result, param.name, {
                            get: function get() {
                                throw wrapAccessError("property ".concat(JSON.stringify(param.name)), value);
                            }
                        });
                    } else {
                        result[param.name] = value;
                    }
                }
            }); // Make all error indexed values throw on access

            var _loop = function _loop(i) {
                var value = result[i];

                if (value instanceof Error) {
                    Object.defineProperty(result, i, {
                        get: function get() {
                            throw wrapAccessError("index ".concat(i), value);
                        }
                    });
                }
            };

            for (var i = 0; i < result.length; i++) {
                _loop(i);
            }

            return Object.freeze(result);
        } // Given a transaction, find the matching function fragment (if any) and
        // determine all its properties and call parameters

    }, {
        key: "parseTransaction",
        value: function parseTransaction(tx) {
            var fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());

            if (!fragment) {
                return null;
            }

            return new TransactionDescription({
                args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
                functionFragment: fragment,
                name: fragment.name,
                signature: fragment.format(),
                sighash: this.getSighash(fragment),
                value: BigNumber.from(tx.value || "0")
            });
        } // Given an event log, find the matching event fragment (if any) and
        // determine all its properties and values

    }, {
        key: "parseLog",
        value: function parseLog(log) {
            var fragment = this.getEvent(log.topics[0]);

            if (!fragment || fragment.anonymous) {
                return null;
            } // @TODO: If anonymous, and the only method, and the input count matches, should we parse?
            //        Probably not, because just because it is the only event in the ABI does
            //        not mean we have the full ABI; maybe jsut a fragment?


            return new LogDescription({
                eventFragment: fragment,
                name: fragment.name,
                signature: fragment.format(),
                topic: this.getEventTopic(fragment),
                args: this.decodeEventLog(fragment, log.data, log.topics)
            });
        }
        /*
        static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
            if (Interface.isInterface(value)) {
                return value;
            }
            if (typeof(value) === "string") {
                return new Interface(JSON.parse(value));
            }
            return new Interface(value);
        }
        */

    }], [{
        key: "getAbiCoder",
        value: function getAbiCoder() {
            return defaultAbiCoder;
        }
    }, {
        key: "getAddress",
        value: function getAddress(address) {
            return _getAddress(address);
        }
    }, {
        key: "getSighash",
        value: function getSighash(functionFragment) {
            return hexDataSlice(id(functionFragment.format()), 0, 4);
        }
    }, {
        key: "getEventTopic",
        value: function getEventTopic(eventFragment) {
            return id(eventFragment.format());
        }
    }, {
        key: "isInterface",
        value: function isInterface(value) {
            return !!(value && value._isInterface);
        }
    }]);

    return Interface;
}();