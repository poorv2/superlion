"use strict";

import _classCallCheck from "/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass";
import {
    arrayify,
    concat,
    hexConcat,
    hexlify
} from "@ethersproject/bytes";
import {
    BigNumber
} from "@ethersproject/bignumber";
import {
    defineReadOnly
} from "@ethersproject/properties";
import {
    Logger
} from "@ethersproject/logger";
import {
    version
} from "../_version";
var logger = new Logger(version);
export function checkResultErrors(result) {
    // Find the first error (if any)
    var errors = [];

    var checkErrors = function checkErrors(path, object) {
        if (!Array.isArray(object)) {
            return;
        }

        for (var key in object) {
            var childPath = path.slice();
            childPath.push(key);

            try {
                checkErrors(childPath, object[key]);
            } catch (error) {
                errors.push({
                    path: childPath,
                    error: error
                });
            }
        }
    };

    checkErrors([], result);
    return errors;
}
export var Coder = /*#__PURE__*/ function() {
    function Coder(name, type, localName, dynamic) {
        _classCallCheck(this, Coder);

        // @TODO: defineReadOnly these
        this.name = name;
        this.type = type;
        this.localName = localName;
        this.dynamic = dynamic;
    }

    _createClass(Coder, [{
        key: "_throwError",
        value: function _throwError(message, value) {
            logger.throwArgumentError(message, this.localName, value);
        }
    }]);

    return Coder;
}();
export var Writer = /*#__PURE__*/ function() {
    function Writer(wordSize) {
        _classCallCheck(this, Writer);

        defineReadOnly(this, "wordSize", wordSize || 32);
        this._data = [];
        this._dataLength = 0;
        this._padding = new Uint8Array(wordSize);
    }

    _createClass(Writer, [{
        key: "_writeData",
        value: function _writeData(data) {
            this._data.push(data);

            this._dataLength += data.length;
            return data.length;
        }
    }, {
        key: "appendWriter",
        value: function appendWriter(writer) {
            return this._writeData(concat(writer._data));
        } // Arrayish items; padded on the right to wordSize

    }, {
        key: "writeBytes",
        value: function writeBytes(value) {
            var bytes = arrayify(value);
            var paddingOffset = bytes.length % this.wordSize;

            if (paddingOffset) {
                bytes = concat([bytes, this._padding.slice(paddingOffset)]);
            }

            return this._writeData(bytes);
        }
    }, {
        key: "_getValue",
        value: function _getValue(value) {
            var bytes = arrayify(BigNumber.from(value));

            if (bytes.length > this.wordSize) {
                logger.throwError("value out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
                    length: this.wordSize,
                    offset: bytes.length
                });
            }

            if (bytes.length % this.wordSize) {
                bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);
            }

            return bytes;
        } // BigNumberish items; padded on the left to wordSize

    }, {
        key: "writeValue",
        value: function writeValue(value) {
            return this._writeData(this._getValue(value));
        }
    }, {
        key: "writeUpdatableValue",
        value: function writeUpdatableValue() {
            var _this = this;

            var offset = this._data.length;

            this._data.push(this._padding);

            this._dataLength += this.wordSize;
            return function(value) {
                _this._data[offset] = _this._getValue(value);
            };
        }
    }, {
        key: "data",
        get: function get() {
            return hexConcat(this._data);
        }
    }, {
        key: "length",
        get: function get() {
            return this._dataLength;
        }
    }]);

    return Writer;
}();
export var Reader = /*#__PURE__*/ function() {
    function Reader(data, wordSize, coerceFunc, allowLoose) {
        _classCallCheck(this, Reader);

        defineReadOnly(this, "_data", arrayify(data));
        defineReadOnly(this, "wordSize", wordSize || 32);
        defineReadOnly(this, "_coerceFunc", coerceFunc);
        defineReadOnly(this, "allowLoose", allowLoose);
        this._offset = 0;
    }

    _createClass(Reader, [{
        key: "coerce",
        value: function coerce(name, value) {
            if (this._coerceFunc) {
                return this._coerceFunc(name, value);
            }

            return Reader.coerce(name, value);
        }
    }, {
        key: "_peekBytes",
        value: function _peekBytes(offset, length, loose) {
            var alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;

            if (this._offset + alignedLength > this._data.length) {
                if (this.allowLoose && loose && this._offset + length <= this._data.length) {
                    alignedLength = length;
                } else {
                    logger.throwError("data out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
                        length: this._data.length,
                        offset: this._offset + alignedLength
                    });
                }
            }

            return this._data.slice(this._offset, this._offset + alignedLength);
        }
    }, {
        key: "subReader",
        value: function subReader(offset) {
            return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
        }
    }, {
        key: "readBytes",
        value: function readBytes(length, loose) {
            var bytes = this._peekBytes(0, length, !!loose);

            this._offset += bytes.length; // @TODO: Make sure the length..end bytes are all 0?

            return bytes.slice(0, length);
        }
    }, {
        key: "readValue",
        value: function readValue() {
            return BigNumber.from(this.readBytes(this.wordSize));
        }
    }, {
        key: "data",
        get: function get() {
            return hexlify(this._data);
        }
    }, {
        key: "consumed",
        get: function get() {
            return this._offset;
        } // The default Coerce function

    }], [{
        key: "coerce",
        value: function coerce(name, value) {
            var match = name.match("^u?int([0-9]+)$");

            if (match && parseInt(match[1]) <= 48) {
                value = value.toNumber();
            }

            return value;
        }
    }]);

    return Reader;
}();