"use strict";

import _classCallCheck from "/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass";
import _possibleConstructorReturn from "/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf";
import _inherits from "/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits";
import {
    Logger
} from "@ethersproject/logger";
import {
    version
} from "../_version";
var logger = new Logger(version);
import {
    Coder,
    Writer
} from "./abstract-coder";
import {
    AnonymousCoder
} from "./anonymous";
export function pack(writer, coders, values) {
    var arrayValues = null;

    if (Array.isArray(values)) {
        arrayValues = values;
    } else if (values && typeof values === "object") {
        var unique = {};
        arrayValues = coders.map(function(coder) {
            var name = coder.localName;

            if (!name) {
                logger.throwError("cannot encode object for signature with missing names", Logger.errors.INVALID_ARGUMENT, {
                    argument: "values",
                    coder: coder,
                    value: values
                });
            }

            if (unique[name]) {
                logger.throwError("cannot encode object for signature with duplicate names", Logger.errors.INVALID_ARGUMENT, {
                    argument: "values",
                    coder: coder,
                    value: values
                });
            }

            unique[name] = true;
            return values[name];
        });
    } else {
        logger.throwArgumentError("invalid tuple value", "tuple", values);
    }

    if (coders.length !== arrayValues.length) {
        logger.throwArgumentError("types/value length mismatch", "tuple", values);
    }

    var staticWriter = new Writer(writer.wordSize);
    var dynamicWriter = new Writer(writer.wordSize);
    var updateFuncs = [];
    coders.forEach(function(coder, index) {
        var value = arrayValues[index];

        if (coder.dynamic) {
            // Get current dynamic offset (for the future pointer)
            var dynamicOffset = dynamicWriter.length; // Encode the dynamic value into the dynamicWriter

            coder.encode(dynamicWriter, value); // Prepare to populate the correct offset once we are done

            var updateFunc = staticWriter.writeUpdatableValue();
            updateFuncs.push(function(baseOffset) {
                updateFunc(baseOffset + dynamicOffset);
            });
        } else {
            coder.encode(staticWriter, value);
        }
    }); // Backfill all the dynamic offsets, now that we know the static length

    updateFuncs.forEach(function(func) {
        func(staticWriter.length);
    });
    var length = writer.appendWriter(staticWriter);
    length += writer.appendWriter(dynamicWriter);
    return length;
}
export function unpack(reader, coders) {
    var values = []; // A reader anchored to this base

    var baseReader = reader.subReader(0);
    coders.forEach(function(coder) {
        var value = null;

        if (coder.dynamic) {
            var offset = reader.readValue();
            var offsetReader = baseReader.subReader(offset.toNumber());

            try {
                value = coder.decode(offsetReader);
            } catch (error) {
                // Cannot recover from this
                if (error.code === Logger.errors.BUFFER_OVERRUN) {
                    throw error;
                }

                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
            }
        } else {
            try {
                value = coder.decode(reader);
            } catch (error) {
                // Cannot recover from this
                if (error.code === Logger.errors.BUFFER_OVERRUN) {
                    throw error;
                }

                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
            }
        }

        if (value != undefined) {
            values.push(value);
        }
    }); // We only output named properties for uniquely named coders

    var uniqueNames = coders.reduce(function(accum, coder) {
        var name = coder.localName;

        if (name) {
            if (!accum[name]) {
                accum[name] = 0;
            }

            accum[name]++;
        }

        return accum;
    }, {}); // Add any named parameters (i.e. tuples)

    coders.forEach(function(coder, index) {
        var name = coder.localName;

        if (!name || uniqueNames[name] !== 1) {
            return;
        }

        if (name === "length") {
            name = "_length";
        }

        if (values[name] != null) {
            return;
        }

        var value = values[index];

        if (value instanceof Error) {
            Object.defineProperty(values, name, {
                get: function get() {
                    throw value;
                }
            });
        } else {
            values[name] = value;
        }
    });

    var _loop = function _loop(i) {
        var value = values[i];

        if (value instanceof Error) {
            Object.defineProperty(values, i, {
                get: function get() {
                    throw value;
                }
            });
        }
    };

    for (var i = 0; i < values.length; i++) {
        _loop(i);
    }

    return Object.freeze(values);
}
export var ArrayCoder = /*#__PURE__*/ function(_Coder) {
    _inherits(ArrayCoder, _Coder);

    function ArrayCoder(coder, length, localName) {
        var _this;

        _classCallCheck(this, ArrayCoder);

        var type = coder.type + "[" + (length >= 0 ? length : "") + "]";
        var dynamic = length === -1 || coder.dynamic;
        _this = _possibleConstructorReturn(this, _getPrototypeOf(ArrayCoder).call(this, "array", type, localName, dynamic));
        _this.coder = coder;
        _this.length = length;
        return _this;
    }

    _createClass(ArrayCoder, [{
        key: "encode",
        value: function encode(writer, value) {
            if (!Array.isArray(value)) {
                this._throwError("expected array value", value);
            }

            var count = this.length;

            if (count === -1) {
                count = value.length;
                writer.writeValue(value.length);
            }

            logger.checkArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
            var coders = [];

            for (var i = 0; i < value.length; i++) {
                coders.push(this.coder);
            }

            return pack(writer, coders, value);
        }
    }, {
        key: "decode",
        value: function decode(reader) {
            var count = this.length;

            if (count === -1) {
                count = reader.readValue().toNumber();
            }

            var coders = [];

            for (var i = 0; i < count; i++) {
                coders.push(new AnonymousCoder(this.coder));
            }

            return reader.coerce(this.name, unpack(reader, coders));
        }
    }]);

    return ArrayCoder;
}(Coder);