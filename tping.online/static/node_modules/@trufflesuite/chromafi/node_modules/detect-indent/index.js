'use strict'; // detect either spaces or tabs but not both to properly handle tabs
// for indentation and spaces for alignment

function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;
            var F = function F() {};
            return {
                s: F,
                n: function n() {
                    if (i >= o.length) return {
                        done: true
                    };
                    return {
                        done: false,
                        value: o[i++]
                    };
                },
                e: function e(_e) {
                    throw _e;
                },
                f: F
            };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true,
        didErr = false,
        err;
    return {
        s: function s() {
            it = o[Symbol.iterator]();
        },
        n: function n() {
            var step = it.next();
            normalCompletion = step.done;
            return step;
        },
        e: function e(_e2) {
            didErr = true;
            err = _e2;
        },
        f: function f() {
            try {
                if (!normalCompletion && it.return != null) it.return();
            } finally {
                if (didErr) throw err;
            }
        }
    };
}

function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
    }
    return arr2;
}

var INDENT_RE = /^(?:( )+|\t+)/;

function getMostUsed(indents) {
    var result = 0;
    var maxUsed = 0;
    var maxWeight = 0;

    var _iterator = _createForOfIteratorHelper(indents),
        _step;

    try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var entry = _step.value;
            // TODO: use destructuring when targeting Node.js 6
            var key = entry[0];
            var val = entry[1];
            var u = val[0];
            var w = val[1];

            if (u > maxUsed || u === maxUsed && w > maxWeight) {
                maxUsed = u;
                maxWeight = w;
                result = Number(key);
            }
        }
    } catch (err) {
        _iterator.e(err);
    } finally {
        _iterator.f();
    }

    return result;
}

module.exports = function(str) {
    if (typeof str !== 'string') {
        throw new TypeError('Expected a string');
    } // used to see if tabs or spaces are the most used


    var tabs = 0;
    var spaces = 0; // remember the size of previous line's indentation

    var prev = 0; // remember how many indents/unindents as occurred for a given size
    // and how much lines follow a given indentation
    //
    // indents = {
    //    3: [1, 0],
    //    4: [1, 5],
    //    5: [1, 0],
    //   12: [1, 0],
    // }

    var indents = new Map(); // pointer to the array of last used indent

    var current; // whether the last action was an indent (opposed to an unindent)

    var isIndent;

    var _iterator2 = _createForOfIteratorHelper(str.split(/\n/g)),
        _step2;

    try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var line = _step2.value;

            if (!line) {
                // ignore empty lines
                continue;
            }

            var _indent = void 0;

            var matches = line.match(INDENT_RE);

            if (matches) {
                _indent = matches[0].length;

                if (matches[1]) {
                    spaces++;
                } else {
                    tabs++;
                }
            } else {
                _indent = 0;
            }

            var diff = _indent - prev;
            prev = _indent;

            if (diff) {
                // an indent or unindent has been detected
                isIndent = diff > 0;
                current = indents.get(isIndent ? diff : -diff);

                if (current) {
                    current[0]++;
                } else {
                    current = [1, 0];
                    indents.set(diff, current);
                }
            } else if (current) {
                // if the last action was an indent, increment the weight
                current[1] += Number(isIndent);
            }
        }
    } catch (err) {
        _iterator2.e(err);
    } finally {
        _iterator2.f();
    }

    var amount = getMostUsed(indents);
    var type;
    var indent;

    if (!amount) {
        type = null;
        indent = '';
    } else if (spaces >= tabs) {
        type = 'space';
        indent = ' '.repeat(amount);
    } else {
        type = 'tab';
        indent = '\t'.repeat(amount);
    }

    return {
        amount: amount,
        type: type,
        indent: indent
    };
};