var hljs = require('highlight.js');

var cheerio = require('cheerio');

var camelCase = require('camelcase');

var chalk = require('chalk');

var stripAnsi = require('strip-ansi');

var merge = require('lodash.merge');

var ansiMark = require('ansi-mark');

var stripIndent = require('strip-indent');

var detectIndent = require('detect-indent');

var darkPalette = {
    addition: chalk.green,
    attr: chalk.yellow,
    attribute: chalk.blue,
    attrString: chalk.cyan,
    base: chalk.white,
    builtIn: chalk.blue,
    builtInName: chalk.blue,
    bullet: chalk.magenta,
    class: chalk.green,
    code: chalk.yellow,
    comment: chalk.white.dim,
    deletion: chalk.red,
    doctag: chalk.blue,
    emphasis: chalk.magenta,
    function: chalk.white,
    formula: chalk.green,
    keyword: chalk.red,
    lineNumbers: chalk.grey,
    literal: chalk.magenta,
    link: chalk.blue.underline,
    meta: chalk.cyan,
    name: chalk.cyan,
    number: chalk.green,
    params: chalk.blue,
    quote: chalk.gray,
    regexp: chalk.magenta,
    selectorAttr: chalk.green,
    selectorClass: chalk.yellow,
    selectorId: chalk.blue,
    selectorPseudo: chalk.cyan,
    selectorTag: chalk.magenta,
    string: chalk.yellow,
    strong: chalk.red,
    subst: chalk.cyan,
    symbol: chalk.cyan,
    tag: chalk.blue,
    templateTag: chalk.magenta,
    templateVariable: chalk.green,
    title: chalk.green,
    trailingSpace: chalk,
    type: chalk.magenta,
    variable: chalk.red
};

var filter = function filter(node, opts) {
    var color;
    var text;
    var childText;

    if (node.type === 'text') {
        text = node.data;
        return text;
    }

    if (node.name === 'span' && node.type === 'tag') {
        color = camelCase(node.attribs.class.split('-')[1]);
    }

    if (node.childNodes && node.childNodes.length > 0) {
        childText = node.childNodes.map(function(childNode) {
            return filter(childNode, opts);
        }).join('');

        if (typeof color === 'string') {
            return opts.colors[color](childText);
        }

        return childText;
    }

    return '';
};

var findLongestLine = function findLongestLine(text, opts) {
    var tabPad = '';

    if (opts.$indent.tabs) {
        tabPad = String().padEnd(opts.consoleTabWidth, ' ');
    }

    var lines = stripAnsi(text).replace(/\t/g, tabPad).split('\n');
    var max = 0;
    lines.forEach(function(line) {
        if (line.length > max) {
            max = line.length;
        }
    });
    return max;
};

var padLine = function padLine(line, padding) {
    var padStr = String().padStart(padding, ' ');
    return padStr + line + padStr;
};

var getIndentStr = function getIndentStr(opts) {
    if (opts.$indent.tabs) {
        return String().padStart(1, '\t');
    } // Opts.$indent.spaces === true


    if (opts.tabsToSpaces === 0) {
        return "\0";
    }

    return String().padEnd(opts.tabsToSpaces, ' ');
};

var syntaxHlStr = function syntaxHlStr(lang, script, opts, indentStart) {
    var indentStr = getIndentStr(opts);

    if (opts.$indent.tabs) {
        script = script.replace(/\t/g, indentStr);
    }

    if (opts.$indent.spaces) {
        script = script.replace(/\t/g, indentStr);
    }

    if (indentStart) {
        script = indentStr + script;
    }

    var code = hljs.highlight(lang, script).value;
    var html = "<code>".concat(code, "</code>");
    var $body = cheerio.load(html).root().find('code')[0];
    var output = filter($body, opts);
    return output;
};

var syntaxHlJson = function syntaxHlJson(json, opts) {
    var indentStr = getIndentStr(opts);

    try {
        json = JSON.stringify(json, function(key, val) {
            if (val instanceof Function) {
                return "[FUNCTION]".concat(String(val), "[FUNCTION]");
            }

            return val;
        }, indentStr);
    } catch (err) {
        err.message = 'ðŸ¦…  Chromafi: ' + err.message;
        throw new Error(err);
    }

    var highlighted = json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+-]?\d+)?)/g, function(match) {
        var colorClass = 'number'; // eslint-disable-next-line unicorn/prefer-starts-ends-with

        if (/^"/.test(match)) {
            // eslint-disable-next-line unicorn/prefer-starts-ends-with
            if (/:$/.test(match)) {
                if (match.includes('-')) {
                    colorClass = 'attrString';
                    match = match.replace(/"/g, '\'');
                } else {
                    colorClass = 'attr';
                    match = match.replace(/"/g, '');
                }
            } else {
                colorClass = 'string';

                if (match.substr(1, 10) === '[FUNCTION]' && match.substr(match.length - 11, 10) === '[FUNCTION]') {
                    colorClass = 'function';
                } else {
                    match = match.replace(/"/g, '\'');
                    match = match.replace(/\\n/g, '\n');
                    match = match.replace(/\\t/g, indentStr);
                }
            }
        } else if (/true|false/.test(match)) {
            colorClass = 'literal';
        } else if (/null/.test(match)) {
            colorClass = 'literal';
        }

        return opts.colors[colorClass](match);
    });

    var getFnStrIndent = function getFnStrIndent(fnStr, opts) {
        fnStr = fnStr.replace(/\t/g, indentStr);
        var indent = detectIndent(fnStr);

        if (opts.$indent.spaces) {
            var indentLevel = indent.amount / opts.tabsToSpaces;
            return indentLevel;
        }

        if (opts.$indent.tabs) {
            var _indentLevel = indent.amount;
            return _indentLevel;
        }
    };

    var lines = highlighted.split('\n').map(function(line) {
        var fnParts = line.split('[FUNCTION]');

        if (fnParts.length === 3) {
            var plain = stripAnsi(line);
            var outerIndent;

            if (opts.$indent.spaces) {
                outerIndent = plain.match(/^[ \\t]*/)[0].length / opts.tabsToSpaces;
            }

            if (opts.$indent.tabs) {
                outerIndent = plain.match(/^\t*/)[0].length;
            }

            var fnStr = fnParts[1].replace(/"/g, '\'').replace(/\\n/g, '\n').replace(/\\t/g, '\t');
            var innerIndent = getFnStrIndent(fnStr, opts);
            var indentOffset = Math.abs(outerIndent - (innerIndent - 1));
            var re = new RegExp("\n(\t){".concat(indentOffset, "}"), 'g');
            var reTabbed = fnStr.replace(re, '\n').replace(/\\t/g, indentStr);
            var preFn = fnParts[0].substr(0, fnParts[0].length - 1);
            var postFn = fnParts[2].substr(1);
            var jsHighlighted = syntaxHlStr('javascript', reTabbed, opts);
            return preFn + jsHighlighted + postFn;
        }

        return line;
    }).join('\n');
    return lines;
};

var lineNumberPad = function lineNumberPad(number, opts) {
    if (!opts.lineNumbers) {
        return '';
    }

    var output = '';
    var offsetLineN = number + (opts.lineNumberStart - 1);

    if (opts.$indent.spaces) {
        var padStr = String().padStart(opts.lineNumberPad, ' ');
        var prePad = opts.lineNumberPad + opts.$maxDigitWidth;
        output = String(offsetLineN).padStart(prePad) + padStr;
    } // Indent using spaces - up to the tabwidth required to contain number str


    if (opts.$indent.tabs) {
        output = String(offsetLineN).padStart(opts.$maxTabSpace, ' ');
    }

    return opts.colors.lineNumbers(output);
};

var cropPadAndNumber = function cropPadAndNumber(text, opts) {
    var output = '';
    var lines = text.split('\n');
    var maxDigitWidth = String(lines.length + (opts.lineNumberStart - 1)).length; // Tabs needed to contain digits (so we dont break code tab indentation)

    var tabsNeeded = Math.ceil(maxDigitWidth / opts.consoleTabWidth);
    var maxTabSpace = tabsNeeded * opts.consoleTabWidth;
    var longestLineLen = findLongestLine(text, opts);
    opts.$maxTabSpace = maxTabSpace;
    opts.$maxDigitWidth = maxDigitWidth;
    lines.forEach(function(line, i) {
        var lineNumber = i + 1;

        if (lineNumber < opts.firstLine || lineNumber > opts.lastLine) {
            return;
        }

        var lineNo = lineNumberPad(lineNumber, opts);
        var tabCount = (line.match(/\t/g) || []).length;
        var tabAdjust = tabCount * opts.consoleTabWidth;
        var plain = stripAnsi(line).replace(/\t/g, '');
        var runLengthLine;

        if (opts.lineEndPad === true) {
            var linePad = String().padEnd(longestLineLen - plain.length - tabAdjust, ' ');
            runLengthLine = line + opts.colors.trailingSpace(linePad);
        } else {
            runLengthLine = line;
        }

        var lineOutput;

        if (opts.tabsToSpaces === false) {
            lineOutput = lineNo + runLengthLine;
        }

        if (typeof opts.tabsToSpaces === 'number') {
            lineOutput = lineNo + padLine(runLengthLine, opts.codePad);
        }

        output += lineOutput + '\n';
    });
    return opts.colors.base(output);
};

var decorate = function decorate(ansiStr, opts) {
    if (opts.highlight) {
        ansiStr = ansiMark(ansiStr, opts.highlight);
    }

    ansiStr = cropPadAndNumber(ansiStr, opts);
    return ansiStr;
};

var nameifyArrowFn = function nameifyArrowFn(fn, opts) {
    if (Reflect.has(fn, 'prototype') && Reflect.has(fn.prototype, 'constructor')) {
        return '';
    }

    return "".concat(opts.arrowKeyword, " ").concat(fn.name, " = ");
};

var procOpts = function procOpts() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var options = {
        lineNumbers: true,
        lang: 'javascript',
        lineNumberPad: 0,
        lineNumberStart: 1,
        start: 1,
        end: Infinity,
        highlight: false,
        stripIndent: true,
        codePad: 1,
        colors: darkPalette,
        tabsToSpaces: 4,
        consoleTabWidth: 8,
        arrowKeyword: 'const',
        lineEndPad: true
    };
    options = merge(options, opts);
    options.$indent = {
        spaces: typeof options.tabsToSpaces === 'number',
        tabs: typeof options.tabsToSpaces === 'boolean' && options.tabsToSpaces === false,
        size: typeof options.tabsToSpaces === 'number' ? options.tabsToSpaces : 1
    };
    return options;
};

var chromafi = function chromafi(value, opts) {
    opts = procOpts(opts);

    if (typeof value === 'function') {
        value = nameifyArrowFn(value, opts) + String(value);
        var indentStart = true;
        value = syntaxHlStr('javascript', value, opts, indentStart);
        value = stripIndent(value);
        value = decorate(value, opts);
        return value;
    }

    if (typeof value === 'string') {
        value = syntaxHlStr(opts.lang, value, opts);
        value = decorate(value, opts);
        return value;
    }

    if (typeof value === 'object') {
        value = syntaxHlJson(value, opts);
        value = decorate(value, opts);
        return value;
    }

    throw new Error('ðŸ¦…  Chromafi: You must pass a function, string or object.');
};

chromafi.hljs = hljs; // Expose hljs for modification

module.exports = chromafi;