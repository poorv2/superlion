"use strict";

var _classCallCheck = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck");

var _createClass = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass");

var _possibleConstructorReturn = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf");

var _inherits = require("/Applications/XAMPP/xamppfiles/htdocs/aa-superlion-mainnet/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits");

Object.defineProperty(exports, "__esModule", {
    value: true
});

var events_1 = require("events");

function safeApply(handler, context, args) {
    try {
        Reflect.apply(handler, context, args);
    } catch (err) {
        // Throw error after timeout so as not to interrupt the stack
        setTimeout(function() {
            throw err;
        });
    }
}

function arrayClone(arr) {
    var n = arr.length;
    var copy = new Array(n);

    for (var i = 0; i < n; i += 1) {
        copy[i] = arr[i];
    }

    return copy;
}

var SafeEventEmitter = /*#__PURE__*/ function(_events_1$EventEmitte) {
    _inherits(SafeEventEmitter, _events_1$EventEmitte);

    function SafeEventEmitter() {
        _classCallCheck(this, SafeEventEmitter);

        return _possibleConstructorReturn(this, _getPrototypeOf(SafeEventEmitter).apply(this, arguments));
    }

    _createClass(SafeEventEmitter, [{
        key: "emit",
        value: function emit(type) {
            var doError = type === 'error';
            var events = this._events;

            if (events !== undefined) {
                doError = doError && events.error === undefined;
            } else if (!doError) {
                return false;
            } // If there is no 'error' event listener then throw.


            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
            }

            if (doError) {
                var er;

                if (args.length > 0) {
                    er = args[0];
                }

                if (er instanceof Error) {
                    // Note: The comments on the `throw` lines are intentional, they show
                    // up in Node's output if this results in an unhandled exception.
                    throw er; // Unhandled 'error' event
                } // At least give some kind of context to the user


                var err = new Error("Unhandled error.".concat(er ? " (".concat(er.message, ")") : ''));
                err.context = er;
                throw err; // Unhandled 'error' event
            }

            var handler = events[type];

            if (handler === undefined) {
                return false;
            }

            if (typeof handler === 'function') {
                safeApply(handler, this, args);
            } else {
                var len = handler.length;
                var listeners = arrayClone(handler);

                for (var i = 0; i < len; i += 1) {
                    safeApply(listeners[i], this, args);
                }
            }

            return true;
        }
    }]);

    return SafeEventEmitter;
}(events_1.EventEmitter);

exports.default = SafeEventEmitter;